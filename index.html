
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不会开机的男孩</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="最近看了一些有关server的东西，一些很简单的东西，不外乎是一些文档规范，另外结合最近看的wwdc的一些video，觉得对软件架构（software architecture）认识又清楚了一些，这里记录下来。 software architecture 听上去是一个很大的概念， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="不会开机的男孩" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/jquery.min1.9.1.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">不会开机的男孩</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  	<li><a href="/">Blog</a></li>
  	<li><a href="/blog/archives">Archives</a></li>
	 <li><a href="/tags/index.html">Tags</a></li>
	<li><a href="/favorite/index.html">Favorite</a></li>
	<li><a href="/about/index.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/29/ios-architecture/">iOS APP 架构漫谈</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-29T15:48:00+08:00" pubdate data-updated="true">Aug 29<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/29/ios-architecture/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近看了一些有关server的东西，一些很简单的东西，不外乎是一些文档规范，另外结合最近看的wwdc的一些video，觉得对软件架构（software architecture）认识又清楚了一些，这里记录下来。</p>

<p>software architecture 听上去是一个很大的概念，实际上也包括很多东西，里面的争议也很多。在我看来软件架构最好放在小的场景中理解。</p>

<h2>问题1</h2>

<p>我们有2个页面。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/architecture0.gif' width='' height='' title=''><span class='caption-text'></span></span></p>

<ul>
<li>页面A：主页面</li>
<li>页面B：详情页面</li>
</ul>


<p><a href="https://github.com/studentdeng/CUArchitectureDemo/tree/1.0.0">demo code 1.0.0</a></p>

<p>2个页面分别显示一个数字，这个数字应该相同。详情会修改这个数字，这里我们发现，详情页面和主页面数字不一样。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/architecture1.gif' width='' height='' title='数据不一致'><span class='caption-text'>数据不一致</span></span></p>

<h2>问题1 解决方法A</h2>

<p>这里首先的感觉就是，详情页面返回，主页面数据没有刷新，导致数据不一致。
那么Fix这个Bug的方法，就是在主页面出现的时候刷新界面</p>

<pre><code>- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];

    self.displayLabel.text = [[CUDataDAO selectData].data stringValue];
}
</code></pre>

<p>现在来看，还不错。但是，我们调用selectData的次数则变得非常非常多。数据不是经常变化的。</p>

<p><a href="https://github.com/studentdeng/CUArchitectureDemo/tree/1.0.1">demo code 1.0.1</a></p>

<h2>问题1 解决方法B</h2>

<p>我们发现既然数据的改变是在页面B进行的，那么页面B修改这个数据的时候，应该把数据变化&#8221;通知&#8221;给页面A，那么我们写了一个Delegate</p>

<pre><code>@protocol CUDetailViewControllerDelegate &lt;NSObject&gt;

- (void)detailVC:(CUDetailViewController *)vc dataChanged:(NSNumber *)data;

@end
</code></pre>

<p>在页面B修改数据之后，通过delegate 通知给页面A。</p>

<pre><code>- (IBAction)changeButtonClicked:(id)sender {
    int value = arc4random() % 100;
    [CUDataDAO setData:value];

    self.displayLabel.text = [@(value) stringValue];

    if ([self.delegate respondsToSelector:@selector(detailVC:dataChanged:)]) {
        [self.delegate detailVC:self dataChanged:@(value)];
    }
}
</code></pre>

<p>到此场景1得到了不错的解决。</p>

<p><a href="https://github.com/studentdeng/CUArchitectureDemo/tree/1.0.2">demo code 1.0.2</a></p>

<h2>问题2</h2>

<p>这时我们增加了另一个页面C。这个场景会稍微抽象一点，我们定义了3个数据</p>

<ul>
<li>页面A的数据dataA</li>
<li>页面B的数据dataB</li>
<li>页面C的数据dataC</li>
</ul>


<p>问题1中 dataA = dataB。在问题2中dataA = dataB + dataC;</p>

<h2>问题2 解决方法C</h2>

<p>也就是说页面C的修改，也会影响页面A的数据，那么我们是不是也要写一个XXXXDelegate呢？</p>

<p>这时我们的大脑嗅出了一些不好的味道，如果再来个什么dataD，dataE，我们要写这么多的Delegate么？对于多对一&#8221;通知&#8221;这种味道，很自然的想到了不用Delegate，而是用<code>NSNotification</code>来做。让我们未雨绸缪一下，定义一个Notificaiton</p>

<pre><code>NSString *const kCUDataChangedNotification = @"CUDataChangedNotification";

[[NSNotificationCenter defaultCenter] postNotificationName:kCUDataChangedNotification
                                                  object:nil
                                                userInfo:nil];
</code></pre>

<p>那这个变化broadcast到listener，看上去是一个很赞的idea。</p>

<p><a href="https://github.com/studentdeng/CUArchitectureDemo/tree/1.0.3">demo code 1.0.3</a></p>

<h2>问题3</h2>

<p>过了一段时间，我们发现问题2的方法有一个Bug，当界面停在页面B的时候，切换到页面C，修改数据，B中再返回时，数据和页面A的数据不一致。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/architecture2.gif' width='' height='' title='数据不一致'><span class='caption-text'>数据不一致</span></span></p>

<p>那也可以类比解决方法B，得到了下面的方法</p>

<h2>解决方法D</h2>

<p>既然A和B的数据不一致，而A的数据比B的新，那么保留一个B的指针，然后A变化的时候，更新B就好了。</p>

<pre><code>- (void)handleDataChangedNotification {
    [self updateLabel];
    [self.vc updateLabel];
}

// In a storyboard-based application, you will often want to do a little preparation before navigation
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ([segue.identifier isEqualToString:@"push"]) {
        CUDetailViewController *vc = [segue destinationViewController];
        if ([vc isKindOfClass:[CUDetailViewController class]]) {
            self.vc = vc;
        }
    }
}
</code></pre>

<p><a href="https://github.com/studentdeng/CUArchitectureDemo/tree/1.0.4">demo code 1.0.4</a></p>

<h2>问题4</h2>

<p>页面C实在是太简单了，这次我们希望在页面C中显示页面A的数据。因为上次我们就产生了一个数据不一致的问题，这次我们注意到了，那么怎么修改呢？</p>

<h2>解决方法E</h2>

<p>在看了看整个APP各种通知之后，觉得挺麻烦，准备用一个取巧的方法。可以类比解决方法A。在页面C出现的时候，刷新数据，至于什么性能问题，不管了，先fix bug。</p>

<pre><code>- (void)viewWillAppear:(BOOL)animated {
    [self updateLabel];
}

- (void)updateLabel {
    int dataB = [[CUDataDAO selectData].data intValue];
    int dataC = [[CUDataDAO selectOtherData].data intValue];

    self.dataLabel.text = [@(dataB + dataC) stringValue];
}
</code></pre>

<p><a href="https://github.com/studentdeng/CUArchitectureDemo/tree/1.0.5">demo code 1.0.5</a></p>

<h2>问题5</h2>

<p>这时的数据需要不断的变化，我们在<code>CUDataDAO</code>加了一个timer 模拟数据变化，数据变化的原因可能是server push 一些数据。client 本地数据库更新了数据，需要在页面A、B、C中显示。</p>

<p>页面C的数据又不一致了。。。。</p>

<h1>问题到底在哪里呢</h1>

<p>走到这里，我们需要重新思考为什么这个问题会不断的重复出现呢？<code>software architecture</code>就是来解决这个问题的。但是在提出一个合理的方案之前，先思考一个概念。</p>

<p>我们把数据库中的数据，显示到屏幕上，或是传递给View时，这个过程其实是对data 做了一次copy。而且只要不是通过引用或是指针这些方式，通过值传递的方式都是对data做了一次copy。而这个copy的过程，非常类似<strong>Cache</strong>。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ios-architecture0.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>通常建立一个Cache会遇到2种问题。</p>

<ul>
<li>Cache情况A: 与original Data 数据不一致，没有及时更新</li>
<li>Cache情况B: 重复建立Cache</li>
</ul>


<p>让我们用这个思路来看我们的解决方案</p>

<h2>解决方法A</h2>

<p>这是一个非常典型的<code>Cache情况B</code>。数据库的数据并没有变化，但我们却多次重复计算cache</p>

<h2>解决方法B</h2>

<p>页面之间的关系可以用下面来描述</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ios-architecture1.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这里我们隐隐能够感觉到问题，A的数据变化依赖于2个地方。不急，再往后看</p>

<h2>解决方法C</h2>

<p><span class='caption-wrapper'><img class='caption' src='/images/ios-architecture2.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<h2>解决方法D</h2>

<p><span class='caption-wrapper'><img class='caption' src='/images/ios-architecture3.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>事情变得更糟了</p>

<h2>解决方法E</h2>

<p>和解决方法A类似，同样的重复计算Cache问题。</p>

<h2>实际上问题还会更糟</h2>

<p>现在还是一个简单的Model，如果project变得很大，那么就会变成这个样子</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ios-architecture4.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>每一个<code>X</code>都可能是一个Bug。</p>

<h1>我们似乎已经找到问题了</h1>

<p><a href="https://developer.apple.com/videos/wwdc/2014/?id=229">《Advanced iOS Application Architecture and Patterns》</a> 中，把这个图叫做information flow。我们的直觉会告诉我们，这个信息的传递，应该是自上而下的树或是森林，而且最好是一个层次平衡结构，要清晰，每一个位置都有相对于的职责。那我们就需要制定一个规则。</p>

<p>在想这个规则之前，如果把上面的图背后的数据忘记，我们感觉这很类似内存模型。当然内存模型会比较复杂。但是我们可以借鉴很多&#8221;内存管理中的规则&#8221;，比如<strong>谁创建，谁销毁</strong>。同样，在我们的information flow中，我们希望<strong>谁创建Cache，谁更新Cache变化</strong></p>

<p>DAO的数据库似乎很难做这件事情，我们引入了一个新的元素<code>dataSource</code>（当然他本身又是DAO的一个Cache)。其中A、B、C3个都会显示数据，那么他们应该在一个层级，其中B、C会修改数据，他们会把这个数据返回给<code>dataSource</code>，而通过<code>dataSource</code>来把这个变化通知到A、B、C。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ios-architecture5.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这样带来的好处很明显，我们再添加一个D，也不会对其他地方的数据产生任何影响，我们的Unit Test、Mock也更加好写。</p>

<h1>我们之前的思路错在哪里呢？</h1>

<p>从局部来看，我们之前的思路都没有任何问题，但是整体来看却把问题隐藏化。关键的问题是在于没有找到<code>Truth</code>，找到问题真正的地方。而找到真正的地方，需要我们在大脑中有一个清晰的<code>information flow</code>或是<code>data flow</code>。了解之间元素的相互关系，才能建立一个个的层。才能坐到真正的<strong>解耦</strong>,<strong>解耦并不是仅仅一个个的<code>Manager</code>，更重要的是建立一套清晰的flow机制，或是消息机制，如果没有一套flow，中间引入的各种各样的方法，即便使用了各种设计模式，整个software 依然是深度耦合</strong>。</p>

<h1>疑问</h1>

<h2>这个APP看上去交互非常复杂</h2>

<p>上面的model，有些同学还可能觉得这是交互上面的问题，这个交互看上去非常的复杂，不是一个好设计。</p>

<p>我这里列举一个实际的例子：</p>

<p>A页面要创建动画，动画背后包括很多数据，这些数据会在B，C甚至更多的页面，或是后台被修改。动画本身实际上体现在View，而这些view可能不仅仅在A中有，B，C可能也会有部分的View。</p>

<h2>单例怎么样</h2>

<p>当然我们可以用单例的法子。单例是个魔鬼，被很多滥用，这个场景用单例，其实仅仅是把全局变量合理的封装在了单例下，因为这份数据，并没有任何理由要一定是一份copy。</p>

<h1>recap</h1>

<p>在了解这个概念后，再看一些server的架构，规则时，也会更容易理解这些层之间的关系。包括</p>

<ul>
<li>为什么要规定那些层之间，不能相互调用，不能有静态方法。</li>
<li>一个层之间的model，不能有重叠功能，不能连表查询。</li>
<li>在哪个层才能调用另一个服务，而调用这个服务还必须要通过统一的接口</li>
</ul>


<p>software architecture 涵盖的东西非常多。这篇只是一个引子，介绍了设计之前的准备工作。但是在实际过程中，我们的模型可能要比我这里写的还要复杂很多。下一篇会介绍一种策略用来处理更加复杂模型的情况。</p>

<p>最后附上一个完整功能的 <a href="https://github.com/studentdeng/CUArchitectureDemo/tree/1.0.6">demo code</a></p>

<h1>参考</h1>

<p><a href="https://developer.apple.com/videos/wwdc/2014/?id=229">《Advanced iOS Application Architecture and Patterns》</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/24/machine-learning-2/">机器学习(二) 线性回归、梯度下降实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-24T20:52:00+08:00" pubdate data-updated="true">Aug 24<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/24/machine-learning-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>了解一个算法最好的方法就是实现它，不过在开始实现算法之前，有一些额外的概念需要理解。</p>

<h1>Vectorization</h1>

<p>这是<a href="http://studentdeng.github.io/blog/2014/07/28/machine-learning-tutorial/">上一篇</a>提到的hypothesis的计算公式。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_1.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>当计算这个表达式值的时候，往往第一个感觉是写一个for loop 然后累加求和</p>

<pre><code>prediction = 0;
for (int i = 0; i &lt; n; ++i) {
    prediction += theta[j] * x[j];
}
</code></pre>

<p>但是在machine learning中更倾向于使用矩阵的方式。
比如同样的公式，会看成矩阵相乘。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_3.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>其中theta和X分别是</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_2.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这里通过矩阵或是向量来代替之前的loop。</p>

<p>这是<a href="http://studentdeng.github.io/blog/2014/07/28/machine-learning-tutorial/">上一篇</a>提到的算法</p>

<p><img src="http://studentdeng.github.io/images/ml/4.png" alt="image" /></p>

<p>计算function J如果用octave来实现则是这个样子</p>

<pre><code>function J = computeCost(X, y, theta)
%COMPUTECOST Compute cost for linear regression
%   J = COMPUTECOST(X, y, theta) computes the cost of using theta as the
%   parameter for linear regression to fit the data points in X and y

% Initialize some useful values
m = length(y); % number of training examples

% You need to return the following variables correctly 
J = 0;

% ====================== YOUR CODE HERE ======================
% Instructions: Compute the cost of a particular choice of theta
%               You should set J to the cost.


t = (X * theta) - y;
J = (sum(t .* t)) / (2 * m);

% =========================================================================

end
</code></pre>

<p><img src="http://studentdeng.github.io/images/ml/19.png" alt="image" /></p>

<p>而求偏导数迭代更新theta的代码则是这个样子</p>

<pre><code>function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)
%GRADIENTDESCENT Performs gradient descent to learn theta
%   theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by 
%   taking num_iters gradient steps with learning rate alpha

% Initialize some useful values
m = length(y); % number of training examples
J_history = zeros(num_iters, 1);

for iter = 1:num_iters

    % ====================== YOUR CODE HERE ======================
    % Instructions: Perform a single gradient step on the parameter vector
    %               theta. 
    %
    % Hint: While debugging, it can be useful to print out the values
    %       of the cost function (computeCost) and gradient here.
    %


    s = sum(bsxfun(@times, X * theta - y, X));
    theta = theta - (alpha / m) * s';

    % ============================================================

    % Save the cost J in every iteration    
    J_history(iter) = computeCost(X, y, theta);

end
</code></pre>

<p>上面的2部分代码如果做一些合并分别可以简化成1行代码。说到这里自己还是相当羞愧的。今天早上花了3个小时才搞定这2行代码&#8230;主要时间花在了
2个地方。</p>

<ol>
<li>算好theta去predict的上面，和normal equations的方式计算的答案总是对不上，不得不怀疑人生了。。。后面才发现是因为函数没有完全收敛，在调整learning rate之后误差明显变小了。</li>
<li>让大脑适应矩阵还是有点难，很多东西看上去很简单，反应很长时间，不过后面会好一些。</li>
</ol>


<h1>为什么用矩阵</h1>

<p>在费了老半天力气搞定Vectorization的转变之后，不得不想想为什么要用这个方式做。obviously有2个好处，Andrew课上也提到了好多次。</p>

<ol>
<li>增加一个feature很简单，只要把输入增加一列就好，而算法不需要改动。</li>
<li>矩阵的运算更容易优化，性能比循环更快。实际我们往往处理上百万个Example和N多的features</li>
</ol>


<p>第一个很好理解，而且把循环的一大堆代码写成一行，显得逼格很高。
第二个会比较麻烦，涉及到了并行计算优化。</p>

<h1>其他</h1>

<p>在之前的算法中，我们看到了每一次调整theta都需要iterate整个所有的example，但实际中往往需要处理上百万个examples，而这样的iteration显然是不能接受的。实际上会随机选取一部分examples然后去迭代theta，最后得到一个较为可靠的theta向量。</p>

<p>最后附上Andrew作业的图片，虽然Andrew 不希望把答案放在网上或是论坛什么的，不过我觉得都过去2年多了,应该没关系了。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_4.png' width='' height='' title='最后的预测效果图'><span class='caption-text'>最后的预测效果图</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_5.png' width='' height='' title='cost function & theta'><span class='caption-text'>cost function &amp; theta</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_6.png' width='' height='' title='cost function & theta 等高线'><span class='caption-text'>cost function &amp; theta 等高线</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_7.png' width='' height='' title='learning rate'><span class='caption-text'>learning rate</span></span></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/16/qinshihuang/">《中国古代历史与人物——秦始皇》笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-16T10:17:00+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/16/qinshihuang/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在coursera学完了台湾国立大学的公开课——<a href="https://class.coursera.org/chinesehistory-002">《中国古代历史与人物——秦始皇》</a>。虽然自己看过不少课程，看过不少历史书，但是这门课程对我的影响超过了任何一本文史书。我自己完整的看过3遍，并做了作业(可惜没有认真做好)。这门课从某种角度来看，彻底改变了我对文史课程的认知，对自己之前的无知和误解感到深深的愧疚，并再次讥讽一下国内的文史课程。下面是自己整理的东东，方便自己日后review。</p>

<ul>
<li> 读历史需要思辨</li>
<li> 每一个决定的结果是否成功是通过时间衡量的，做决定的关键是在于是否得到了自己想要的结果。得到就要付出，除非有其他人替自己付出</li>
<li> 社会就是需要和有用，说服别人是因为知道别人需要什么</li>
<li> 人和人的差别不在于遇到的问题，而是面对问题时的态度</li>
<li> 看书要学会“沙金”，从沙子里面掏出金子，而不是一味的埋怨，批判。任何事情都有值得自己学习的东西。放下自己的成见，很多事情没有自己想象的那么简单。</li>
</ul>


<h3>2-5</h3>

<p>秦国百战百胜，不在于它真能变法，而在于列国不能真正变法
历史说明了一个道理，不能适应时代的，只有被淘汰消失</p>

<h3>2-6</h3>

<p>历史上的所谓的成功和失败，就看你站在什么位置，用什么尺度来衡量。而判断成功和失败的标准，最后还是问自己</p>

<h3>3-4</h3>

<p>想要成功，就要懂得把理智放在感情之上。</p>

<p>谋事在人这是真得有用，有人用很多的时间去提高效率，但是节约的时间，并没有被真正利用起来。那么这个办法也很一般。
自己需要自己不断的努力，才能让之前的办法真正变成好办法。。。</p>

<p>方法和人关系太大了</p>

<p>这个社会不外乎需要和有用。</p>

<p>你需要知道别人需要什么，你才能变得有用</p>

<h3>5-3</h3>

<p>富家子弟处逆境难
穷家子弟处顺境难</p>

<h3>6-1</h3>

<p>人生总会有赌博的时候，对错往往是命运差别巨大。
百折不挠的民族</p>

<p>人生：运气 ，自我要求。好好准备，让自己成为那样的条件。等待机会。</p>

<p>理想是，你知道你下一步应该做什么
妄想是，你只有目标却不知道从何做起</p>

<p>自强的第一步，不自欺</p>

<h3>6-8</h3>

<p>在中国文化中，最高的道德和最高的智慧必然是合一的</p>

<h3>7-3</h3>

<p>学会认错，改过。</p>

<h3>8-1</h3>

<p>改变环境，需要改变自己，让自己适应那个自己想要的环境的要求。
如何改变，通过学习</p>

<h3>9-1</h3>

<p>做事之前，为虑胜，先虑败，方能考虑周全</p>

<h3>9-9</h3>

<p>历史启发智慧，所有的学问都能带来智慧</p>

<p>审时度势：</p>

<p>时：你所处的环境。
势：环境变动的方向</p>

<p>变的是时间和环境。
不变的是人性和良知</p>

<p>不仅仅是自己改变，需要改变周围的人。</p>

<p>历史用真，去伪。。。
改动人心</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/28/machine-learning-tutorial/">机器学习(一) 简单的背景介绍、线性回归、梯度下降</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-28T16:48:00+08:00" pubdate data-updated="true">Jul 28<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/07/28/machine-learning-tutorial/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Introduction</h1>

<p>机器学习很久之前就已经热得不行了，直到最近这几个星期，自己才打算了解一些这方面的东西。原因大概有这么3点。</p>

<ol>
<li>自从Andrew Ng 加入我厂之后(虽然和我毛关系也没有)，总觉得还是需要围观一下这个令他兴奋的领域。</li>
<li>在听了IDL的有关手环算法分享后(其实毛也没有听懂), 在知道了一大堆的名词如最小二乘、梯度下降、SVM。以及里面很多的线性代数，微积分的概念，让我觉得这是一个很好的回收自己大学时期的沉默成本(微积分、现代是我在学校里面不多的用心学过的课程)的好机会。总之就是对这些很感兴趣。</li>
<li>前一段时间受组里高工分享睡眠算法影响，对这种阅读paper，然后优化算法的过程感到很开心。</li>
</ol>


<p>有了这3条，足够我忙活好几个月了 : )</p>

<h1>Background</h1>

<p>在机器学习中，有2个很大的思路<code>监督学习(supervised learning)</code>和<code>非监督学习(unsupervised learning)</code></p>

<p>监督学习，用通俗的话来说就是<code>你知道问题的答案，需要计算机给出一个更标准的答案</code>。</p>

<p>非监督学习，用通俗的话来说就是<code>物以类聚，人以群分</code>。我们拿到了很多数据，但是不知道问题的答案，希望计算机给我们提供思路。</p>

<p>在生产环境中，往往采用混合模式。比如图片搜索，如何能够查找网页中判断那个图片是老虎，那个是狗。就有2个思路。</p>

<ol>
<li>根据图片周围的文字。</li>
<li>图片的图像数据分析。</li>
</ol>


<p>2个角度相互校验，稳定之后，就可以产生足够的标注信息了。</p>

<h1>线性回归(Linear regression)</h1>

<p>线性回归主要用于手环的里程部分的计算，涉及到更细节的是 最小二乘，梯度下降。这里从先从最简单的一元线性回归开始。</p>

<h2>一元线性回归(Linear regression with one variable)</h2>

<p>Regression Problem : Predict real-valued output</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/8.png' width='' height='' title='1-1 算法运行的过程'><span class='caption-text'>1-1 算法运行的过程</span></span></p>

<p>最关键的在于如何描述hypothesis。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/1.png' width='' height='' title='1-2 一元线性回归中的hypothesis函数'><span class='caption-text'>1-2 一元线性回归中的hypothesis函数</span></span></p>

<p>那么应该如何选取参数呢？直觉告诉我们这个直线需要尽可能的拟合我们的数据集。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/9.png' width='' height='' title='1-3 线性回归的目标函数'><span class='caption-text'>1-3 线性回归的目标函数</span></span></p>

<p>通过下面的cost function 来评估参数的好坏。算法的目标也很清晰，让函数越小越好。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/12.png' width='' height='' title='1-4 cost function'><span class='caption-text'>1-4 cost function</span></span></p>

<p>那个这个cost function 到底是个什么样子呢？</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/2.png' width='' height='' title='1-5 图形化的cost function'><span class='caption-text'>1-5 图形化的cost function</span></span></p>

<p>当然这个图还是看起来比较麻烦，Andrew 用了更为简单绘制的图来表示（有点类似等高线）。
相同的圆圈上，有着相同的cost function value。这里可以看到和上面的图一样，有一个极值。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/7.png' width='' height='' title='1-6 一个比较差的选择'><span class='caption-text'>1-6 一个比较差的选择</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/18.png' width='' height='' title='1-7 一个很接近极值的选择'><span class='caption-text'>1-7 一个很接近极值的选择</span></span></p>

<h1>梯度下降 (Gradient descent)</h1>

<p>梯度下降，不仅仅是用于线性回归，也可以用在其他机器学习的场景下。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/3.png' width='' height='' title='1-8 梯度下降的思路（2个参数的情况）'><span class='caption-text'>1-8 梯度下降的思路（2个参数的情况）</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/10.png' width='' height='' title='1-9 梯度下降函数图形（2个参数的情况）'><span class='caption-text'>1-9 梯度下降函数图形（2个参数的情况）</span></span></p>

<p>我们的目标是寻找这个图形中的最小值，也就是靠近蓝色的地方。直觉告诉我们，我们先随机一个点，然后沿着最大的坡度向下走最后就可以走到一个极值里。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/16.png' width='' height='' title='1-10 一条算法路径，全局最优'><span class='caption-text'>1-10 一条算法路径，全局最优</span></span></p>

<p>这个算法也有问题，随着第一个点的位置不同，我们可能找到一个局部最优的解，而不是全局最优。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/14.png' width='' height='' title='1-11 另一条算法路径，局部最优'><span class='caption-text'>1-11 另一条算法路径，局部最优</span></span></p>

<p>好在在很多实际问题中，我们遇到的情况要好很多，往往<strong>只有一个极值</strong>。</p>

<p>那么梯度下降的算法就可以简单的描述出来，分别计算2个维度的偏导数，直到函数收敛</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/5.png' width='' height='' title='1-12'><span class='caption-text'>1-12</span></span></p>

<p>通过分别计算偏导数,a 为learning rate，决定每一步的步长，太小函数收敛很慢，太大则可能无法找到极值，甚至函数无法收敛。</p>

<p>这里Andrew 着重指出了一个叫做同步更新的概念</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/11.png' width='' height='' title='1-13'><span class='caption-text'>1-13</span></span></p>

<p>如果不同步更新，最后也可以得到极致，但是Andrew 更推荐计算完成所有的参数之后，再一起同步更新。</p>

<h2>梯度下降和一元线性回归</h2>

<p>将图1-4分别偏导后</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/15.png' width='' height='' title='1-14 算法公式'><span class='caption-text'>1-14 算法公式</span></span></p>

<h2>其他</h2>

<ol>
<li>根据上面的算法，如果我们的cost function 在一些地方不可导，那算法不就没法继续了？</li>
<li>有其他的方法，可以不去循环计算而是直接根据工具计算</li>
</ol>


<h2>梯度下降和一般化的线性回归</h2>

<p>很多时候我们不仅仅满足2个参数，决定事情的因素很多，我们需要更一般化的公式。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/4.png' width='' height='' title='1-15'><span class='caption-text'>1-15</span></span></p>

<p>算法</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/19.png' width='' height='' title='1-16'><span class='caption-text'>1-16</span></span></p>

<p>分别求偏导后</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/17.png' width='' height='' title='1-17'><span class='caption-text'>1-17</span></span></p>

<h1>梯度下降生产环境中的一些技巧</h1>

<h2>Feature Scaling</h2>

<p>思路: 希望所有的feature在相同或是类似的范围之内，这样梯度下降会更快收敛。</p>

<p>下图是feature的范围不在一起的运算过程，可以看出来不是圆形，2个维度调整的步长不一样，导致很多反复</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/21.png' width='' height='' title='1-18 红色箭头表示算法的一次迭代'><span class='caption-text'>1-18 红色箭头表示算法的一次迭代</span></span></p>

<p>下图则是调整过的feature，好了很多</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/23.png' width='' height='' title='1-19 红色箭头表示算法的一次迭代'><span class='caption-text'>1-19 红色箭头表示算法的一次迭代</span></span></p>

<p>更一般的，Andrew 推荐每一个feature放在[-1, 1]区间范围内</p>

<h2>Learning Rate</h2>

<p>说到Learning Rate 就不能不提收敛(convergence)。一般应该定义多大的阀值来判断是否收敛呢？</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/6.png' width='' height='' title='1-20 Andrew 并不推荐使用一个阀值来判断是否收敛'><span class='caption-text'>1-20 Andrew 并不推荐使用一个阀值来判断是否收敛</span></span></p>

<p>Andrew 更推荐用图表的形式，因为这个不仅仅可以看到是否马上收敛，而且还能看到算法是否运行正常，是不是一些参数的问题，导致算法无法收敛。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/20.png' width='' height='' title='1-21'><span class='caption-text'>1-21</span></span></p>

<p>下图是2个出了问题的J函数，通常来说是Learning Rate 过大。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/25.png' width='' height='' title='1-22 一些过大的Learning Rate 导致的图形'><span class='caption-text'>1-22 一些过大的Learning Rate 导致的图形</span></span></p>

<p>最后Andrew 还提供了一些practice的Learning Rate 选取方法，比如一些0.001, 0.003, 0.01, 0.03, 0.1, &#8230;</p>

<h2>参考</h2>

<p><a href="https://class.coursera.org/ml-006">Coursera 《Machine Learning》 Stanford Andrew Ng</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/core-animation/">Core Animation基本概念和Additive Animation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T19:21:00+08:00" pubdate data-updated="true">Jun 24<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/06/24/core-animation/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/">上一篇《AutoLayout 相关概念介绍和动画demo》</a>提到了一些Core Aniamtion的基础知识，这篇依然介绍一些基本概念，最后提到一点iOS8的动画改动。</p>

<h1>一些基本概念</h1>

<p>说到Core Animation 不能不说Layer, 一个个Layer通过tree的结构组织起来，在Display的过程中实际上有3种Layer tree。</p>

<ul>
<li>model layer tree</li>
<li>presentation tree</li>
<li>render tree</li>
</ul>


<p><code>model Layer tree</code> 中的Layer是我们通常意义说的Layer。当我们修改layer中的属性时,就会立刻修改model layer tree。</p>

<pre><code>layer.position = CGPointMake(0,0); //这里的修改会直接影响model layer tree
</code></pre>

<p><code>presentation tree</code> 是Layer在屏幕中的真实位置。比如我们创建一个动画</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">5.0f</span>
</span><span class='line'>                   <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                     <span class="n">self</span><span class="p">.</span><span class="n">animationLabel</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">);</span>
</span><span class='line'>                   <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//这里用一个Timer print presentLayer的位置。</span>
</span><span class='line'>  <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">animationLabel</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">presentationLayer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;model:%@, presentLayer%@&quot;</span><span class="p">,</span> <span class="n">NSStringFromCGPoint</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">animationLabel</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span><span class="p">),</span> <span class="n">NSStringFromCGPoint</span><span class="p">(</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是屏幕输出结果</p>

<pre><code>model:{73.5, 155.5}, presentLayer{73.5, 155.5}
model:{200, 400}, presentLayer{73.559769, 155.61552}//开始动画
model:{200, 400}, presentLayer{73.814095, 156.10709}
model:{200, 400}, presentLayer{74.267357, 156.98315}
...
...
...
model:{200, 400}, presentLayer{199.99576, 399.99182}
model:{200, 400}, presentLayer{200, 400}
</code></pre>

<div class='notebox'><p><strong>Note: </strong>render tree 在apple的render server进程中，是真正处理动画的地方。而且线程的优先级也比我们主线程优先级高。所以有时候即使我们的App主线程busy，依然不会影响到手机屏幕的绘制工作。</p></div>


<h1>CADisplayLink</h1>

<p>了解<a href="http://www.cocos2d-x.org/?v=EN">cocos2dx</a>对CADisplayLink一点也不陌生，对APP开发者可能就有一点远，但是facebook的<a href="https://github.com/facebook/pop">Pop</a>一下子拉近了我们和CADisplayLink的距离。通过设置callback函数，当屏幕刷新的时候，就可以执行我们的代码。当然，我们也可以利用NSTimer 或是GCD来实现类似的功能。但是CADisplayLink是最优的，因为不管是哪种类型的Timer，即使我们的刷新间隔和屏幕刷新保持一致。我们都无法知道系统什么时候刷新屏幕。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation1.png' width='' height='' title='1-1 NSTimer中每一帧其实只有8ms的时间，如果大于8ms，那么就会丢帧'><span class='caption-text'>1-1 NSTimer中每一帧其实只有8ms的时间，如果大于8ms，那么就会丢帧</span></span></p>

<p>facebook的<a href="https://github.com/facebook/pop">Pop</a>非常类似UIDynamic，但是我们需要注意一点，相对于传统的model动画来说，CADisplayLink导致部分绘制工作放在了我们APP的地址空间中，也就是说，增大了APP内存，CPU的开销。也更容易遇到性能瓶颈。</p>

<div class='notebox'><p><strong>Note: </strong>model layer的这部分绘制是完全在render server，而render server运行在比APP更高优先级的进程中，而这个也意味着会有进程间通讯的开销。传递的数据包括整个render tree还有动画，所以，Apple 并不推荐我们手动commit transaction, Core Animation 默认会在run loop 中提交transaction。</p></div>


<h1>UIView animation</h1>

<p>Apple 最近在推荐一些Modern APP的设计，其中有一条是希望responsive。比如下面的场景，启动一个动画之后，在动画还没有完成之前取消这个动画。</p>

<p><a href="https://github.com/studentdeng/CoreAnimationAdditiveExample">下图的相关代码</a></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation1.gif' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这里我们看到了3种情况。</p>

<ul>
<li>红色的2个动画之间有一个很大的跳动。</li>
<li>绿色的比红色的好一点，没有跳动，但是就像撞到了墙一样，完全丧失了一开始动画的速度。</li>
<li>蓝色的的运动更加平滑，有更真实的物理效果。</li>
</ul>


<h2>UIKit创建的动画，系统是如何理解的</h2>

<p>UIKit的动画最后都会通过Core Animation 来实现, 那么当我们修改layer（model layer）的数值时，系统是如何理解并创建动画呢？
比如这里有一个线性的动画，将animationView的坐标从（0，0）移动到（0,500）</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="n">animationView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">1.0f</span>
</span><span class='line'>                        <span class="nl">delay:</span><span class="mi">0</span>
</span><span class='line'>                      <span class="nl">options:</span><span class="n">UIViewAnimationOptionCurveLinear</span>
</span><span class='line'>                   <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                     <span class="n">animationView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
</span><span class='line'>                   <span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>下面是当我们创建一个UIKit的动画时发生的事情</h3>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation9.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<ul>
<li>Model：在<code>animationView.center = CGPointMake(0, 500);</code>之后会立刻修改<code>animationView</code>的model Layer中的<code>position</code>的值为（0， 500）。</li>
<li>Animation：系统的理解就是从原来的model layer的值(0,0)到新的model layer的值(0, 500)创建一个动画。</li>
<li>Presentation： Presentation就像上面提到的，是表示<code>animationView</code>当前在屏幕的真实位置(渲染位置)，因为还没有&#8221;动&#8221;起来，所以还是(0,0)</li>
</ul>


<div class='notebox'><p><strong>Note: </strong>Animation的部分如果没有明白，可以结合后面的回头再看</p></div>


<h3>当我们看到屏幕上面的View移动的时候，发生了下面的事情</h3>

<p>这是在0.4s时刻之前的状态。Model Layer的数值没有变化，而Presentation则在变化，和真正的屏幕动画保持一致。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation10.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<h3>在一个animation并没有完成的情况下，再创建一个动画系统是如何理解的呢？</h3>

<p>如果我们在<strong>0.5时刻</strong>创建一个reverse动画，<code>animationView.center = CGPointMake(0, 0);</code></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">1.0f</span>
</span><span class='line'>                        <span class="nl">delay:</span><span class="mi">0</span>
</span><span class='line'>                      <span class="nl">options:</span><span class="n">UIViewAnimationOptionCurveLinear</span>
</span><span class='line'>                   <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                     <span class="n">animationView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>                   <span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation5.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<ul>
<li>Model：的数值会被立刻修改成目标数值(0, 0)</li>
<li>Animation： 系统的理解是从原来的(0, 500)，创建一个去(0,0)的动画</li>
<li>Presentation: 基于系统的理解，Presentation layer的数值变成了(0, 500)。1秒中的时间内递减到(0, 0)</li>
</ul>


<p>到目前为止，我们可以清楚的理解为什么红色的view会有一个大的跳跃，在我们这里的理解就是presentation layer的一个不连续的修改。</p>

<h2>绿色的动画效果原因</h2>

<p>在上面的基础之前，绿色的就可以简单说一些</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation6.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<ul>
<li>Model 这里还是和之前一样，表示目标值</li>
<li>Animation：系统的理解是从当前的动画位置开始，也就是 (0, 150)开始创建一个1秒的动画到(0,0)</li>
<li>Presentation 和我们的预期一样。</li>
</ul>


<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation2.png' width='' height='' title='linear animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage'><span class='caption-text'>linear animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage</span></span>
<span class='caption-wrapper'><img class='caption' src='/images/core_animation3.png' width='' height='' title='EseInOut animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage'><span class='caption-text'>EseInOut animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage</span></span></p>

<p>可以看出来2个动画相接的曲线不平滑，而造成这个不平滑的原因在于把之前的动画覆盖了, 丢掉了之前动画的速度，如果要实现一个更一般化的解决方案，我们很自然的想到了动画合成。</p>

<h2>蓝色的动画原因</h2>

<p>蓝色的动画比较复杂，使用了Core Animation中的additive属性，动画被设置成相对的，那么就和动画具体的位置无关。最后还合成了2个动画。</p>

<p>首先，解释一下什么是相对的动画。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation7.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这里很容易看到，view的真实位置是Animation 的值 + Model的值。系统的理解就是相对目标值(0, 500)来说，创建一个从-500 到 0 的动画。</p>

<p>其次，相比之前的动画，在0.6时刻（为了方便计算，把之前的0.5时刻移动到了0.6时刻）并没有删除掉之前的动画，而是添加了一个新的动画Animation2。也就是一个相对目标值(0,0)来说，创建一个从500到0的动画。整个运动变成了2个动画的合成。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation8.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<div class='notebox'><p><strong>Note: </strong>Animation2的duration修改了，在demo code里面并没有修改 ：）</p></div>


<p>这里，我们就得到了一个一般化的解决方案。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation4.png' width='' height='' title='图中的颜色和本文的颜色无关，只是表示2个动画的stage'><span class='caption-text'>图中的颜色和本文的颜色无关，只是表示2个动画的stage</span></span></p>

<h2>iOS8的改动</h2>

<p>Core Animation 有一个additive的属性实际上已经存在很久了，但是却很少被大家知道（我自己也是）。在iOS8 之前，UIKit创建的动画默认是不使用additive的，而在iOS8之后，默认是Additive的。有兴趣的同学可以试一试download <a href="https://github.com/studentdeng/CoreAnimationAdditiveExample">demo code</a>用Xcode6(这会还是beta)并打开macro<code>#define USING_UIKIT 1</code>看一下新的UIKit animation效果。</p>

<p>在了解背后的机制之后，其中的变化也很容易理解。</p>

<ol>
<li>completion block 的调用变了。之前在创建一个UIKit的动画时候，会覆盖掉上一个动画，也就是删除再添加一个新动画，而现在前一个动画会在真正执行完毕才会执行completion block。</li>
<li>不是所有的动画都支持additive</li>
</ol>


<p>&#8230;&#8230;</p>

<h1>参考</h1>

<ul>
<li><a href="https://developer.apple.com/videos/wwdc/2014/?id=236">《WWDC2014 236_building_interruptible_and_responsive_interactions》</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/coreanimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW3">《Core Animation Programming Guide:Core Animation Basics》</a></li>
<li><a href="http://kxdx.org/additive-core-animation/">《additive-core-animation》</a></li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'studentdeng';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>








</body>
</html>
