
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>studentdeng Blog</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="内容主要来自http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-1/ 里面加入了一点点自己的吐槽和理解 已经有很久很久没有写一些 under the hood 的东西了, 好久没有学习新的技术了, 不说废话了.
ARC &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="studentdeng Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">studentdeng Blog</a></h1>
  
    <h2>不会开机的男孩</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/03/arc/">ARC 1</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-03T13:43:00+08:00" pubdate data-updated="true">Mar 3<span>rd</span>, 2013</time>
        

        
      | <a href="/blog/2013/03/03/arc/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><p>内容主要来自http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-1/ 里面加入了一点点自己的吐槽和理解</p>

<p>已经有很久很久没有写一些 under the hood 的东西了, 好久没有学习新的技术了, 不说废话了.
ARC 是编译器的技术, 不知道为什么, 我对编译器增加额外代码有着非常大的恐惧, 是因为和C++ 相关么? 不知道, anyway ARC 的确帮我这样的码农减少了工作量, 对于一向懒惰的我来说, 我还是更倾向于省事.</p>

<p>在之前写block 的时候, 有些好奇的家伙们问我,是怎么发现编译器增加代码的. 这个其实很简单, 就是看一些文档了,但是总是有些人比较好奇编译器到底做了什么,不想理所当然的接受.</p>

<p>先瞅瞅我们的测试函数 test_arc.m</p>

<pre><code>    @interface ClassA : NSObject
    @interface ClassA : NSObject
    {
            NSNumber *_foo;
    }
    @property (nonatomic, retain) NSNumber *foo;
    @end

    @implementation ClassA

    @synthesize foo = _foo;

    - (void)changeFooDirect:(NSNumber*)inFoo {
        _foo = inFoo;
    }

    - (void)changeFooSetter:(NSNumber*)inFoo {
        self.foo = inFoo;
    }

    - (NSNumber*)newNumber {
        return [[NSNumber alloc] initWithInt:10];
    }

    - (NSNumber*)getNumber {
        return [[NSNumber alloc] initWithInt:10];
    }

    @end
</code></pre>

<p>Mac 环境比较让人dt, 安装Xcode 后 安装Command Line Tools 否则, 会遇到各种各样的问题. 首先关闭ARC</p>

<pre><code>clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/ -arch armv7 -fno-objc-arc -O3 -S -o test_arc.s test_arc.m
</code></pre>

<p>这个是开启ARC的命令</p>

<pre><code>clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/ -arch armv7 -fobjc-arc -O3 -S -o test_arc_on.s test_arc.m
</code></pre>

<p>让我们先看一下 changeFooDirect 在没有开启arc时的样子, 当然, 如果有人和我一起工作,敢写出这样的代码, 肯定会让我喷的体无完肤的: )</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA changeFooDirect:]"
.thumb_func "-[ClassA changeFooDirect:]"
"-[ClassA changeFooDirect:]":
@ BB#0:
    movw    r1, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))
    movt    r1, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))
LPC0_0:
    add r1, pc
    ldr r1, [r1]
    str r2, [r0, r1]
    bx  lr
</code></pre>

<p>这里可以看出, 只是简单的覆盖变量, 没有retain release, 非常容易产生内存问题.
再看一下 changeFooDirect 开启ARC后的样子</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA changeFooDirect:]"
.thumb_func "-[ClassA changeFooDirect:]"
"-[ClassA changeFooDirect:]":
@ BB#0:
    push    {r4, r7, lr}
    mov r4, r0                          
    mov r0, r2
    add r7, sp, #4
    blx _objc_retain
    movw    r1, :lower16:(_OBJC_IVAR_$_ClassA._foo-(LPC0_0+4))
    movt    r1, :upper16:(_OBJC_IVAR_$_ClassA._foo-(LPC0_0+4))
LPC0_0:
    add r1, pc                          
    ldr r2, [r1]            //r2 = 变量foo在类实例中的偏移量
    ldr r1, [r4, r2]            //r4 = self 这句的意思就是 r1 = foo;
    str r0, [r4, r2]            //r0 表示参数inFoo, 这里相当于_foo = inFoo;
    mov r0, r1              
    pop.w   {r4, r7, lr}            
    b.w _objc_release           //release ro的变量 也就是 _foo
</code></pre>

<p>这里我们可以看出, ARC retain 新变量, 然后release 旧的变量, 而这个正是我们想要的结果.这段坑爹的代码在ARC下是可以正确运行的</p>

<p><strong>这里我再次声明一下, 类似changeFooDirect 这样的代码 只是用于研究, 访问类实例成员变量时都应该使用property方法而不是直接访问或是修改</strong></p>

<p>changeFooSetter 这里我们看到无论是否开启ARC 生成的代码都是一样的.调用自动生成的setter 方法</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA changeFooSetter:]"
.thumb_func "-[ClassA changeFooSetter:]"
"-[ClassA changeFooSetter:]":
@ BB#0:
    movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
    movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
LPC1_0:
    add r1, pc
    ldr r1, [r1]
    b.w _objc_msgSend
</code></pre>

<p>然后我们再看看getNumber 函数 开启ARC后的代码</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA getNumber]"
.thumb_func "-[ClassA getNumber]"
"-[ClassA getNumber]":
@ BB#0:
push    {r7, lr}
movw    r0, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+4))
mov r7, sp
movt    r0, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+4))
movw    r2, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+4))
movt    r2, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+4))
LPC3_0:
add r0, pc
LPC3_1:
add r2, pc
ldr r1, [r0]
ldr r0, [r2]
blx _objc_msgSend
movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+4))
movs    r2, #10
movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+4))
LPC3_2:
add r1, pc
ldr r1, [r1]
blx _objc_msgSend
pop.w   {r7, lr}
b.w _objc_autoreleaseReturnValue               //如果没有开启ARC 则没有 _objc_autoreleaseReturnValue
</code></pre>

<p>关于_objc_autoreleaseReturnValue 也有很多有趣的事情, 如果把这个家伙简单的理解成autorelease就大错特错了, 编译器会对这些做优化, 减少一些无谓的retain release 来提高代码效率</p>

<p>newNumber 和我们想的也一样, 在开启ARC的时候, 并没有增加 类似autorelease 的函数, 而是将retain count 保持为1.</p>

<p>如果是普通的临时变量又是什么样子呢?</p>

<pre><code>- (void)test
{
        NSNumber *test = [[NSNumber alloc] initWithInt:1];

        NSLog(@"%@", test);
}
</code></pre>

<p>开启ARC 后的代码</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA test]"
.thumb_func "-[ClassA test]"
"-[ClassA test]":
@ BB#0:
push    {r4, r7, lr}
movw    r0, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC4_0+4))
add r7, sp, #4
movt    r0, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC4_0+4))
movw    r2, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC4_1+4))
movt    r2, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC4_1+4))
LPC4_0:
add r0, pc
LPC4_1:
add r2, pc
ldr r1, [r0]
ldr r0, [r2]
blx _objc_msgSend
movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC4_2+4))
movs    r2, #1
movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC4_2+4))
LPC4_2:
add r1, pc
ldr r1, [r1]
blx _objc_msgSend
mov r4, r0
movw    r0, :lower16:(L__unnamed_cfstring_-(LPC4_3+4))
movt    r0, :upper16:(L__unnamed_cfstring_-(LPC4_3+4))
mov r1, r4
LPC4_3:
add r0, pc
blx _NSLog
mov r0, r4
pop.w   {r4, r7, lr}
b.w _objc_release           // 这里我们看出release 掉了 test 变量 也和我们想想的一样.ARC 这里对带类成员变量和普通的临时变量是不同的
</code></pre>

<p>寄存器变量在第一个例子中已经列举了一点, 这个就不赘述啦.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/26/tips/">Tips</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-26T18:05:00+08:00" pubdate data-updated="true">Jan 26<span>th</span>, 2013</time>
        

        
      | <a href="/blog/2013/01/26/tips/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><ol>
<li><a href="#A1">ARC 编译时遇到的相关问题</a></li>
<li><a href="#A2">install cocoapods 问题</a></li>
<li><a href="#A3">Adding Unit Tests to an existing iOS project with Xcode 4</a></li>
<li><a href="#A4">NSDateFormatter 问题</a></li>
</ol>




<div name = "A1" id = "A1"></div>


<h1>ARC 编译时遇到的相关问题</h1>

<ol>
<li>自己的项目没有使用ARC, 其他代码使用ARC</li>
<li>自己项目使用ARC, 其他代码没有使用ARC</li>
</ol>


<p>在Xcode Build Phases 里面的 Compile Source 需要特殊处理的文件 增加 COmpiler Flags
1. 第一种情况 添加 -fobjc-arc
2. 第二种情况 添加 -fno-objc-arc</p>

<div name = "A2" id = "A2"></div>


<h1>install cocoapods 问题</h1>

<p>In Preview of OS X Mountain Lion, Xcode has been distributed as X.app. And Commandline Tools are not installed by default. Commandline Tools contains cc/gcc that you must need to build environment.</p>

<p>Open Xcode and cmd +, to open Preferences panel where you can install Commandline Tools:</p>

<p><img src="/images/commandline.jpg" alt="alt text" /></p>

<p>then</p>

<pre><code>gem install hpricot
gem install cocoapods
</code></pre>

<div name = "A3" id = "A3"></div>


<h1>Adding Unit Tests to an existing iOS project with Xcode 4</h1>

<p>When you build a new iPhone or iPad app from scratch, you can generate a new project with tests using Xcode’s project templates, and the test dependency is set up correctly.</p>

<p>However, if you add a unit test target to an existing iOS project, there are some manual steps required to set up the target correctly. Following these steps will get you up and running quickly:</p>

<p>Project MyExistingApp -> + Add Target -> iOS -> Other -> Cocoa Unit Testing Bundle
Name the new target something like “Unit Tests” or “MyAppTests”
Select your new “Unit Tests” target and click the Build Phases tab, expand Target Dependencies and add MyExistingApp as as a Target Dependency
Click the Build Settings tab and set the Bundle Loader setting to</p>

<pre><code>$(BUILT_PRODUCTS_DIR)/MyExistingApp.app/MyExistingApp
</code></pre>

<p>Set the Test Host build setting to</p>

<pre><code>$(BUNDLE_LOADER)
</code></pre>

<p>Go back to your app target (not the test target), set the Symbols Hidden by Default build setting to NO</p>

<p>That should take care of it, and you can now start adding tests for your app. With this configuration, you continue to add application classes only to your app target, and add test classes only to your test target. Since the tests run in the app running in the simulator, the code under test can safely instantiate views and fonts, which would otherwise cause OCunit to crash when running without the Test Host setting.</p>

<div name = "A4" id = "A4"></div>


<h1>NSDateFormatter 问题</h1>

<p>最近在使用新版本xcode4.6 或是 因为新版本的sdk6.1 日期转换出现了一个问题. 而且是在模拟器可以, 真机不行的问题.
问题是 时间格式中的 &#8220;Thu Jan&#8221; 无法被识别出来. 这个挺奇怪的, 可能新版本修改了默认行为. 下面是解决方法</p>

<pre><code>//time format: @"Thu Jan 17 13:59:11 +0000 2013"
s_format = [[NSDateFormatter alloc] init];
[s_format setDateFormat:@"eee MMM dd HH:mm:ss ZZZZ yyyy"];
[s_format setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]]; //之前少了设定Locale
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/15/happiness/">哈佛幸福课 杂感一</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-15T18:10:00+08:00" pubdate data-updated="true">Jan 15<span>th</span>, 2013</time>
        

        
      | <a href="/blog/2013/01/15/happiness/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><p>好长时间不写博客了, 可以说将近一年的时间里面,并没有多少技术上的积累, 甚至有点倒退的痕迹, 不管是从心气还是态度, 还是毅力上面.我曾经是<em><a href="http://mindhacks.cn/">刘未鹏</a></em>的粉丝,哈,当然现在也一样. 我一直好奇为什么会他会那么的专心在思维这部分.其实在1年前,我也无法想象我会放下我心爱的计算机的书籍而拿起这些曾经我看不上的东西.有些东西的确只有经历过,才会明白.好消息是,一切还来得及.文本和技术类文章毫无瓜葛, 只是我觉得对于Geek们来说,有些其他东西还是很重要的.</p>

<p><em><a href="http://v.163.com/special/positivepsychology/">幸福课</a></em>来自豆瓣小组的推荐, 一开始觉得这个只是一个练习英文听力的一个好的途径, 因为相对电影来说,我觉得对时间的利用率更高, 但事实上, 却是我听过的最好的公开课, 没有之一</p>

<h2>为什么要看这门课</h2>

<p>Tal 也就是这门课的老师, 第一句话就深深的吸引了我, &#8220;我来这里讲这门课, 因为我在本科的时候非常希望能学习这样的一门课程&#8221;.Tal本科在哈佛大学读计算机, 学习成绩优秀 社交优秀, 运动优秀, 但还是有一种说不出来的压抑, 不幸福的感觉,然后他寻找问题的根源, 最后居然转向了哲学和心理学. 看到这里, 我就有一种特别的冲动, 想继续看下去, 想去了解Tal的动机. 我特别好奇的在于, 如何将一个理科思维转向哲学和心理学呢? 当然, 这是我当时的想法,科学本来就是理性,严谨的, 只是我当时对心理学,哲学这些有很多的偏见. 后面我才知道了这门课程讲的是积极心理学.</p>

<p>积极心理学啊, 可能是涉及到一些积极的心理暗示的某些东西, 这是我当时的想法, 不过相比占卜啊,星座啊, 这些扯淡的东西,我还是比较有好感的, 因为我当初在高考前, 学校组织过一次考试时的减压方法的交流会,有一个专家说过, 在做题没有思路的时候, 深呼吸3次, 然后心理默念&#8221;我能行&#8221;, 3次, 然后再读题, 效果会很不错. 然后我当年在考理综的时候, 最后一道物理题,纠结了我挺长时间, 最后就是通过这个心理暗示搞定的.从那之后,从不信到半信半疑.</p>

<p>为什么想学心理学, 主要原因还是,当自己的外部空间拓展收到阻碍, 这个包括 工作, 学习, 人际交往,各种都不顺利, 到达瓶颈, 突然觉得可以向自己内部空间探索.而这些正好和Tal第一节课讲的内容吻合, 我觉得这就是缘分, 一种在正确的时间学正确的东西的缘分.而且Tal是一个内向的心理学老师, 他自己也承认, 而且Tal很风趣幽默.他里面讲了很多自己的故事, 包括很多让自己很尴尬的事情, 感觉很真实, 而不是我看到的其他的那种特别热情, 有力量, 感觉就像江湖卖艺的那种老师.</p>

<h2>什么是幸福</h2>

<p>大家都知道现在社会充斥着浮躁的概念, 不仅在中国, 美国, 全世界都是, 各种各样的秘籍, 捷径, 只要就类似的语句, 还有那句经典的&#8221;移动互联网唯快不破&#8221;, 等等. 尽是些夸大其词, 效果甚微的言论.而这些言论却成了媒体追逐的主要理念, 追求快节奏, 什么都要快.一个个就像兴奋剂一样, 给我们短暂的快感, 但对长远收获来说, 都是弊大于利的.而这些也就是我们不断的感到焦虑,压抑的原因,那么应该如何看待这些信息呢.</p>

<p>Tal 讲得最多的一句话,就是chip away 我们身上的限制, 消除掉我们心理的枷锁.很多人都没有做到permission to be human. 很多时候不能面对自己, 面对自己的情绪, 更别说控制情绪.疏导情绪. 不能合理的理解情绪, 则极大的影响到自己的个人成长, 不论是生活, 工作, 学习, 还是人际交往, 而且我也确确实实的遇到了这方面的困难.</p>

<p>生活包括了起起落落, 这是一件说起来容易, 做起来难的事情, 大家都知道生活包括了失败, 振作, 成功, 迎接新的挑战. 但是人们往往给自己的预期则是和这个道理背驰的. 甚至很多家长自己的心理不成熟而导致孩子心理也不成熟, 比如一个经典的例子, 考上一个好的初中, 高中, 大学, 找到好的工作, 成家就怎怎怎么了, 这个好像一个充分必要条件似的强加在孩子心理上. 幸福没有那么容易获得,也不是一个等式可以解决的.</p>

<p>说到幸福,呵呵,这门课的名字可是讲happiness的, 这里我想到了一个特别搞笑的段子, &#8220;你幸福么?&#8221; 我不在这里重复了, 我在这里其实一直很困惑这个问题. Tal 讲到, 幸福不是一个简单的比较, 0 或1 .要么幸福, 要不不幸福.幸福存在于一个连续的状态,这个很像物理中能量的概念, 我们更关注与能量的转化, 多了还是少了, 而不是在乎我到底具有多少能量.更准确的描述应该是,我们如何才能变得更幸福.</p>

<p>Tal 讲述了一个这样子的观点. 是这样子的一个调查, 调查那些参加终身职位的教授们的心理, 这些教授们只能申请一次一所大学, 要么得到,也么没有. 调查的内容就是, &#8220;如果得到了终身职位,那么会有多开心?&#8221;, 教授们的绝大多数都是回答&#8221;会非常非常高兴, 这实现了很多很多很多年努力的目标, 梦想成真的一刻, 我余生都会非常快乐, 一切都会变得简单, 停止不成功变成仁的竞争, 他将改变我的人生云云&#8221;, 另一个调查是,&#8221;如果得不到终身职位会怎么样?&#8221;, 教授们绝大多数回答&#8221;我们会非常非常难过, 这是很多很多年奋斗的目标, 因为如果在一所学校无法获得终身职位, 就没有可能在更高的学府获得, 只能在低一等的学校获得,所以会难过很长很长时间&#8221;</p>

<p>而在一段时间时候,再次调查教授们的感受, 其中有人得到了, 有人没有得到.&#8221;得到的说非常开心,余生都会非常开心&#8221;, 而那些没有得到的, 则是&#8221;我们很确认我们会难过很长时间&#8221;. 三个月后, 六个月后不管是得到职位的,还是没有得到职位的都恢复到之前的幸福水平.</p>

<p>也就是说, 在得到职位 对他们的幸福感觉, 没有任何帮助, 在长久的角度来看.这既是一个好消息也是一个坏消息.坏消息是似乎无论我们怎么做,都无关紧要, 好消息是,无论这是一个多么糟糕的经历, 最后都会过去.</p>

<p>但这就带来一个问题,为什么我们还要不断地设立目标,努力实现呢?</p>

<p>很多时候我们通过降低我们的心理预期,降低自己的压力,去享受生活, 比如考试只是考了B, 然后我们不去想为什么不是A, A+, 而是想,恩,可以了,及格了,我不在乎成绩;我们的工作不好, 我不在乎我工作什么, 我只想快乐.有些时候,的确降低期望水平,会感到快乐一点.但长远来看却不行.</p>

<p>真正的问题不是在于降低期望, 而是在于区分正确的和错误的期望.一个错误的期望例子,就是我之前提到的,&#8221;考上好大学, 找到好工作, 升职, 找到理想的伴侣,就能让自己更快乐&#8221;. 而让我们更快乐,是通过改变我们对问题,事物的看法,内在的认知,心境来做到的,而不是这些外部条件.(当然,外部条件肯定重要,如果每天都吃不饱, 没有住的地方, 外部条件的改善当然能提升幸福, 这里不考虑这种极端情况).</p>

<p>一个自己的例子吧, 之前很很用心的喜欢过一个女孩子, 但是知道的, 对于我这样的低情商Geek们来说, 结局大多都是悲剧的,觉得自己真的迈不过这个坎, 没法在面对以后的生活了, 没法在北京待下去了, 要逃避. 但现在看来, 当时自己的想法就是哈哈一笑带过了. 现在不是好好的么, 还有一个例子, 当时做IOS开发, AppStore排名是相当的低, 一度AppStore都无法找到了, 当时过年的时候,就定下一个目标, 丫的一定能冲到第一, 而且, 最后的确到第一了, 但也没有觉得特别开心, 觉得自己很厉害什么的.</p>

<h2>Give ourselves the permission to be human</h2>

<p>学积极心理学,主要就是想让自己能够变得阳光, 积极, 不消极. 那么就吧思路聚焦在那些痛苦的,不愉快的经历上面.</p>

<p>很多情绪是与生俱来的, 但是我却在内心里不断得在抵触, 在抗拒那种情绪.有一个简单的例子,就是 &#8220;现在开始,我们脑子里面不要想一个粉色的大象, 恩, 不要想一个粉色的大象, 一定不要想一个粉色的大象&#8221;.</p>

<p>我自己的感受吧, 对于一个低情商男孩来说和一个女孩交往往往会有各种各样神奇的情绪产生, 而且我自己也却觉得不可思议, 不管是嫉妒,羡慕, 负罪感, 等等的情绪. 或是对于一个初步进入社会的男孩, 在工作中也会遇到各种各样的困难,不管是大目标,还是小目标,总是会各种各样的问题, 特别是对我这种有这强大的信心,自我,自恋, 把自己看得很重, 但实际上,别人根本不这么想, 没有那么在意自己.而有时候,发现自己能力的确不够,无力改变一些事情,而陷入一种挣扎.</p>

<p>而且事实上,在现在的社会, 不管是西方还是东方的, 男人们往往不能想女人们一样去向别人倾诉自己的内心真实想法.而随着压力越来越大,而变得焦躁.</p>

<p>Tal 讲述了一个自己的例子, 是当他和她的妻子有第一个孩子的情景. Tal在一个月的时候, 突然发现自己有一种嫉妒的情绪,他很嫉妒她的妻子和医生之间的关系, 因为在他的角度来看, 突然有个另一个人在Tal的妻子心中比Tal获得更多的关注,不管Tal怎么哭…..Tal感到非常的嫉妒.</p>

<p>在看到这个例子的时候, 给我非常大的震惊, 因为看到很多表面现象, 很多人都是永远的宠辱不惊, 在大的压力也面不改色, 遇到再困难的事情都不会害怕,以至于我认为那些家伙们没有这些消极情绪, 而作为情商极高的Tal来说, 肯定不会有这种消极情绪存在,不会这么敏感.</p>

<p>但事实上, 的确有, 那后来的故事是这样子的. Tal说, 在5分钟后,他就想通了这件事情,&#8221;这个医生真的好棒,让我体会到这种以前从来没有过的情绪&#8221; 额, 听到这个, 真的觉得好假. 这也太假了, 我反正是不信, 几分钟钱还充满嫉妒, 几分钟后就感谢他么,太扯了.但是Tal说, 完全正确, 各种各样的情绪就是作为一个human的一部分. 有人的确比另一部分人敏感, 几分钟就能够产生很多各种各样的情绪.Tal说, 我完全接受了我对医生的嫉妒这个情绪, 然后give myself the permission to be human, 然后自然而然的对医生产生了积极的情绪.</p>

<p>这里边会有一种自相矛盾的感觉, 是一个反语的自然现象,就像我之前说过的粉色大象, 我相信大多数人脑子里面都会有一个粉色大象出来.因为当我们企图压抑一种自然现象时, 只会加强它.就像失恋后, 想忘记那个人, 然后不停得对自己说,忘掉,忘掉,但却越来越清晰是一个道理.</p>

<p>在控制自己消极情绪出现的时候, 首先做的,不是压抑他, 而是学会接受他.<em><a href="http://book.douban.com/subject/4194978/">完整的成长</a></em>这本书里面也提到了类似的经历, 让情绪自然而然的流动.</p>

<p>这是一件说起来容易, 做起来非常难的一件事情. 因为我们很多人对心理学有着很大的偏见, 总觉得我们可以控制自己很棒, 因为我们总认为自己很了解自己,但事实上, 我们对自己的理解, 对大脑是如何思维, 决断, 我们的潜意识,我们的基因等等的了解, 相对而来不会比宇宙多多少.</p>

<p>我们不会有一天起来说, OK, 我拒绝万有引力,我不想每天爬楼梯, 我想直接飞过去.这样多简单, 多容易.相对其他科学,比如物理, 我们总是能够很容易的承认物理的基本定理并欣然接受, 而且还能接受他的不足, 比如在量子物理等等很多领域.</p>

<p>但在心理学这里,却有了双重标准. <em><a href="http://book.douban.com/subject/1221479/">与“众”不同的心理学</a></em>这里面也提到了这个基本的道理.</p>

<p>一个简单的例子,就是很多媒体鼓吹的东西,什么占星, 星座, 一些通过特别简单的一些tips, 就可以把一个人了解彻底.多容易,多么简单的捷径, 不需要花费很多时间就可以了解一个人的性格.心理学家似乎就可以通过一眼就可以把这个人了解明白.网上我记得看过一个笑话, 是一个学心理的男孩,在吐槽她的女朋友, 她女朋友有天突然问他, 你知道我现在在想什么, 他说不知道,然后她女朋友说, 你真没用,学心理的居然不知道我想什么.然后他就瞎了.</p>

<p>拒绝自己内心的情绪, 就像不遵守物理中的万有引力定律一样, 会让自己到处碰壁, 而事实上, 我们可以利用万有引力做出很多好玩的游戏, 刺激精彩的运动.但在面对自己的情绪时, 我们却很难做到,甚至面对都很难, 而这里,我真的好佩服Tal的情商了.因为当我有这样的消极情绪,我会觉得一定是那里出了问题, 那里做的不对,然后陷入一大段无意义的思考中, 最后因疲倦而逃避,而不是面对它, 接受它, 甚至是改变它.时间一长,则变的更加焦虑, 抑郁.</p>

<p>而学到这里, 我又有了新的疑惑, 那么就是,如何接受, 被动的接受么?就没有什么可以主动做的么.而事实上,Tal说出了一个非常重要的观点, 就是, 在改变自己, 改造自己之前, 我们需要先知道, 我们可以改变什么, 不可以改变什么.</p>

<p>这里Tal 提出了一个很犀利的观点.心理学的A B C</p>

<p>A: affect           情绪</p>

<p>B: behavior       行为</p>

<p>C: cognition      思想,认知</p>

<p>permission to be human 主要是和情绪相关的. 比如,我们有愤怒的情绪,接受它但并不是意味着, 我们也要接受那些因为愤怒而做出伤害他人的行为.Tal嫉妒医生, 并不代表Tal是一个坏人, 这个没有好坏之分.很多时候,我们应该采用什么样的行为去表达情感, 这个才是问题的关键. 就像之前发生的一名男子失恋后, 在地铁里面划女孩脸. 我们承认失恋的确很难过, 但是通过这种行为表达自己的难过, 就是不能接受的.</p>

<p>对于认知这部分同样. 我们可以有消极的情绪,但并不意味着我们必须屈从于消极情绪带来的消极的想法.而且事实上沉思,下功夫琢磨对消极情绪这里,并没有多大帮助, 通常会越来越糟. 比如一直在想,哦,我被女朋友甩了,这有多么的惨.</p>

<p>举一个我的例子吧, 我很喜欢沉思,但是在对待消极情绪这里就遇到了极大的困难,恩, 算了, 我还是在改变里面讲这个吧.</p>

<p>一个情商高, 内心强大的家伙, 不是没有那些消极的情绪, 就像一个强壮的身体, 不可能永远不得病, 而是因为更有抵抗能力, 在面对病症时,也可以更快的恢复.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/05/22/asm-win32/">Win32汇编学习（1）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-05-22T18:49:00+08:00" pubdate data-updated="true">May 22<span>nd</span>, 2010</time>
        

        
      | <a href="/blog/2010/05/22/asm-win32/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><p>终于把学校里面让人无语的论文搞定了。周末终于有时间干些自己想干的事了。想起了这2周做的关于编译原理的实验，代码优化这部分的确是个难题。哎，我实在是太笨了，其实答案就在自己电脑里。将c程序反汇编后，终于第一次感受到了debug 和release的区别。兴奋之余让我又产生了忧虑，自己汇编的能力太弱了，面对稍微复杂点的算法再加上编译优化后的汇编代码，真是欲哭无泪。痛下决心，准备好好学学汇编了。为了给自己一个动力，准备学习Win32汇编（和学校那个8086再见了）。</p>

<p>　　第一天，不准备上难度了。从最简单的&#8221;HelloWorld&#8221;开始。</p>

<pre><code>; HelloWorld.asm

comment * ----------------------------------------------
                 The First Assemble Application
                ---------------------------------------------- *

.386
.model flat, stdcall
option casemap:none

include \masm32\include\windows.inc

include \masm32\include\user32.inc
include \masm32\include\kernel32.inc

includelib \masm32\lib\user32.lib
includelib \masm32\lib\kernel32.lib

    .data
szCaption   db 'MessageBox', 0
szText      db 'Hello, World!', 0

    .code
start:
    invoke MessageBox,\     ; 调用函数名
        NULL,\                      ; 父窗口句柄
        offset szText,\           ; 文字
        offset szCaption,\      ; 标题
        MB_OK                    ; 按钮类型

    invoke ExitProcess, NULL
end start
</code></pre>

<p>一个简单的窗口就创建好了。一眼看上去发现和以前的8086还是有很多不同的。</p>

<p>首先8086和80386在寻址方式不同。</p>

<p>8086 通过 段地址*0x10 +偏移地址确定的。只能寻址1M，而80386 32根地址线寻址，空间达到了4G而且80386 通用寄存器大小为32位，所以不需要分段就能访问到地址。</p>

<p>那么.data,.code不是段的意思么？ 不是。因为808386有分页机制，每个页可以自由制定属性，已经和8086代码和数据分段处理完全不同，实际上是把不同类型的数据或代码归类，再放到不同属性的内存页。</p>

<p> 其次，8086的不安全，不方便的调用中断的方式改为了调用系统API的方式。我这里是采用的MASM，所以有invoke伪指令，其实这个指令也没别的，就是为我们编程省去了函数参数入栈的那些push。</p>

<p>最后，发现win32汇编和使用c/c++似乎没有复杂很多。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/04/24/mult-threading2/">多线程程序设计笔记二</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-04-24T18:46:00+08:00" pubdate data-updated="true">Apr 24<span>th</span>, 2010</time>
        

        
      | <a href="/blog/2010/04/24/mult-threading2/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><p>当我们正式开始之前，我想再多说一点，上一篇最后的那个程序可能会给像我一样的菜鸟一个误解，这里解释下。</p>

<p>程序启动后就执行的那个线程称为主线程（也就是那个程序中的执行main函数的线程），而其他线程则成为子线程。主线程和其他线程最大的区别是当主线程返回或是调用一些函数强制退出后，使得程序中的其他子线程强制结束。 在一篇中native code和Manager code 在遇到同样的问题时，.net给我们做了一个好的榜样，其实不管是否是UI子线程，.net 控制台在终止进程结束之前，都会保证所有子线程已经退出。虽然我们无法知道到底它采用的是什么机制（我的理解是在调用结束进程之前调用了WaitForMultipleObjects或是其他wait函数等待所有子线程返回），但是这体现了一个很重要的原则，对产生的子线程负责，无论什么时候，都不应该直接结束程序而不等待子线程结束。因为子线程没有机会做清理工作。这个是一个非常可怕的问题，想这样的一个情况，子线程比如正在申请一个堆空间，而正好锁住了那个区域，然后被强制结束了。那么就很可能产生了内存泄露（产生不了也会增大系统负担）。所以再次提醒自己主线程在退出的时候，必须保证所有的子线程已经退出。</p>

<p>从上一篇《多线程程序设计笔记一》中，我们知道了多线程程序设计的最基础的知识。下面总结下线程之间的通讯和同步问题。不过这个问题实在是太大了，对我来说。这里先只涉及最简单的在同一进程下的用户方式下的同步问题。</p>

<p>以下内容将包括：</p>

<p>互锁函数
临界区
互锁函数</p>

<p>互锁函数运行在用户模式。它能保证当一个线程访问一个变量时，其它线程无法访问此变量，以确保变量值的唯一性。</p>

<p>下面是一个简单的例子。</p>

<pre><code>DWORD WINAPI ThreadFunc1(PVOID n)
{
  while(InterlockedExchange(&amp;g_bResourceInUse,TRUE) == TRUE)
    SwitchToThread();
  printf("thread1 used\n");
  InterlockedExchange(&amp;g_bResourceInUse,FALSE);
  return 0;
}
DWORD WINAPI ThreadFunc2(PVOID n)
{
  while(InterlockedExchange(&amp;g_bResourceInUse,TRUE) == TRUE)
    SwitchToThread();
  printf("thread2 used\n");
  InterlockedExchange(&amp;g_bResourceInUse,FALSE);    
  return 0;
}
</code></pre>

<p>这个例子通过不断地判断bResourceInUse中的信息来确定线程是否能够使用资源。但是使用这个方法必须小心。大量的循环运算会浪费宝贵的CPU时间。而且如果是在单CPU下，线程不可能真正的异步执行，在thread1判断while的时候，thread2并不能做什么（不能修改该值）。所以我们应该避免在单个CPU计算机上使用循环锁。</p>

<p>这里面还有一个需要知道的是必须使用关键字volatile声明g_bResourceInUse。我们需要把循环锁变量和循环锁保护的数据维护在不同的高速缓存行中。通过高速缓存行CPU可以不必访问内存总线而获得数据，但是在多处理器环境中，高速缓存行使得内存更新更加困难。如下：</p>

<p>CPU1读取一个字节，将该字节和相邻字节读入CPU1的高速缓存行。
CPU2读取同一个字节。从而和第一步相同的内容读入了CPU2的高速缓存行。
CPU1修改该字节，因为已经在高速缓存行中，所以修改后的内容写入CPU1的高速缓存行，这个信息还没有写入内存。
CPU2再次入去同一个字节。因为已经放入了CPU2的高速缓存行，所以CPU2不会访问内存。那么问题出现了。这个字节并不是该字节的新值。
这个问题的确很严重，不过硬件工作者已经给我们解决了这个问题，当一个CPU修改高速缓存行字节时，其他CPU会被告知这个情况，他们的高速缓存行将无效。所以第四步中，CPU1必须将高速缓存行转入内存，而CPU2必须再次访问内存。</p>

<p>原因想说清楚这些我现在还不行，这又涉及到了多核编程（哎，愧对老师啊，《多核程序设计》那课是白学了）。不过这里还是必须解释下volatile。</p>

<p>被定义为volatile的变量，每次从内存中读取，而不能把他放在cache或寄存器中重复使用。
告知编译器不要对这个变量做优化。
告知编译器，变量可以被应用程序本身以外的某个东西进行修改，这些东西包括操作系统，硬件或同时执行的线程等。</p>

<p>当必须以原子操作方式修改32为，64位值时，我们可以使用互锁函数。他们很有效率。但是实际工作，我们需要面对更复杂的数据结构。而且他们的效率是不进入内核态而节省下的。如果等待资源时间过长，就变成对CPU极大的浪费了，我们需要一种机制，使线程在等待访问共享资源时不浪费CPU时间。</p>

<p>临界区（Critical Section）又叫做关键代码段</p>

<p>临界区的描述</p>

<p>win32提供的一种轻量级的同步机制，它存在于进程的内存空间中。一次只有一个线程获准进入临界区执行代码段，（其实就是让若干行代码能够以原子操作方式来使用资源）。
它并不总是执行向内核模式的控制转换，要是获得一个未被占用的临界区时，只需要在用户态内的很少运算就能完成，只有在尝试获得已占用临界区时，它才会跳至内核模式。
只能在属于同一个进程的线程间同步。
补充一点，比如当线程A试图进入线程B拥有的临界区时，线程A将被置于等待状态。线程B离开临界区，线程A将处于可调度状态。让线程A立即等待，并不一定立即切换到内核方式。MS为了提高关键代码段的运行性能，将循环锁加入了这些代码段。当调用 EnterCriticalSection 它使用循环锁进行循环，只有当每次尝试获取都失败时才转入内核方式，从而线程A进入等待状态。</p>

<p>这里可能就又糊涂了。之前说的循环锁不是效率很低么？的确，但是如果和转入内核方式比所消耗的资源少的话，就是可行的。比如我们仅仅是想操作一个指针。当然，如果是在单CPU下，循环锁是没有意义的，会直接转入内核方式。</p>

<p>临界区的使用方法</p>

<pre><code>    通过 InitializeCriticalSection 或 InitializeCriticalSectionAndSpinCount 函数初始化一个 CRITICAL_SECTION 结构，使用 SetCriticalSectionSpinCount 函数设置临界区的Spin计数器（可选）。然后使用 EnterCriticalSection 或 TryEnterCriticalSection 获取临界区的所有权；完成需要同步的操作后，使用 LeaveCriticalSection 函数释放临界区。最后使用 DeleteCriticalSection 函数析构临界区结构（只是删除RTL_CRITICAL_SECTION_ DEBUG）。
</code></pre>

<p>讲了这么多理论，实践一下。</p>

<p>下面是对上一篇List做的多线程改进。</p>

<pre><code>typedef struct _Node
{
  struct _Node *next;
  int data;
}Node;
typedef struct _List
{
  Node *head;
  CRITICAL_SECTION sec;
}List;
List *CreateList()
{
  List *pList = (List *)malloc(sizeof(pList));
  pList-&gt;head = NULL;
  InitializeCriticalSection(&amp;pList-&gt;sec);
  return pList;
}
void DeleteList(List *pList)
{
  DeleteCriticalSection(&amp;pList-&gt;sec);
  free(pList);
  pList = NULL;
}
void AddHead(List *pList,Node *node)
{
  EnterCriticalSection(&amp;pList-&gt;sec);
  node-&gt;next = pList-&gt;head;
  pList-&gt;head = node;
  LeaveCriticalSection(&amp;pList-&gt;sec);
}
</code></pre>

<p>当然事实上没有这么简单。比如当交换两个链表内容的函数</p>

<pre><code>void SwapLists(List *list1,List *List2)
{
  List *temp_List;
  EnterCriticalSection(list1-&gt;sec);
  EnterCriticalSection(list2-&gt;sec);
  tmp_List-&gt;list = list1-&gt;head;
  list1-&gt;head = list2-&gt;head;
  list2-&gt;head = temp-&gt;list;
  LeaveCriticalSection(list1-&gt;sec);
  LeaveCriticalSection(list2-&gt;sec);
}
</code></pre>

<p>当threadA: SwapLists(list1,list2);threadB:SwapLists(list2,list1)。两个线程会落入“我等你，你等我”的轮回，这种情况称为死锁。</p>

<p>任何时候当一段代码需要1个以上的资源时，都可能发生死锁。而我们防止死锁通常的做法是保证“all or nothing”，也就是要不全部拥有，要不什么也没有。</p>

<p>其实上面的代码还隐藏了一个问题，SwapList函数在使用的时候无形的需要确保一个资源使用的顺序。也就是说这个函数的运程依赖于代码的执行顺序，这种设计本身就是很脆弱的。</p>

<p>临界区需要注意的</p>

<p>每个共享资源使用一个CRITICAL_SECTION。只有被临界区Enter和Leave“围起来”的资源才能获得保护，临界区维护的只是一段代码（代码中通常有一些资源）。
当同时访问多个资源的时候，使用临界区非常容易造成死锁， EnterCriticalSection 的顺序是需要认真考虑的但是并不一定十分可靠， LeaveCriticalSection 顺序则没有关系。
不要长时间运行临界区，也就是不要长时间锁住一个资源。但是时间到底多长很难确定在windows OS中，所以不要在一个CRITICAL_SECTION中调用Sleep或Wait….API函数，SendMessage。当你以一个同步机制保护一份资源时，必须牢记“这项资源被使用频率如何？线程必须多块释放资源，才能确保整个程序运作平顺”。
无法获知进入临界区的线程状态。由于临界区不是核心对象，如果一个线程进入临界区后，没有Leave，系统没有办法清除临界区。而且如果一个线程在Enter时被等待，那么等待的最长时间也是不能设定的。（也减少了一个处理错误的方式）
想要了解更多的关于临界区的，参考http://msdn.microsoft.com/zh-cn/magazine/cc164040(en-us).aspx</p>

<p>中文http://www.microsoft.com/china/MSDN/library/enterprisedevelopment/softwaredev/ousCriticalSections.mspx?mfr=true</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/04/16/mult-threading/">多线程程序设计笔记一</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-04-16T18:11:00+08:00" pubdate data-updated="true">Apr 16<span>th</span>, 2010</time>
        

        
      | <a href="/blog/2010/04/16/mult-threading/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><p>多线程编程，学习了一个星期，总结一下。以下内容全部基于windows操作系统。  由于实力有限，对操作系统没有深入了解（或是根本不了解吧），一下内容主要来自《windows核心编程》、《win32多线程程序设计》、一些网上高人的见解和自己的理解而自己的认识难免有些偏差，希望大家挑挑毛病。谢谢。</p>

<h1>进程和线程的区别。</h1>

<p>进程通常被定义为一个正在运行的程序实例，它由两个部分组成</p>

<p>1.操作系统用来管理进程的内核对象。内核对象也是系统用来存放关于进程的统计信息的地方。
2.地址空间，它饱含所有可执行模块或DLL模块的代码和数据。它还包含动态内存分配的空间。如线程堆栈和堆分配空间。</p>

<p>线程是CPU调度的基本单位。由两个部分组成的</p>

<ol>
<li>一个是线程的内核对象，操作系统用它来对线程实施管理。内核对象是系统用来存放线程统计信息的地方。</li>
<li>线程堆栈，它用于维护线程在执行代码时需要的所有函数参数和局部变量。</li>
</ol>


<p>单个进程可能包含多个线程，而线程都“同时”执行进程地址空间中的代码，为此每个线程都有它自己的一组CPU寄存器（称为线程的上下文）和它自己的堆栈。进程是不活泼的，从不执行任何东西，它只是线程的容器。操作系统为每个线程安排一定的CPU时间片，仿佛所有线程都是同时运行一样。在同一个进程下的多个线程，能够执行相同的代码，对相同的数据进行操作，共享内核对象句柄。</p>

<h1>Context Switch</h1>

<p>在一个抢占式多任务操作系统中，操作系统确保每个线程都有机会执行，它依赖硬件的协助以及其他的工作。当硬件计时器认为某个线程已经执行够久了，就会发出一个中断，与之CPU保存线程的当前状态，把所有寄存器内容复制到堆栈中，再把它从堆栈中复制到CONTEXT结构中。操作系统通过恢复CONTEXT结构中的寄存器值来切换不同的线程。（当然得先切换到该线程隶属的进程内存）。这个过程为Context Switch 。当然如果有非常多的CPU，也就不需要进行Context Switch。</p>

<h1>使用多线程的原因。</h1>

<ol>
<li>和进程相比，它是一种非常&#8221;节俭&#8221;的操作方式。启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。</li>
<li>线程间方便的通信机制。同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用。</li>
<li>提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作和UI线程工作分开。</li>
<li>线程彼此分享了大部分核心对象的拥有权。</li>
<li>在多CPU下，多个线程可以真正的同时运行，提高了CPU的利用率。</li>
</ol>


<h1>多线程所带来的问题</h1>

<ol>
<li>多线程在单CPU上实际上是一个假象，CPU的时间总是有限的，如果用的不好，反而增加了CPU的负担，降低了系统性能。</li>
<li>多线程发生共享数据空间，在这个抢占式环境下线程运行次序无法预期，容易产生竞争，导致程序效率降低，出错，甚至死锁。</li>
<li>过多的线程导致过多的Context Switch，也会降低运行效率。</li>
</ol>


<p>讲了这么多，可见多线程程序设计给程序员带来了更高的要求。再查MSDN的时候，有的API会附上线程安全而有的却没有。下面我们开始进入多线程编程世界。</p>

<p>在进入多线程世界之前，先想一个问题。</p>

<p>设想一下，假如有一个简单的增添链表的操作</p>

<pre><code>AddHead(struct List *list,struct Node *node)
{
   node -&gt; next = List-&gt;head;
   List-&gt;head = node;
}
</code></pre>

<p>这个程序若是在多线程下进行的话，会出问题。 比如当thread1 正在执行 AddHead，而Context Switch发生在node->next = List->head 和 List->head = node语句之间，而thread2也要执行AddHead，而且正确执行之后，并把一个节点添加到List中，那么当Context Switch发生，而thread1执行List->head = node后，那么thread2添加的节点就不在List中了，造成了内存泄露，而且的确，你可以想到很多出错的可能性。你可能说这个问题出现的概率很低，但是多想一下，若是这个程序是在一个搜索引擎中，每天有多少人去运行这个程序？而且CPU是以每秒千万级（我的YY，反正是很快）运行，那么程序的问题就不可避免。而之所以产生了问题，就是因为thread1和thread2产生了竞争（race condition）。</p>

<p>当然可能你一下子就有了思路，产生这个问题的关键是在于在发生race 的地方设置变量，来“保护”AddHead的操作正确。</p>

<pre><code>AddHead(struct List *list,struct Node *node)
{
   while(flag !=0)
   flag = 1;
   node -&gt; next = List-&gt;head;
   List-&gt;head = node;
   flag = 0;
}
</code></pre>

<p>这个代码似乎可以正确运行，但是很遗憾，还是不行。好吧让我们先来明确一个知识。<strong>Atomic Operations(原子操作)</strong>。
一下是AddHead的汇编代码</p>

<pre><code>AddHead(struct List *list,struct Node *node)
{
  xor eax,eax 
  s: 
  ;while(flag !=0) 
  cmp DWORD PTR _flag,eax 7   
  jne short s 
  ;flag = 1; 
  mov eax,DWORD PTR _list$[esp-4]
  mov ecx,DWORD PTR _node$[esp-4]
  mov DWORD PTR _flag,1
  ;node -&gt; next = List-&gt;head;
  mov edx,DWORD PTR [eax]
  mov DWORD PTR [ecx],edxx
  ;List-&gt;head = node;
  mov DWORD PTR [eax],ecx
  ;flag = 0;
  mov DWORD PTR _flag,0
  ret 0
   ;小弟还没学习完汇编，有一些操作码还是不知道，只能是理解意思，不能保证
  ;肯定能执行，例子来自《Win32多线程程序设计》
;}

# Atomic Operations(原子操作)

简单的几行代码在执行时会转换成这么多代码，不能指望C，C++这种高级语言的语句可以一次执行完毕而不发生Context Switch。
</code></pre>

<p>而且还存在编译器优化（比如一些循环语句等等）真实在机器上执行的代码可能和你所希望的是不同的。</p>

<p>原子操作（Atomic Operation ）指一个操作如果能够不受中断的完成。</p>

<p>所以上例的检查标记和设立标记的动作必须是一个Atomic Operation，如果中断了，就不能避免竞争。</p>

<p>好吧让我们真正的开始多线程编程旅行吧，我们和学习其他任何知识一样，来一个HelloWorld。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;windows.h&gt;

DWORD WINAPI ThreadFunc(LPVOID);

int main()
{
    HANDLE hThrd;
    DWORD threadId;
    hThrd = CreateThread(NULL,
,
            ThreadFunc,
,//(LPVOID)i,
,
            &amp;threadId );
    if (hThrd)
    {
      printf("Thread launched\n");
      CloseHandle(hThrd);
    }
    //Sleep(2000);
    return 0;
}

DWORD WINAPI ThreadFunc(LPVOID n)
{
  printf("HelloWorld\n");
  return 0;
}
</code></pre>

<p>运行后发现悲剧了,Thread launched有了,但是没有我们的熟悉HelloWorld(对大部分人来说是没机会看到HelloWorld的),那么我们又遇到什么问题了?</p>

<p>加上Sleep后,HelloWorld出现了,好吧,我们又发现了,创建一个线程,并写一个调用函数,和我们在main函数中写一个子程序不是一回事。</p>

<p>一个函数调用操作，程序的控制权转移到被调函数中，执行完毕后在返回原调用处。</p>

<p>产生一个线程，情况也十分类似，但是有些曲折，线程函数中我们是通过CreateThread，并传给ThreadFunc的地址。CreateThread开启一个新的线程，该线程调用ThreadFunc而原来的线程继续前进。好吧。ThreadFunc相对main来说异步执行了。那么ThreadFunc不需要在main结束之前返回，所以，main函数返回了，ThreadFunc还没来得及返回，所以没有显示HelloWorld，而Sleep之后，那么ThreadFunc返回了，那么也就显示HelloWorld。</p>

<p>当main函数返回后，操作系统中止整个进程，收回大部分或全部资源，而你的thread就还没工作完就被“干”掉了。</p>

<p><strong>当然你也可能会产生另一个疑问，main函数返回了，进程结束了，thread就直接悲剧了，能不能让main函数返回，进程不结束，thread不悲剧呢？</strong></p>

<pre><code> static void Main(string[] args)
 {
   Thread th = new Thread(ShowWindow);
   th.Start();
   Console.WriteLine("窗体已创建,敲任意键退出...");
   Console.ReadKey();
   Console.WriteLine("Main thread End");
 }
  static void ShowWindow()
 {
   MessageBox.Show("test");
 }
</code></pre>

<p>这是一段C#代码，主要来自<a href="http://blog.csdn.net/bitfan/archive/2010/01/14/5191299.aspx">ref</a>我稍微改动了一点点，这段代码可以保证即使主线程退出了，只要窗体没有关闭，操作系统会认为“进程”仍在执行，因此，控制台窗口会保持显示，直到窗体关闭，整个进程才结束。在这种情况下，本示例程序中有两个UI线程，一个是控制台窗口，另一个创建应用程序窗体的那个线程。</p>

<p>如下是我模仿上边代码，写的c++的例子</p>

<pre><code> int main()
 {
   HANDLE hThrd;
   DWORD threadId;
   HANDLE handle;
   hThrd = CreateThread(NULL,
           0,
           ThreadFunc,
           0,//(LPVOID)i,
            0,
           &amp;threadId );
   if(hThrd)
   {
     printf("Thread launched\n");
     CloseHandle(hThrd);
   }
   Sleep(5000);
   printf("Main Thread End\n");
   return 0;
 }
 DWORD WINAPI ThreadFunc(LPVOID n)
 {
   MessageBox(NULL,"test","test",MB_OK);
   printf("thread1 End\n");
   return 0;
 }
</code></pre>

<p>令人遗憾的是，我写的这个，在main函数返回后，整个进程也随之结束了。。。。。。</p>

<p>好吧。我承认我错了，到底哪里出了问题。我是搞不定了。这个花了我大概2天的时间，曾经我一度以为UI线程和Message queue之间有某种必然的联系，但是上例完全证明了我之前的想法是可笑的或是我整个思考出发点就是错误的。在thread1中不仅调用了GDI函数，而且能够响应消息（说明已经有了Message queue和Message loop）。</p>

<p>看来我得继续学习才能搞定这个了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/04/06/thumb-pic2/">缩略图设计初探二</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-04-06T18:43:00+08:00" pubdate data-updated="true">Apr 6<span>th</span>, 2010</time>
        

        
      | <a href="/blog/2010/04/06/thumb-pic2/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><p>之前的问题还是很大的，参考了.net framework Dictionary的思路，保留MPQ的hash算法和判断冲突的思路。重新整理了一下。</p>

<p>第一部分：改进部分</p>

<p>1、处理冲突的方法由原来线性再散列，改为分离链表法。</p>

<p>2、修正了一些因为处理冲突而变化的部分。</p>

<p>3、增加了扩容的部分。</p>

<p>4、增加了CRC校验部分。</p>

<p>第二部分：疑问</p>

<p>1、如何保证数据的安全性？Delete操作只是将数据从hashTable中delete，但是文件中依然有图片存在。</p>

<p>要么将每个图片加密储存，但是手机上资源消耗太大。那么最有可能就是delete之后将文件数据格式中关键数据上写一些随机数，从而正常解码失败。</p>

<p>2、如果要统一管理图片，需要建立文件索引。</p>

<p>3、过多的seek会影响效率，我这里还是保存了文件的偏移量，在读取的时候也必然会seek，因为我觉得使用seek似乎没有在效率产生很大的损失（可能我测试的数据不具有普遍性吧），但是很多资料上都对寻道很讨厌。这里我又参考了一下空间问题，故而保存了文件偏移量。</p>

<p>第三部分：部分代码</p>

<p>插入</p>

<pre><code>BOOL MPFile::InsertData( LPCVOID lpBuffer, TCHAR *lpszString, const UINT fileSize, const FILETIME LastModiTime, 
        LONG &amp;lindex, DWORD dwFlags )
{
    ASSERT( lpBuffer != NULL );
    ASSERT( lpszString != NULL );

    if( m_pMPBlockTable == NULL ) Initialize(0);
    const DWORD HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;   
    DWORD hashCode = hash.HashString(lpszString, HASH_OFFSET);   
    DWORD nHashA = hash.HashString(lpszString, HASH_A);   
    DWORD nHashB = hash.HashString(lpszString, HASH_B);   

    DWORD targetBucket = hashCode % (m_pMPFileHeader-&gt;nHashTableLength); 
    for ( LONG i = m_pMPBlucketTable[targetBucket].iBlockIndex; i &gt;= 0; i = m_pMPBlockTable[i].MPEntry.iNext ) 
    {
        if( m_pMPBlockTable[i].MPEntry.dwHashCode == hashCode
    　　　　&amp;&amp;m_pMPBlockTable[i].MPEntry.dwHashValueA == nHashA 
    　　　　&amp;&amp; m_pMPBlockTable[i].MPEntry.dwHashValueB == nHashB )
        {
        if( !(dwFlags &amp; INSERT_REPLACE_EXISTING) ) {return FALSE;}
            return SetDataToFile(lpBuffer,lpszString,i);
        }
    }
    // add new 
    LONG index;
    BOOL isNew=TRUE;
    if (m_pMPFileHeader-&gt;nFreeCount &gt; 0) 
    { 
        index = m_pMPFileHeader-&gt;iFreeList;
        m_pMPFileHeader-&gt;iFreeList = m_pMPBlockTable[index].MPEntry.iNext;
        m_pMPFileHeader-&gt;nFreeCount--;
        isNew = FALSE;
    } 
    else 
    {
        if (m_pMPFileHeader-&gt;nChildFileCount == m_pMPFileHeader-&gt;nHashTableLength) 
        {
            ReSize();
            targetBucket = hashCode % (m_pMPFileHeader-&gt;nHashTableLength);
        }
        index = m_pMPFileHeader-&gt;nChildFileCount;
        m_pMPFileHeader-&gt;nChildFileCount++;
    } 

    m_pMPBlockTable[index].MPEntry.dwHashCode= hashCode; 
    m_pMPBlockTable[index].MPEntry.iNext = m_pMPBlucketTable[targetBucket].iBlockIndex; 
    m_pMPBlockTable[index].MPEntry.dwHashValueA = nHashA;
    m_pMPBlockTable[index].MPEntry.dwHashValueB = nHashB;
    m_pMPBlockTable[index].dwFlag = dwFlags;
    m_pMPBlockTable[index].nSize = fileSize + sizeof(MINIPICDATAITEMHEADER)+sizeof(DWORD);//size add fileName and crc32
    m_pMPBlucketTable[targetBucket].iBlockIndex = index;

    lindex = index;

    //TODO:修改数据
     if(isNew)
    {
        m_pMPBlockTable[index].FileStartAt = m_endOfFileData;
        if(SetDataToFile(lpBuffer,lpszString,index) )
        {
            m_endOfFileData+=m_pMPBlockTable[index].nSize;//TODO:防止溢出
        　　  return TRUE;
        }
        return FALSE;
    }
    else
    {
        return SetDataToFile( lpBuffer,lpszString, index );
    }
}
</code></pre>

<p>读取数据</p>

<pre><code>LONG MPFile::FindEntry( TCHAR *lpszString )
{
    ASSERT(lpszString!=NULL);
     if (m_pMPBlucketTable != NULL ) 
     {
        const DWORD HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;   
        DWORD    hashCode = hash.HashString(lpszString, HASH_OFFSET);   
        DWORD    nHashA = hash.HashString(lpszString, HASH_A);   
        DWORD    nHashB = hash.HashString(lpszString, HASH_B);   
        DWORD    nHashStart = hashCode % (m_pMPFileHeader-&gt;nHashTableLength);   

        for (LONG i = m_pMPBlucketTable[nHashStart].iBlockIndex; i &gt;= 0; i = m_pMPBlockTable[i].MPEntry.iNext) 
        {
            if (m_pMPBlockTable[i].MPEntry.dwHashCode == hashCode 
                &amp;&amp;m_pMPBlockTable[i].MPEntry.dwHashValueA == nHashA 
                &amp;&amp; m_pMPBlockTable[i].MPEntry.dwHashValueB == nHashB )
            return i;
        }
     }
     return -1;
}
</code></pre>

<p><a href="http://files.cnblogs.com/studentdeng/MP_v2.rar">MP_v2.rar源码</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/03/24/thumb-pic1/">缩略图设计初探</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-03-24T18:35:00+08:00" pubdate data-updated="true">Mar 24<span>th</span>, 2010</time>
        

        
      | <a href="/blog/2010/03/24/thumb-pic1/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><h2>第一部分简介：</h2>

<p>最近有幸参加了一个网上的开源项目，需要我设计一个缩略图存储的方法。整个思路主要是模仿XP的实现方式，而对于Win7（或是Vista）里面将所有缩略图统一管理的模式没有采用。主要想法还是一切从简，这也就是初探的来由了。</p>

<p>整个缩略图的核心算法来自《Inside MoPaQ》http://shadowflare.samods.org/inside_mopaq/</p>

<p>核心是将文件名通过Hash散列到表中，从而达到快速查找的目的。</p>

<p>MPQ文件，对于大部分大学时间沉浸的游戏——War3是非常重要的，每次War3版本的更替都对这个文件做了修改。的确，对于一个计算机系的非常爱玩的我，现在才分析MPQ实在是惭愧。</p>

<p>对于我这个文件名，现在姑且命名为MP(MiniPic)。</p>

<p>这是我第一次用c++来写程序，整个程序很简单，花了差不多1个半月（我这个效率实在不行），和第一篇一样，希望各位大哥能帮忙看看。</p>

<h2>第二部分实现：</h2>

<ol>
<li>需求</li>
</ol>


<p>1.1          这里实现读取，修改固定大小的文件，即每个缩略图的存储空间大小一致。</p>

<p>1.2          根据文件名添加，查找，删除功能。</p>

<p>1.3          文件存储数目固定，不能动态增长。</p>

<p>1.4          储存文件名，使用ID形式访问。</p>

<p>2.存储方案</p>

<p>2.1          表结构设计</p>

<p>整个文件包括FileHeader，HashTable，BlockTable，DataHeader，Data构成。通过计算文件名的hash值，将文件名散列到HashTable中，然后根据HashTable中查找BlockTable（文件块表），在BlockTable中查找到实际文件data的位置。读入DataHeader和Data。</p>

<p>FileHeader HashTableItem HashTableItem &#8230;&#8230; HashTableItem</p>

<p>BlockTableItem BlockTableItem DataHeader Data DataHeader</p>

<p>Data
&#8230;</p>

<p>2.2          内存中存储。</p>

<p>内存中存储FileHeader、HashTable、BlockTable、DebrisBlock,dataBuffer。</p>

<p>DebrisBlock是队列结构。存储因删除操作而产生的碎片。</p>

<p>FileHeader，HashTable，BlockTable是数组。dataBuffer数据缓存</p>

<p>3.实现方案</p>

<p>实际还需要增加功能，以下是核心部分。对于每个功能的算法也只写核心部分。</p>

<p>3.1       增加</p>

<p>3.1.1     将文件名转换为数字。这里使用的是MPQ文件算法。</p>

<pre><code>DWORD HashManager::HashString( TCHAR *lpszFileName,DWORD dwHashType )
{
    BYTE *key = (BYTE *)lpszFileName;   
    DWORD seed1 = 0x7FED7FED, seed2 = 0xEEEEEEEE;   
    int ch;   

    while(*key != 0)   
    {
        ch = toupper(*key++);
        //原来是char，这里处理TCHAR中的0，这里也有小问题，如果要更多的地方使用，还需要做大头小头机数据转换
         if(!*key)
        {
            ++key;
        }
        seed1 = cryptTable[(dwHashType &lt;&lt; 8) + ch] ^ (seed1 + seed2);   
        seed2 = ch + seed1 + seed2 + (seed2 &lt;&lt; 5) + 3;    
    }   
    return seed1; 
}
</code></pre>

<p>3.1.2     插入HashTable。</p>

<p>在处理冲突的时候，是采用最简单的线性探查法，在判断位置相同的时候，采用增加2个Hash值的方法。虽然不能保证肯定不会出问题。但是3个相同的概率很低，大概是10的22.3次方分之一，这个是在参考《Inside MoPaQ》，中的数据，是否可靠。我无法确定。</p>

<pre><code>BOOL HashManager::InsertHashTable( TCHAR *lpszString, FILETIME FileTime, LONG &amp;HashPos, DWORD dwFlags,
                                   BOOL &amp;isNew//设置，是否是新文件
)
{
    ASSERT( m_pHashIndexTable!= NULL );
    isNew = TRUE;
    const DWORD HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;   
    DWORD nHash = HashString(lpszString, HASH_OFFSET);   
    DWORD nHashA = HashString(lpszString, HASH_A);   
    DWORD nHashB = HashString(lpszString, HASH_B);   
    DWORD nHashStart = nHash %m_hashTableLength;   
    DWORD nHashPos = nHashStart;   
    DWORD x=m_pHashIndexTable[nHashPos].dwFlag &amp; FILE_EXISTS;
    DWORD y = m_pHashIndexTable[nHashPos].dwFlag &amp; FILE_DELETED;
    while( x!=0 )
    {   
        if( y==FILE_DELETED )
        {
            isNew = FALSE;
            break;
        }
        //如果有同名文件
         if (m_pHashIndexTable[nHashPos].dwHashValueA == nHashA                &amp;&amp; m_pHashIndexTable[nHashPos].dwHashValueB == nHashB)
        {
            if( dwFlags &amp; INSERT_CHECK_FILETIME )
            {
                if(m_pHashIndexTable[nHashPos].dwFileLastModiTime.dwHighDateTime == FileTime.dwHighDateTime
                   &amp;&amp; m_pHashIndexTable[nHashPos].dwFileLastModiTime.dwLowDateTime == FileTime.dwLowDateTime)
                {
                  return FALSE;//说明文件真实存在,插入失败
                  }
                else
                {
                    isNew = FALSE;
                    break;
                }
            }
            if( dwFlags &amp; INSERT_REPLACE_EXISTING )
            {
                isNew = FALSE;
                break;
            }
            else
            {
                return FALSE;
            }
        }  
        nHashPos = (nHashPos + 1) % m_hashTableLength;   
        if(nHashPos == nHashStart)    
        {   
            return FALSE;    
        }   
        x=m_pHashIndexTable[nHashPos].dwFlag &amp; FILE_EXISTS;
        y = m_pHashIndexTable[nHashPos].dwFlag &amp; FILE_DELETED;
    }   
    m_pHashIndexTable[nHashPos].dwFlag = FILE_EXISTS;  
    m_pHashIndexTable[nHashPos].dwHashValueA = nHashA;   
    m_pHashIndexTable[nHashPos].dwHashValueB = nHashB;   
    m_pHashIndexTable[nHashPos].iBlockIndex=nHashPos;
    if( dwFlags &amp; INSERT_CHECK_FILETIME )
    {
        m_pHashIndexTable[nHashPos].dwFileLastModiTime.dwHighDateTime = FileTime.dwHighDateTime;
        m_pHashIndexTable[nHashPos].dwFileLastModiTime.dwLowDateTime = FileTime.dwLowDateTime;
    }
    HashPos = nHashPos;
    return TRUE;  
}
</code></pre>

<p>3.1.3     插入BlockTable</p>

<p>如果DebrisBlock（空闲表）为空，则将BlockTable中的文件偏移量指向文件最后。</p>

<p>如果DebrisBlock不为空，则将BlockTable中的文件偏移量指向BlockTable头结点，DebrisBlock头结点出列。</p>

<p>3.2          查找</p>

<p>3.2.1     查找HashTable</p>

<pre><code>LONG HashManager::GetHashTablePos( TCHAR *lpszString )
{
    const DWORD HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;   
    DWORD nHash = HashString(lpszString, HASH_OFFSET);   
    DWORD nHashA = HashString(lpszString, HASH_A);   
    DWORD nHashB = HashString(lpszString, HASH_B);   
    DWORD nHashStart = nHash % m_hashTableLength;   
    DWORD nHashPos = nHashStart; 

    DWORD x=m_pHashIndexTable[nHashPos].dwFlag &amp; FILE_EXISTS;
    while( x != 0 )
    {    
        if(m_pHashIndexTable[nHashPos].dwHashValueA == nHashA               &amp;&amp; m_pHashIndexTable[nHashPos].dwHashValueB == nHashB)
        {
            return nHashPos;  
        }      
        else
        {
            nHashPos = (nHashPos + 1) % m_hashTableLength; 
        }  
        if(nHashPos == nHashStart)    
             break;    
        x=m_pHashIndexTable[nHashPos].dwFlag &amp; FILE_EXISTS;
    }
    return -1; //没有找到
}
</code></pre>

<p>3.3          删除</p>

<p>3.3.1    查找HashTable ：GetHashTablePos；</p>

<p>3.3.2    查找到则DebrisBlock入列文件偏移量，</p>

<p>3.3.3    在HashTable中Flag标记位FILE_DELETED</p>

<p>3.3.4    备注：这里不是真正删除。真正删除在MPFileClose()中的ManagerFileDebris进行。</p>

<pre><code>BOOL    MiniPic::DeleteData(TCHAR *lpszString)
{
    ASSERT(m_isInit);
    ASSERT( m_pHashManager != NULL );
    ASSERT( lpszString != NULL );
    LONG hashTablePos;
    hashTablePos = m_pHashManager-&gt;GetHashTablePos(lpszString);
    if( hashTablePos == -1 )
    {
        return FALSE;
    }
    MINIPICDEBRIS debris;
    debris.dwBlockTableIndex = hashTablePos;
    debris.dwDebrisStartAt = m_pBlockTableManager-&gt;GetBlockTable()[hashTablePos].FileStartAt;
    m_pHashManager-&gt;DeleteHashTable(hashTablePos);
    m_debrisBlock.push_back(debris);
    DebugPrintString(L"Free data the pos is %d\n",hashTablePos);
#ifdef TEST
    if(count1&gt;=testNum)
    {
        count1=0;
    }
    testIns[count1++]=hashTablePos;
#endif
    m_fileHeader.childFileCount--;
    return TRUE;
}
</code></pre>

<p>3.4           回收资源</p>

<p>因为在删除的时候只是在hashTable中做了一个Deleted的标记，并没有真正删除文件。若是长时间使用，则会浪费很多空间。此时需要整理。</p>

<p>收集空闲区域。排序，将文件尾部数据移动至最早空闲处，删除空闲处，更新hashTable。</p>

<pre><code>BOOL MiniPic::ManagerFileDebris( LPVOID lpBuffer, const UINT count )
{
    ASSERT( lpBuffer != NULL );
    ASSERT( m_MPFile != NULL );
    if( m_debrisBlock.empty() )
    {
        return TRUE;
    }
    MINIPICDATAITEMHEADER dataItemHeader;
    m_debrisBlock.sort();

    /*
首先将比较Debris block末尾，若是处在文件的最后，则将Debris block末尾数据出列。并向前移动fileEndPointer     保证Debris block要小于文件末尾。
确认Debris block是否为空。
将末尾文件数据移动到Debris block的首部位置，fileEndPointer--，并将Debris block首部数据出列。
    在判断条件1，2*/
    //查找Debris。
    while( !m_debrisBlock.empty() )
   {
        while( m_debrisBlock.back().dwDebrisStartAt + count                   + sizeof(MINIPICDATAITEMHEADER) == m_fileDataEndPointer )//处理文件末尾的空闲区域
         {
            m_fileDataEndPointer -= count + sizeof(MINIPICDATAITEMHEADER);
            m_pHashManager-&gt;ClearHashTable( m_debrisBlock.back().dwBlockTableIndex );//New add
            m_debrisBlock.pop_back();
            if( m_debrisBlock.empty() )
            {
                break;
            }
        }
        if( !m_debrisBlock.empty() )
        {
            if( 0xFFFFFFFF == m_MPFile-&gt;Seek( m_fileDataEndPointer - count - sizeof(MINIPICDATAITEMHEADER), 
                FILE_BEGIN ))//指向最后文件块开始处
              {
                return FALSE;
            }
            m_MPFile-&gt;Read( &amp;dataItemHeader, sizeof(MINIPICDATAITEMHEADER) );
            m_MPFile-&gt;Read( lpBuffer, count );
            if( 0xFFFFFFFF == m_MPFile-&gt;Seek( m_debrisBlock.front().dwDebrisStartAt, FILE_BEGIN ) )
            {
                return FALSE;
            }
            m_MPFile-&gt;Write( &amp;dataItemHeader, sizeof(MINIPICDATAITEMHEADER) );
            m_MPFile-&gt;Write( lpBuffer, count );
            m_fileDataEndPointer -= count+sizeof(MINIPICDATAITEMHEADER);
            m_pBlockTableManager-&gt;SetBlockTableFileStartAt( dataItemHeader.dwBlockTableIndex,
            m_debrisBlock.front().dwDebrisStartAt );
            //将原来指向空此间的HashTable标记位空。
              m_pHashManager-&gt;ClearHashTable( m_debrisBlock.front().dwBlockTableIndex );
            m_debrisBlock.pop_front();
            DebugPrintString(L"find freedata set in it ,and the pos is %d\n",dataItemHeader.dwBlockTableIndex);
        }
    }
    m_fileHeader.bfSize = m_fileDataEndPointer;
    return TRUE;
}
</code></pre>

<h2>第三部分 使用</h2>

<pre><code>BOOL      MPFileOpen( LPCTSTR lpFileName );

void          MPFileClose();                            

BOOL      MPFileAddFile( LPCVOID lpBuffer, TCHAR *lpszString, const DWORD fileSize,

                 const FILETIME LastModiTime, LONG &amp;lIndex, DWORD dwFlags

);

BOOL       MPFileReadFile( LPVOID lpBuffer, TCHAR *lpszString );

BOOL       MPFileDeleteFile(TCHAR *lpszString);

void           MPFileFlushData();

BOOL       MPFileReadFileByIndex( LPVOID lpBuffer, const DWORD index );

BOOL       MPFileGetFileName( TCHAR *FileNameBuffer, const  size_t count,

                                                        const DWORD index

);

BOOL        MPFileReName( LPCTSTR lpNewFileName, LPCTSTR lpOldFileName);
</code></pre>

<h2>第四部分 未解决问题</h2>

<p>没有实现动态增长，处理文件的最大值有限。
没有对文件正确性做足够保证。没有加入CRC or MD5校验。
没有设定返回的错误码只有TRUE,FALSE，不利于识别错误问题。
算法的有些地方效率不高。还需改进。
数据的大小没有做限制，插入过多数据会溢出。</p>

<h2>第五部分 疑问</h2>

<p>在处理非常多的数据时，是否该将文件压缩？
许多管理文件系统都加入了最近访问文件列表，这些在有大量文件读入时效率高，是否可以设计类似结构？
如何处理异常，特别是在写入时产生的异常，导致文件写入错误。如何能够更好的解决类似问题？在发生异常的时候，如何能够做到高效的完全释放资源？
把HashTable，BlockTable放置到文件末尾，方便文件以后动态扩展。但是具体的如何扩容hashTable，可能不好办。
在文件头部分增加一个Flag，标示文件的状态。（在读入的时候标记位0，最后如果没有异常则标记位1，那么如果在这个文件出现了问题，那么就可以通过检测这个Flag来判断文件异常），若是设计的更好，可以通过这个检测那部分有问题，而对问题修正。
我之前谈到的异常情况，导致有的文件没有即时更新。我的想法是来自IE浏览器，他会记录上次出错的位置，那么这时候就可以启动恢复程序。要是MP文件的Flag是正常，那么就说明问题不在MP文件处理，可能是别的地方异常导致结束，那么就可以重新查找，根据文件创建的时间来判断是否文件变化过，那么这样就比重新生成要快多了。我这里应该提供用来恢复的接口，这个由外部程序调用它。
第六部分 写给自己</p>

<p>如果仔细看的话，这个并不是很复杂的东西，只是实现了最基本最简单的内容，但是自己做的依然很不完整。问题依然很多。这也映射出自己学习不仔细，编程依然马虎。很多问题都想的不周全。这也进一步说明自己基础不扎实。</p>

<p>我相信我这里肯定还有不少问题，希望大家有时间给小弟看看，与此同时我也会不断改进，把这个做到自己的极限。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/01/10/wpf-sample-game/">WPF设计简单游戏初探</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-01-10T18:23:00+08:00" pubdate data-updated="true">Jan 10<span>th</span>, 2010</time>
        

        
      | <a href="/blog/2010/01/10/wpf-sample-game/#comments">Comments</a>
        

      </p>
    
  </header>


  <div class="entry-content"><p>自从看了深蓝大哥的博客之后感触很多，于是花了一个多月学习WPF并模仿深蓝大哥的设计，并使用了一部分深蓝大哥的控件和代码，再加上_goods大哥对小弟的提示与帮助。做成了这个十分简陋的“迷你弹弹堂”，由于种种原因，仅仅实现了最基本的功能，即实现了模拟弹坑，和在弹坑中移动。由于小弟没有在公司做过项目，遇到代码难看的地方或是我理解不到位的地方请大家不要一笑而过，给小弟提出来，万分感谢。</p>

<p>【实验名称】
迷你弹弹堂</p>

<p>【实验目的】
通过对迷你弹弹堂的编写，深入了解面向对象的程序的思想，熟悉WPF事件驱动，动画以及多媒体应用，了解XAML， 逐步了解多线程编程，了解windows 新的图形系统。</p>

<p>【掌握内容】
了解位图文件在系统中的保存方法和处理方法，熟悉根据图形点阵图对图形以像素单位修改，逐步了解WPF中UI线程控制，了解BackgroundWorker应用。
通过实际编码，逐步了解游戏编程中精灵对象的设计以及使用，逐步了解网页游戏地图设计，熟练掌握基本美工技巧。</p>

<p>【问题描述及基本要求】
本程序为一个弹弹堂单机版，可自由设定玩家人数（不要太多，影响速度），
玩家控制和网络上的弹弹堂一样，通过space控制发射，上下左右控制移动。
由于时间原因，并没有增加武器，头像，道具等工具，也没有加入风向的影响。
【游戏设计】</p>

<p>游戏地图部分设计
游戏地图包括3部分，游戏的背景，游戏的障碍物遮罩层，游戏地图副本。
游戏背景：为一个简单的图片。没有过多的说法。
游戏的障碍物：大小与游戏背景大小一致，并根据图片byte流，将不遮挡部分的图片像素alpha设为0，但是由于对WPF图形渲染的过程没有非常清楚的了解，要想保证完全透明，必须将对应像素值的RGB一次同A一样设为0。（这里很不明白，希望大家能给点提示）。
游戏地图副本：大小同游戏背景大小一致，并结合背景，主角，遮罩层等等设计，通过不同的颜色来区分不同的对象，游戏运行期间的数据处理都依赖于游戏地图副本的计算。
游戏精灵设计
游戏精灵包括了游戏主角，游戏中的子弹。
游戏精灵：由一个DispatcherTimer为核心的有许多属性封装成的类，
DispatcherTimer被称为生命线程，用来控制该类对象的状态和在UI线程刷新的优先级。</p>

<p>【关键算法描述】
游戏主角移动：在整个游戏地图副本中取出主角的碰撞体积大小的byte流，并保存在数组中，通过对数组遍历，根据游戏地图副本颜色的不同而区分出游戏主角的行进路线及状态。
游戏弹坑实现：通过子弹精灵中取得的子弹弹坑的形状，将游戏地图副本中找到弹坑的位置并根据弹坑颜色更新游戏地图副本，同时并将修改反应到游戏遮罩层中，使遮罩层和游戏副本地图保持一致。
将大量的运算放在UI线程则会阻塞UI线程，故通过合理的应用后台工作者（BackgroundWorker）可以将复杂的运算放在后台，在后台线程中则每隔一段时间调用Dispatcher.BeginInvoke来异步调用更新UI线程的控件。（这里是整个程序运行效率的关键，1、不能一直占用cpu去调用，也就是必须对调用时间或间隔或优先级进行约定，2、beginInvoke虽然能异步执行，但是修改不能过大，一次性的赋值时间过长也会将UI线程阻塞，也就是说遇到大的数据量需要分时间段执行等，好在现在的v1.0版本没有非常多的魔法效果，爆炸效果，飞行效果，人物的头像，衣服等等，数据量很小，所以好坏这里并不明显）。</p>

<p>【调试结果及说明】
由于采用了vs2008 sp1补丁和.net3.5 sp1补丁，所以没打补丁的不能对程序编译，程序也不能运行，又由于游戏中有声音，而我没有使用win32的声音函数，wpf的声音播放是基于Media Player 10的，所以若是没有Media Player10以上版本则没有声音，但不影响程序中其他部分正常运行。（这里提供的链接没有声音）</p>

<p>【结论及问题讨论】
通过编写此程序，发现了很多问题，也知道了自己的不足，缺乏对.Net的设计架构的理解，而且缺乏对CLR的清楚理解，归根到底还是特别缺乏对.Net的基础认识，特别是对IL认知的缺乏，使自己无法真正了解整个.Net的程序的真实运行情况。所编的程序对GC的压力较大。从实际出发则是长时间运行下，急剧增长的内存（主要是在不断的new，再null），如果不加处理内存会直线上升比原来增大数倍，虽然MS说全交给GC处理，但是如果程序员不行，程序也不可能实用化，只能是个花瓶。</p>

<p>虽然程序现在的设计为将来如果增加武器系统，人物属性系统，伤害系统，道具系统，魔法特效装饰系统预留了扩展空间，但是当真正的程序计算量翻翻后这种设计是否能经得主考验我也说不清楚。</p>

<p>这里有个技术问题没有想明白希望能得到大家的帮助：</p>

<p>在WPF下怎么通过透明图片来初始化WB，SL中可以使用writeablebitmap.SetSource，那么WPF中应该是什么呢？ 我这里是用的很笨的方法BitmapFrame.Create(&#8230;).CopyPixels得到一个数组，但是奇怪的是图片中原来透明的部分就变成白色了。</p>

<p>最后还是那句话，遇到代码难看的地方或是我理解不到位的地方请大家不要一笑而过，给小弟提出来，万分感谢。</p>

<p><a href="http://files.cnblogs.com/studentdeng/MyWorm4_2.rar">源代码</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/ios/'>IOS (1)</a></li>
<li class='category'><a href='/blog/categories/objective-c/'>Objective-C (1)</a></li>
<li class='category'><a href='/blog/categories/wpf-sl/'>WPF/SL (1)</a></li>
<li class='category'><a href='/blog/categories/algorithms/'>algorithms (1)</a></li>
<li class='category'><a href='/blog/categories/algorithms-/'>algorithms, (1)</a></li>
<li class='category'><a href='/blog/categories/asm/'>asm (1)</a></li>
<li class='category'><a href='/blog/categories/c-/'>c++ (3)</a></li>
<li class='category'><a href='/blog/categories/c-/'>c++] (1)</a></li>
<li class='category'><a href='/blog/categories/configure/'>configure (1)</a></li>
<li class='category'><a href='/blog/categories/mobile-/'>mobile, (1)</a></li>
<li class='category'><a href='/blog/categories/psychology/'>psychology (1)</a></li>
<li class='category'><a href='/blog/categories/tips/'>tips (1)</a></li>
<li class='category'><a href='/blog/categories/windows/'>windows (3)</a></li>
<li class='category'><a href='/blog/categories/windows-mobile/'>windows mobile (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/03/03/arc/">ARC 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/26/tips/">tips</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/15/happiness/">哈佛幸福课 杂感一</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/05/22/asm-win32/">Win32汇编学习（1）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/04/24/mult-threading2/">多线程程序设计笔记二</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/04/16/mult-threading/">多线程程序设计笔记一</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/04/06/thumb-pic2/">缩略图设计初探二</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/03/24/thumb-pic1/">缩略图设计初探</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/01/10/wpf-sample-game/">WPF设计简单游戏初探</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/studentdeng">@studentdeng</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'studentdeng',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





<section>
<h1>Recent Comments</h1>
<ul class="ds-recent-comments" data-num-items="10" data-show-avatars="0" data-show-time="0" data-show-title="0" data-show-admin="0" data-excerpt-length="18"></ul>

<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
  var duoshuoQuery = {short_name:"studentdeng"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->

</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
