
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不会开机的男孩</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="了解一个算法最好的方法就是实现它，不过在开始实现算法之前，有一些额外的概念需要理解。 Vectorization 这是上一篇提到的hypothesis的计算公式。 当计算这个表达式值的时候，往往第一个感觉是写一个for loop 然后累加求和 prediction = 0;
for (int i &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="不会开机的男孩" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/jquery.min1.9.1.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">不会开机的男孩</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  	<li><a href="/">Blog</a></li>
  	<li><a href="/blog/archives">Archives</a></li>
	 <li><a href="/tags/index.html">Tags</a></li>
	<li><a href="/favorite/index.html">Favorite</a></li>
	<li><a href="/about/index.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/24/machine-learning-2/">机器学习(二) 线性回归、梯度下降实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-24T20:52:00+08:00" pubdate data-updated="true">Aug 24<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/24/machine-learning-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>了解一个算法最好的方法就是实现它，不过在开始实现算法之前，有一些额外的概念需要理解。</p>

<h1>Vectorization</h1>

<p>这是<a href="http://studentdeng.github.io/blog/2014/07/28/machine-learning-tutorial/">上一篇</a>提到的hypothesis的计算公式。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_1.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>当计算这个表达式值的时候，往往第一个感觉是写一个for loop 然后累加求和</p>

<pre><code>prediction = 0;
for (int i = 0; i &lt; n; ++i) {
    prediction += theta[j] * x[j];
}
</code></pre>

<p>但是在machine learning中更倾向于使用矩阵的方式。
比如同样的公式，会看成矩阵相乘。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_3.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>其中theta和X分别是</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_2.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这里通过矩阵或是向量来代替之前的loop。</p>

<p>这是<a href="http://studentdeng.github.io/blog/2014/07/28/machine-learning-tutorial/">上一篇</a>提到的算法</p>

<p><img src="http://studentdeng.github.io/images/ml/4.png" alt="image" /></p>

<p>计算function J如果用octave来实现则是这个样子</p>

<pre><code>function J = computeCost(X, y, theta)
%COMPUTECOST Compute cost for linear regression
%   J = COMPUTECOST(X, y, theta) computes the cost of using theta as the
%   parameter for linear regression to fit the data points in X and y

% Initialize some useful values
m = length(y); % number of training examples

% You need to return the following variables correctly 
J = 0;

% ====================== YOUR CODE HERE ======================
% Instructions: Compute the cost of a particular choice of theta
%               You should set J to the cost.


t = (X * theta) - y;
J = (sum(t .* t)) / (2 * m);

% =========================================================================

end
</code></pre>

<p><img src="http://studentdeng.github.io/images/ml/19.png" alt="image" /></p>

<p>而求偏导数迭代更新theta的代码则是这个样子</p>

<pre><code>function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)
%GRADIENTDESCENT Performs gradient descent to learn theta
%   theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by 
%   taking num_iters gradient steps with learning rate alpha

% Initialize some useful values
m = length(y); % number of training examples
J_history = zeros(num_iters, 1);

for iter = 1:num_iters

    % ====================== YOUR CODE HERE ======================
    % Instructions: Perform a single gradient step on the parameter vector
    %               theta. 
    %
    % Hint: While debugging, it can be useful to print out the values
    %       of the cost function (computeCost) and gradient here.
    %


    s = sum(bsxfun(@times, X * theta - y, X));
    theta = theta - (alpha / m) * s';

    % ============================================================

    % Save the cost J in every iteration    
    J_history(iter) = computeCost(X, y, theta);

end
</code></pre>

<p>上面的2部分代码如果做一些合并分别可以简化成1行代码。说到这里自己还是相当羞愧的。今天早上花了3个小时才搞定这2行代码&#8230;主要时间花在了
2个地方。</p>

<ol>
<li>算好theta去predict的上面，和normal equations的方式计算的答案总是对不上，不得不怀疑人生了。。。后面才发现是因为函数没有完全收敛，在调整learning rate之后误差明显变小了。</li>
<li>让大脑适应矩阵还是有点难，很多东西看上去很简单，反应很长时间，不过后面会好一些。</li>
</ol>


<h1>为什么用矩阵</h1>

<p>在费了老半天力气搞定Vectorization的转变之后，不得不想想为什么要用这个方式做。obviously有2个好处，Andrew课上也提到了好多次。</p>

<ol>
<li>增加一个feature很简单，只要把输入增加一列就好，而算法不需要改动。</li>
<li>矩阵的运算更容易优化，性能比循环更快。实际我们往往处理上百万个Example和N多的features</li>
</ol>


<p>第一个很好理解，而且把循环的一大堆代码写成一行，显得逼格很高。
第二个会比较麻烦，涉及到了并行计算优化。</p>

<h1>其他</h1>

<p>在之前的算法中，我们看到了每一次调整theta都需要iterate整个所有的example，但实际中往往需要处理上百万个examples，而这样的iteration显然是不能接受的。实际上会随机选取一部分examples然后去迭代theta，最后得到一个较为可靠的theta向量。</p>

<p>最后附上Andrew作业的图片，虽然Andrew 不希望把答案放在网上或是论坛什么的，不过我觉得都过去2年多了,应该没关系了。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_4.png' width='' height='' title='最后的预测效果图'><span class='caption-text'>最后的预测效果图</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_5.png' width='' height='' title='cost function & theta'><span class='caption-text'>cost function &amp; theta</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_6.png' width='' height='' title='cost function & theta 等高线'><span class='caption-text'>cost function &amp; theta 等高线</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml2_7.png' width='' height='' title='learning rate'><span class='caption-text'>learning rate</span></span></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/16/qinshihuang/">《中国古代历史与人物——秦始皇》笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-16T10:17:00+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/16/qinshihuang/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在coursera学完了台湾国立大学的公开课——<a href="https://class.coursera.org/chinesehistory-002">《中国古代历史与人物——秦始皇》</a>。虽然自己看过不少课程，看过不少历史书，但是这门课程对我的影响超过了任何一本文史书。我自己完整的看过3遍，并做了作业(可惜没有认真做好)。这门课从某种角度来看，彻底改变了我对文史课程的认知，对自己之前的无知和误解感到深深的愧疚，并再次讥讽一下国内的文史课程。下面是自己整理的东东，方便自己日后review。</p>

<ul>
<li> 读历史需要思辨</li>
<li> 每一个决定的结果是否成功是通过时间衡量的，做决定的关键是在于是否得到了自己想要的结果。得到就要付出，除非有其他人替自己付出</li>
<li> 社会就是需要和有用，说服别人是因为知道别人需要什么</li>
<li> 人和人的差别不在于遇到的问题，而是面对问题时的态度</li>
<li> 看书要学会“沙金”，从沙子里面掏出金子，而不是一味的埋怨，批判。任何事情都有值得自己学习的东西。放下自己的成见，很多事情没有自己想象的那么简单。</li>
</ul>


<h3>2-5</h3>

<p>秦国百战百胜，不在于它真能变法，而在于列国不能真正变法
历史说明了一个道理，不能适应时代的，只有被淘汰消失</p>

<h3>2-6</h3>

<p>历史上的所谓的成功和失败，就看你站在什么位置，用什么尺度来衡量。而判断成功和失败的标准，最后还是问自己</p>

<h3>3-4</h3>

<p>想要成功，就要懂得把理智放在感情之上。</p>

<p>谋事在人这是真得有用，有人用很多的时间去提高效率，但是节约的时间，并没有被真正利用起来。那么这个办法也很一般。
自己需要自己不断的努力，才能让之前的办法真正变成好办法。。。</p>

<p>方法和人关系太大了</p>

<p>这个社会不外乎需要和有用。</p>

<p>你需要知道别人需要什么，你才能变得有用</p>

<h3>5-3</h3>

<p>富家子弟处逆境难
穷家子弟处顺境难</p>

<h3>6-1</h3>

<p>人生总会有赌博的时候，对错往往是命运差别巨大。
百折不挠的民族</p>

<p>人生：运气 ，自我要求。好好准备，让自己成为那样的条件。等待机会。</p>

<p>理想是，你知道你下一步应该做什么
妄想是，你只有目标却不知道从何做起</p>

<p>自强的第一步，不自欺</p>

<h3>6-8</h3>

<p>在中国文化中，最高的道德和最高的智慧必然是合一的</p>

<h3>7-3</h3>

<p>学会认错，改过。</p>

<h3>8-1</h3>

<p>改变环境，需要改变自己，让自己适应那个自己想要的环境的要求。
如何改变，通过学习</p>

<h3>9-1</h3>

<p>做事之前，为虑胜，先虑败，方能考虑周全</p>

<h3>9-9</h3>

<p>历史启发智慧，所有的学问都能带来智慧</p>

<p>审时度势：</p>

<p>时：你所处的环境。
势：环境变动的方向</p>

<p>变的是时间和环境。
不变的是人性和良知</p>

<p>不仅仅是自己改变，需要改变周围的人。</p>

<p>历史用真，去伪。。。
改动人心</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/28/machine-learning-tutorial/">机器学习(一) 简单的背景介绍、线性回归、梯度下降</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-28T16:48:00+08:00" pubdate data-updated="true">Jul 28<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/07/28/machine-learning-tutorial/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Introduction</h1>

<p>机器学习很久之前就已经热得不行了，直到最近这几个星期，自己才打算了解一些这方面的东西。原因大概有这么3点。</p>

<ol>
<li>自从Andrew Ng 加入我厂之后(虽然和我毛关系也没有)，总觉得还是需要围观一下这个令他兴奋的领域。</li>
<li>在听了IDL的有关手环算法分享后(其实毛也没有听懂), 在知道了一大堆的名词如最小二乘、梯度下降、SVM。以及里面很多的线性代数，微积分的概念，让我觉得这是一个很好的回收自己大学时期的沉默成本(微积分、现代是我在学校里面不多的用心学过的课程)的好机会。总之就是对这些很感兴趣。</li>
<li>前一段时间受组里高工分享睡眠算法影响，对这种阅读paper，然后优化算法的过程感到很开心。</li>
</ol>


<p>有了这3条，足够我忙活好几个月了 : )</p>

<h1>Background</h1>

<p>在机器学习中，有2个很大的思路<code>监督学习(supervised learning)</code>和<code>非监督学习(unsupervised learning)</code></p>

<p>监督学习，用通俗的话来说就是<code>你知道问题的答案，需要计算机给出一个更标准的答案</code>。</p>

<p>非监督学习，用通俗的话来说就是<code>物以类聚，人以群分</code>。我们拿到了很多数据，但是不知道问题的答案，希望计算机给我们提供思路。</p>

<p>在生产环境中，往往采用混合模式。比如图片搜索，如何能够查找网页中判断那个图片是老虎，那个是狗。就有2个思路。</p>

<ol>
<li>根据图片周围的文字。</li>
<li>图片的图像数据分析。</li>
</ol>


<p>2个角度相互校验，稳定之后，就可以产生足够的标注信息了。</p>

<h1>线性回归(Linear regression)</h1>

<p>线性回归主要用于手环的里程部分的计算，涉及到更细节的是 最小二乘，梯度下降。这里从先从最简单的一元线性回归开始。</p>

<h2>一元线性回归(Linear regression with one variable)</h2>

<p>Regression Problem : Predict real-valued output</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/8.png' width='' height='' title='1-1 算法运行的过程'><span class='caption-text'>1-1 算法运行的过程</span></span></p>

<p>最关键的在于如何描述hypothesis。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/1.png' width='' height='' title='1-2 一元线性回归中的hypothesis函数'><span class='caption-text'>1-2 一元线性回归中的hypothesis函数</span></span></p>

<p>那么应该如何选取参数呢？直觉告诉我们这个直线需要尽可能的拟合我们的数据集。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/9.png' width='' height='' title='1-3 线性回归的目标函数'><span class='caption-text'>1-3 线性回归的目标函数</span></span></p>

<p>通过下面的cost function 来评估参数的好坏。算法的目标也很清晰，让函数越小越好。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/12.png' width='' height='' title='1-4 cost function'><span class='caption-text'>1-4 cost function</span></span></p>

<p>那个这个cost function 到底是个什么样子呢？</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/2.png' width='' height='' title='1-5 图形化的cost function'><span class='caption-text'>1-5 图形化的cost function</span></span></p>

<p>当然这个图还是看起来比较麻烦，Andrew 用了更为简单绘制的图来表示（有点类似等高线）。
相同的圆圈上，有着相同的cost function value。这里可以看到和上面的图一样，有一个极值。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/7.png' width='' height='' title='1-6 一个比较差的选择'><span class='caption-text'>1-6 一个比较差的选择</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/18.png' width='' height='' title='1-7 一个很接近极值的选择'><span class='caption-text'>1-7 一个很接近极值的选择</span></span></p>

<h1>梯度下降 (Gradient descent)</h1>

<p>梯度下降，不仅仅是用于线性回归，也可以用在其他机器学习的场景下。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/3.png' width='' height='' title='1-8 梯度下降的思路（2个参数的情况）'><span class='caption-text'>1-8 梯度下降的思路（2个参数的情况）</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/10.png' width='' height='' title='1-9 梯度下降函数图形（2个参数的情况）'><span class='caption-text'>1-9 梯度下降函数图形（2个参数的情况）</span></span></p>

<p>我们的目标是寻找这个图形中的最小值，也就是靠近蓝色的地方。直觉告诉我们，我们先随机一个点，然后沿着最大的坡度向下走最后就可以走到一个极值里。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/16.png' width='' height='' title='1-10 一条算法路径，全局最优'><span class='caption-text'>1-10 一条算法路径，全局最优</span></span></p>

<p>这个算法也有问题，随着第一个点的位置不同，我们可能找到一个局部最优的解，而不是全局最优。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/14.png' width='' height='' title='1-11 另一条算法路径，局部最优'><span class='caption-text'>1-11 另一条算法路径，局部最优</span></span></p>

<p>好在在很多实际问题中，我们遇到的情况要好很多，往往<strong>只有一个极值</strong>。</p>

<p>那么梯度下降的算法就可以简单的描述出来，分别计算2个维度的偏导数，直到函数收敛</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/5.png' width='' height='' title='1-12'><span class='caption-text'>1-12</span></span></p>

<p>通过分别计算偏导数,a 为learning rate，决定每一步的步长，太小函数收敛很慢，太大则可能无法找到极值，甚至函数无法收敛。</p>

<p>这里Andrew 着重指出了一个叫做同步更新的概念</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/11.png' width='' height='' title='1-13'><span class='caption-text'>1-13</span></span></p>

<p>如果不同步更新，最后也可以得到极致，但是Andrew 更推荐计算完成所有的参数之后，再一起同步更新。</p>

<h2>梯度下降和一元线性回归</h2>

<p>将图1-4分别偏导后</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/15.png' width='' height='' title='1-14 算法公式'><span class='caption-text'>1-14 算法公式</span></span></p>

<h2>其他</h2>

<ol>
<li>根据上面的算法，如果我们的cost function 在一些地方不可导，那算法不就没法继续了？</li>
<li>有其他的方法，可以不去循环计算而是直接根据工具计算</li>
</ol>


<h2>梯度下降和一般化的线性回归</h2>

<p>很多时候我们不仅仅满足2个参数，决定事情的因素很多，我们需要更一般化的公式。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/4.png' width='' height='' title='1-15'><span class='caption-text'>1-15</span></span></p>

<p>算法</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/19.png' width='' height='' title='1-16'><span class='caption-text'>1-16</span></span></p>

<p>分别求偏导后</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/17.png' width='' height='' title='1-17'><span class='caption-text'>1-17</span></span></p>

<h1>梯度下降生产环境中的一些技巧</h1>

<h2>Feature Scaling</h2>

<p>思路: 希望所有的feature在相同或是类似的范围之内，这样梯度下降会更快收敛。</p>

<p>下图是feature的范围不在一起的运算过程，可以看出来不是圆形，2个维度调整的步长不一样，导致很多反复</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/21.png' width='' height='' title='1-18 红色箭头表示算法的一次迭代'><span class='caption-text'>1-18 红色箭头表示算法的一次迭代</span></span></p>

<p>下图则是调整过的feature，好了很多</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/23.png' width='' height='' title='1-19 红色箭头表示算法的一次迭代'><span class='caption-text'>1-19 红色箭头表示算法的一次迭代</span></span></p>

<p>更一般的，Andrew 推荐每一个feature放在[-1, 1]区间范围内</p>

<h2>Learning Rate</h2>

<p>说到Learning Rate 就不能不提收敛(convergence)。一般应该定义多大的阀值来判断是否收敛呢？</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/6.png' width='' height='' title='1-20 Andrew 并不推荐使用一个阀值来判断是否收敛'><span class='caption-text'>1-20 Andrew 并不推荐使用一个阀值来判断是否收敛</span></span></p>

<p>Andrew 更推荐用图表的形式，因为这个不仅仅可以看到是否马上收敛，而且还能看到算法是否运行正常，是不是一些参数的问题，导致算法无法收敛。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/20.png' width='' height='' title='1-21'><span class='caption-text'>1-21</span></span></p>

<p>下图是2个出了问题的J函数，通常来说是Learning Rate 过大。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/ml/25.png' width='' height='' title='1-22 一些过大的Learning Rate 导致的图形'><span class='caption-text'>1-22 一些过大的Learning Rate 导致的图形</span></span></p>

<p>最后Andrew 还提供了一些practice的Learning Rate 选取方法，比如一些0.001, 0.003, 0.01, 0.03, 0.1, &#8230;</p>

<h2>参考</h2>

<p><a href="https://class.coursera.org/ml-006">Coursera 《Machine Learning》 Stanford Andrew Ng</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/core-animation/">Core Animation基本概念和Additive Animation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T19:21:00+08:00" pubdate data-updated="true">Jun 24<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/06/24/core-animation/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/">上一篇《AutoLayout 相关概念介绍和动画demo》</a>提到了一些Core Aniamtion的基础知识，这篇依然介绍一些基本概念，最后提到一点iOS8的动画改动。</p>

<h1>一些基本概念</h1>

<p>说到Core Animation 不能不说Layer, 一个个Layer通过tree的结构组织起来，在Display的过程中实际上有3种Layer tree。</p>

<ul>
<li>model layer tree</li>
<li>presentation tree</li>
<li>render tree</li>
</ul>


<p><code>model Layer tree</code> 中的Layer是我们通常意义说的Layer。当我们修改layer中的属性时,就会立刻修改model layer tree。</p>

<pre><code>layer.position = CGPointMake(0,0); //这里的修改会直接影响model layer tree
</code></pre>

<p><code>presentation tree</code> 是Layer在屏幕中的真实位置。比如我们创建一个动画</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">5.0f</span>
</span><span class='line'>                   <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                     <span class="n">self</span><span class="p">.</span><span class="n">animationLabel</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">);</span>
</span><span class='line'>                   <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//这里用一个Timer print presentLayer的位置。</span>
</span><span class='line'>  <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">animationLabel</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">presentationLayer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;model:%@, presentLayer%@&quot;</span><span class="p">,</span> <span class="n">NSStringFromCGPoint</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">animationLabel</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span><span class="p">),</span> <span class="n">NSStringFromCGPoint</span><span class="p">(</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是屏幕输出结果</p>

<pre><code>model:{73.5, 155.5}, presentLayer{73.5, 155.5}
model:{200, 400}, presentLayer{73.559769, 155.61552}//开始动画
model:{200, 400}, presentLayer{73.814095, 156.10709}
model:{200, 400}, presentLayer{74.267357, 156.98315}
...
...
...
model:{200, 400}, presentLayer{199.99576, 399.99182}
model:{200, 400}, presentLayer{200, 400}
</code></pre>

<div class='notebox'><p><strong>Note: </strong>render tree 在apple的render server进程中，是真正处理动画的地方。而且线程的优先级也比我们主线程优先级高。所以有时候即使我们的App主线程busy，依然不会影响到手机屏幕的绘制工作。</p></div>


<h1>CADisplayLink</h1>

<p>了解<a href="http://www.cocos2d-x.org/?v=EN">cocos2dx</a>对CADisplayLink一点也不陌生，对APP开发者可能就有一点远，但是facebook的<a href="https://github.com/facebook/pop">Pop</a>一下子拉近了我们和CADisplayLink的距离。通过设置callback函数，当屏幕刷新的时候，就可以执行我们的代码。当然，我们也可以利用NSTimer 或是GCD来实现类似的功能。但是CADisplayLink是最优的，因为不管是哪种类型的Timer，即使我们的刷新间隔和屏幕刷新保持一致。我们都无法知道系统什么时候刷新屏幕。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation1.png' width='' height='' title='1-1 NSTimer中每一帧其实只有8ms的时间，如果大于8ms，那么就会丢帧'><span class='caption-text'>1-1 NSTimer中每一帧其实只有8ms的时间，如果大于8ms，那么就会丢帧</span></span></p>

<p>facebook的<a href="https://github.com/facebook/pop">Pop</a>非常类似UIDynamic，但是我们需要注意一点，相对于传统的model动画来说，CADisplayLink导致部分绘制工作放在了我们APP的地址空间中，也就是说，增大了APP内存，CPU的开销。也更容易遇到性能瓶颈。</p>

<div class='notebox'><p><strong>Note: </strong>model layer的这部分绘制是完全在render server，而render server运行在比APP更高优先级的进程中，而这个也意味着会有进程间通讯的开销。传递的数据包括整个render tree还有动画，所以，Apple 并不推荐我们手动commit transaction, Core Animation 默认会在run loop 中提交transaction。</p></div>


<h1>UIView animation</h1>

<p>Apple 最近在推荐一些Modern APP的设计，其中有一条是希望responsive。比如下面的场景，启动一个动画之后，在动画还没有完成之前取消这个动画。</p>

<p><a href="https://github.com/studentdeng/CoreAnimationAdditiveExample">下图的相关代码</a></p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation1.gif' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这里我们看到了3种情况。</p>

<ul>
<li>红色的2个动画之间有一个很大的跳动。</li>
<li>绿色的比红色的好一点，没有跳动，但是就像撞到了墙一样，完全丧失了一开始动画的速度。</li>
<li>蓝色的的运动更加平滑，有更真实的物理效果。</li>
</ul>


<h2>UIKit创建的动画，系统是如何理解的</h2>

<p>UIKit的动画最后都会通过Core Animation 来实现, 那么当我们修改layer（model layer）的数值时，系统是如何理解并创建动画呢？
比如这里有一个线性的动画，将animationView的坐标从（0，0）移动到（0,500）</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="n">animationView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">1.0f</span>
</span><span class='line'>                        <span class="nl">delay:</span><span class="mi">0</span>
</span><span class='line'>                      <span class="nl">options:</span><span class="n">UIViewAnimationOptionCurveLinear</span>
</span><span class='line'>                   <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                     <span class="n">animationView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
</span><span class='line'>                   <span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>下面是当我们创建一个UIKit的动画时发生的事情</h3>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation9.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<ul>
<li>Model：在<code>animationView.center = CGPointMake(0, 500);</code>之后会立刻修改<code>animationView</code>的model Layer中的<code>position</code>的值为（0， 500）。</li>
<li>Animation：系统的理解就是从原来的model layer的值(0,0)到新的model layer的值(0, 500)创建一个动画。</li>
<li>Presentation： Presentation就像上面提到的，是表示<code>animationView</code>当前在屏幕的真实位置(渲染位置)，因为还没有&#8221;动&#8221;起来，所以还是(0,0)</li>
</ul>


<div class='notebox'><p><strong>Note: </strong>Animation的部分如果没有明白，可以结合后面的回头再看</p></div>


<h3>当我们看到屏幕上面的View移动的时候，发生了下面的事情</h3>

<p>这是在0.4s时刻之前的状态。Model Layer的数值没有变化，而Presentation则在变化，和真正的屏幕动画保持一致。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation10.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<h3>在一个animation并没有完成的情况下，再创建一个动画系统是如何理解的呢？</h3>

<p>如果我们在<strong>0.5时刻</strong>创建一个reverse动画，<code>animationView.center = CGPointMake(0, 0);</code></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">1.0f</span>
</span><span class='line'>                        <span class="nl">delay:</span><span class="mi">0</span>
</span><span class='line'>                      <span class="nl">options:</span><span class="n">UIViewAnimationOptionCurveLinear</span>
</span><span class='line'>                   <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                     <span class="n">animationView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>                   <span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation5.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<ul>
<li>Model：的数值会被立刻修改成目标数值(0, 0)</li>
<li>Animation： 系统的理解是从原来的(0, 500)，创建一个去(0,0)的动画</li>
<li>Presentation: 基于系统的理解，Presentation layer的数值变成了(0, 500)。1秒中的时间内递减到(0, 0)</li>
</ul>


<p>到目前为止，我们可以清楚的理解为什么红色的view会有一个大的跳跃，在我们这里的理解就是presentation layer的一个不连续的修改。</p>

<h2>绿色的动画效果原因</h2>

<p>在上面的基础之前，绿色的就可以简单说一些</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation6.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<ul>
<li>Model 这里还是和之前一样，表示目标值</li>
<li>Animation：系统的理解是从当前的动画位置开始，也就是 (0, 150)开始创建一个1秒的动画到(0,0)</li>
<li>Presentation 和我们的预期一样。</li>
</ul>


<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation2.png' width='' height='' title='linear animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage'><span class='caption-text'>linear animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage</span></span>
<span class='caption-wrapper'><img class='caption' src='/images/core_animation3.png' width='' height='' title='EseInOut animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage'><span class='caption-text'>EseInOut animation 图中的颜色和本文的颜色无关，只是表示2个动画的stage</span></span></p>

<p>可以看出来2个动画相接的曲线不平滑，而造成这个不平滑的原因在于把之前的动画覆盖了, 丢掉了之前动画的速度，如果要实现一个更一般化的解决方案，我们很自然的想到了动画合成。</p>

<h2>蓝色的动画原因</h2>

<p>蓝色的动画比较复杂，使用了Core Animation中的additive属性，动画被设置成相对的，那么就和动画具体的位置无关。最后还合成了2个动画。</p>

<p>首先，解释一下什么是相对的动画。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation7.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>这里很容易看到，view的真实位置是Animation 的值 + Model的值。系统的理解就是相对目标值(0, 500)来说，创建一个从-500 到 0 的动画。</p>

<p>其次，相比之前的动画，在0.6时刻（为了方便计算，把之前的0.5时刻移动到了0.6时刻）并没有删除掉之前的动画，而是添加了一个新的动画Animation2。也就是一个相对目标值(0,0)来说，创建一个从500到0的动画。整个运动变成了2个动画的合成。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation8.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<div class='notebox'><p><strong>Note: </strong>Animation2的duration修改了，在demo code里面并没有修改 ：）</p></div>


<p>这里，我们就得到了一个一般化的解决方案。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/core_animation4.png' width='' height='' title='图中的颜色和本文的颜色无关，只是表示2个动画的stage'><span class='caption-text'>图中的颜色和本文的颜色无关，只是表示2个动画的stage</span></span></p>

<h2>iOS8的改动</h2>

<p>Core Animation 有一个additive的属性实际上已经存在很久了，但是却很少被大家知道（我自己也是）。在iOS8 之前，UIKit创建的动画默认是不使用additive的，而在iOS8之后，默认是Additive的。有兴趣的同学可以试一试download <a href="https://github.com/studentdeng/CoreAnimationAdditiveExample">demo code</a>用Xcode6(这会还是beta)并打开macro<code>#define USING_UIKIT 1</code>看一下新的UIKit animation效果。</p>

<p>在了解背后的机制之后，其中的变化也很容易理解。</p>

<ol>
<li>completion block 的调用变了。之前在创建一个UIKit的动画时候，会覆盖掉上一个动画，也就是删除再添加一个新动画，而现在前一个动画会在真正执行完毕才会执行completion block。</li>
<li>不是所有的动画都支持additive</li>
</ol>


<p>&#8230;&#8230;</p>

<h1>参考</h1>

<ul>
<li><a href="https://developer.apple.com/videos/wwdc/2014/?id=236">《WWDC2014 236_building_interruptible_and_responsive_interactions》</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/coreanimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW3">《Core Animation Programming Guide:Core Animation Basics》</a></li>
<li><a href="http://kxdx.org/additive-core-animation/">《additive-core-animation》</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/13/auto-layout/">AutoLayout 相关概念介绍和动画demo</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-13T18:28:00+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/06/13/auto-layout/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>前言</h1>

<p>最近Apple的动作还是蛮多的，其中有3条很有意思。</p>

<ul>
<li>iOS8中设备旋转，布局的变化</li>
<li>可能的iPhone6屏幕的变化，iPhone和iPad Mac开发越来越趋于统一</li>
<li>Xcode6中Interface Builder的变化（IB中显示自定义View）</li>
</ul>


<p>cocoa touch 开发中适配各种屏幕尺寸已经是能够预测的了，那么跟进AutoLayout 也就是必备技能了。</p>

<h1>传统的布局是如何做的</h1>

<p>一开始接触iOS的时候，我还是蛮喜欢他的布局系统。简单来说，一个图像，我们通过中心点坐标，旋转角度和轮廓大小来定义他在窗口中的位置</p>

<p>这里的坐标和笛卡尔坐标系不同的是Y的方向</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/autolayout-1.png' width='' height='' title='1-1 The default layer geometries for iOS'><span class='caption-text'>1-1 The default layer geometries for iOS</span></span></p>

<p>这里表示了anchorPoint含义，用于表示position相对bounds的位置，比如（0.5, 0.5）表示中心，（0,0）表示左上角</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/autolayout-2.png' width='' height='' title='1-2 The default unit coordinate systems for iOS'><span class='caption-text'>1-2 The default unit coordinate systems for iOS</span></span></p>

<p>下面表示了frame bounds position anchorPoint之间的关系，你可能觉得这个anchorPoint似乎没有什么用</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/autolayout-3.png' width='' height='' title='1-3, 1-4  How the anchor point affects the layer’s position property'><span class='caption-text'>1-3, 1-4  How the anchor point affects the layer’s position property</span></span>
<span class='caption-wrapper'><img class='caption' src='/images/autolayout-7.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>但是当我们旋转一个View的时候，好处就来了</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/autolayout-4.png' width='' height='' title='1-5 , 1-6 How the anchor point affects the layer’s position property'><span class='caption-text'>1-5 , 1-6 How the anchor point affects the layer’s position property</span></span>
<span class='caption-wrapper'><img class='caption' src='/images/autolayout-5.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<h1>传统布局的问题</h1>

<p>传统布局是非常高效的，组合各种变化，可以轻易得实现任意的2D动画，当然也可以轻易的解决静态的布局问题。但是在面对多个屏幕，屏幕旋转时，或是需要在2个View 中间动态增加一个View的时候显得非常繁琐。需要不断的写一些计算距离，位置的代码（甚至还有一些magic number）。网上有很多例子，比如<a href="http://www.raywenderlich.com/20881/beginning-auto-layout-part-1-of-2">beginning-auto-layout-part-1-of-2</a>，或是大家在平时工作中遇到的3.5inch和4inch屏幕之间的适配。</p>

<h1>AutoLayout</h1>

<p>AutoLayout使用非常简单，Xcode的支持也非常直观。但是因为和之前的方式有很大的不同，新手一开始很容易遇到一大堆的异常，crash在main函数里面，让人非常沮丧。但是在了解AutoLayout之后，就会发现这是一个非常非常elegant的布局解决方案，也很容易理解为什么crash，以及应该如何debug。</p>

<h2>constraints 约束</h2>

<p>AutoLayout 是一个描述各种约束的行为，比如，一个View 距离父View上边距多少，相邻之间的间隔，各个View之间的宽高关系等等。这一系列的条件就是为了最终确定之前提到的传统布局中需要的东西，这个View的大小，位置。所以，当我们设置的条件不足，或是条件冲突时，就会产生异常。</p>

<h2>Intrinsic Content Size 固有大小</h2>

<p>在使用AutoLayout的时候，UILabel 我们只需要设定他的position，不需要设置宽高，而一个自定义的UIView，我们不仅仅需要位置，还需要设定宽高，这是为什么呢？</p>

<p>每一个View 都有一个特别的属性叫做Intrinsic Content Size，这个可以理解成是一个View的最合适而且最小的宽度和高度。对于UILabe来说，就是至少得把我设定的文字都显示完整吧，所以系统只需要知道UILabel的位置。而UIView的Intrinsic Content是（0，0）所以需要设置UIView的宽高（或是设定周围的边距等等其他关系可以让系统知道这个View应该多宽，多高）。而Intrinsic Content Size，也是未来自定义View显示到Xcode中必须设置的属性之一。</p>

<h2>Phases of Display</h2>

<p>使用AutoLayout之后，把view显示到屏幕上面大体分成3步。</p>

<ul>
<li>Update constraints</li>
<li>Layout views</li>
<li>Display</li>
</ul>


<p>一般来说<code>layoutSubviews</code>负责布局，比如调整View之间的距离，大小，<code>drawRect</code>负责绘制，比如使用什么颜色。而AutoLayout则是在layout之前增加了一个设定约束的过程,也就是上面提到了<code>update constraints</code>。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/autolayout-8.png' width='' height='' title='1-7'><span class='caption-text'>1-7</span></span></p>

<p>在view的<code>layoutSubView</code>中，如果我们调用了<code>[super layoutSubView]</code> 系统就把设定的这些约束计算成每个view的bounds，center属性。当然我们也可以基于AutoLayout的结果,再做布局的调整。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/autolayout-9.png' width='' height='' title='1-8'><span class='caption-text'>1-8</span></span></p>

<p><strong>Display 不是这篇文章的重点，这里略过</strong></p>

<h2>Alignment Rect</h2>

<p>仔细阅读文档的同学会发现在Apple AutoLayout document中可以看到Alignment Rect 这个家伙。
AutoLayout中的Left，Right等约束，并不是针对View的frame。而是根据Alignment Rect。在绝大多数情况下Alignment = Frame。但是如果对某些需要交互的元素，而图片素材很小的时候，就可以利用Alignment把交互区域变大。可以参考UIImage 中的 <code>imageWithAlignmentRectInsets</code>。</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/autolayout-10.png' width='' height='' title='1-9'><span class='caption-text'>1-9</span></span></p>

<h2>Animation</h2>

<p>AutoLayout也可以配合传统的animation方法，整体代码结构如下。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="n">layoutIfNeeded</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">0.3f</span>
</span><span class='line'>                   <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                     <span class="c1">//... update constraints  </span>
</span><span class='line'>
</span><span class='line'>                     <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="n">layoutIfNeeded</span><span class="p">];</span>
</span><span class='line'>                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用AutoLayout也可以轻易的实现之前的设置frame很难实现的动画效果。比如下面的例子(很奇怪，优酷吃掉了后面几秒的动画&#8230;)</p>

<p><embed src="http://player.youku.com/player.php/sid/XNzI3NTQxOTI0/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

<p>使用之前传统的动画，实现这个过程，需要计算所有subView之间的距离，位置。而且在修改一个view的frame时，很难做到和其他View的移动速度同步。除非是custom <code>layoutsubview</code>。做起来相当麻烦。但是用AutoLayout则非常简洁直观，只需要设置第一个View的position，然后其他view约定好高度和间隔依次排列就好了。</p>

<p><a href="https://github.com/studentdeng/AutoLayoutAnimation">demo code</a></p>

<p>当然AutoLayout做动画的时候有的地方也很麻烦，比如希望旋转view A 的时候，或是使用transform时，很容易产生奇怪的结果。一般来说会设置一个host View通过AutoLayout设定位置，然后在旋转view A。一句话就是混合起来，各取优点。</p>

<h2>其他</h2>

<ul>
<li>Compression Resistance</li>
<li>Content Hugging</li>
<li>优先级</li>
</ul>


<p>简单的来说Compression Resistance 设置view有多大意愿（优先级），愿意压缩里面的内容。Content Hugging设置view 有多大愿意（优先级），愿意显示里面内容之外的部分。</p>

<p>stackoverflow上面有一个很清晰的通过UIButton解释的<a href="http://stackoverflow.com/questions/15850417/cocoa-autolayout-content-hugging-vs-content-compression-resistance-priority">[例子]</a>，可以很容易理解这2个属性。</p>

<h1>参考</h1>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/coreanimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW3">Core Animation Programming Guide:Core Animation Basics</a></li>
<li><a href="http://www.objc.io/issue-3/advanced-auto-layout-toolbox.html">Advanced Auto Layout Toolbox-objc.io</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2012/?id=202">WWDC2012 session 202 – Introduction to Auto Layout for iOS and OS X</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2012/?id=228">WWDC2012 session 228 – Best Practices for Mastering Auto Layout</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2012/?id=232">WWDC2012 session 232 – Auto Layout by Example</a></li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'studentdeng';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>








</body>
</html>
