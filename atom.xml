<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[不会开机的男孩]]></title>
  <link href="http://studentdeng.github.com/atom.xml" rel="self"/>
  <link href="http://studentdeng.github.com/"/>
  <updated>2013-09-16T00:37:45+08:00</updated>
  <id>http://studentdeng.github.com/</id>
  <author>
    <name><![CDATA[studentdeng]]></name>
    <email><![CDATA[studentdeng@hotmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[calm down]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/15/calm-down/"/>
    <updated>2013-09-15T23:03:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/15/calm-down</id>
    <content type="html"><![CDATA[<p>最近已经发生了很多事情，将来也会发生一些事情，这里为了不让我负能量爆发，就不写这些细节了。昨天和老大聊到晚上3点半，这里我还很dt的查了一下，上一次聊这么晚也就是2个月前。刚刚突然发现有人赞了一下我的微博，哦，很好，长出一口气，终于不是强X的无脑赞了。微博的内容是一篇关于《女人明白要趁早》的读书笔记，书里写过一句这样的话“这世上只有快乐的猪和悲伤的哲学家”，但在我看来，还有另一类人是悲伤的猪，而我显然属于后者。当然这不是我想说的，书中有一些这样的话。</p>

<p>“当你一无所知、一无所有、一无所成的时候,没事不要去想“个人尊严”和“个人价值”这 类虚词儿。一、做好眼前事。二、假以时日。 有完美榜样是好的,能让我们矢志不渝地去为追求完美努力;知道榜样其实不完美也是好的, 避免我们成为偏执狂,或者因为目标难以企及而自暴自弃。”</p>

<p>这个世界上面充斥这这样子的言论，你没有办法去反驳它，因为他本身说的就是事实，是正确的，而且是毫无疑问正确的，但是如果只是做到这些是不可能成功，或是更严格讲，这些都不是成功的关键因素，从心理学角度来看，这些话没有办法被证伪。这些话就是一个个成功人士为了安慰屌丝们的心灵鸡汤而已。</p>

<p>对于年轻的人们来说，经历的苦难和挫折大概都是因为阅历，资历不足，内心却比地球还大，一开始就像构建一艘航空母舰。但最后发现这样的航母根本做不出来，或是做出来随便小小的浪头就能把它拍的粉碎。而也有不少人意识到了这一点，做出了一搜搜驱逐舰，潜艇。但最后发现，光这艘船，根本不可能带你穿过那些暴风雨频发的海域。</p>

<p>我们害怕跌入日复一日平淡庸碌的结婚、生子、还房贷、终老一生的生活中去。但是现实就是这个社会最不缺的就是空想家，社会不仅不看你的想法，不在意你的未来，更不在意你的过去，只是看你的现在，你的所作所为。你所能掌握的资源，你能做出多少选择的能力。</p>

<p>大家都会成长，会慢慢看淡这些ups and downs，大家都在说，现在社会多么浮躁，年轻人要学会等待，假以时日，每天坚持，就会变好的。我只想说“呵呵”。平静会很容易的掩饰内心的平庸，诚然平静很重要，但绝对不是逃避，需要cope，而这需要一个强大的内心。只有内心足够强大才能做出抵挡风浪的船，而不是随流漂动的木板，虽然他们都是在水上浮着，当然木板也有好处，船会翻。木板不会。</p>

<p>一个朋友曾今问过我为什么给自己设定一个30岁的目标，因为有太多的东西我们不能左右，在到一定年纪就不得不考虑，作为一个男孩子，不得不去承担一些该来的责任，那么自由时间必定要被压缩，而且有一些事情，年纪大了，也就错过机会了，或是需要付出比年轻时候更多的投入。所以必须趁年轻，因为在再不疯狂就来不及了。</p>

<p>Tal在幸福课中提到一句，平庸和卓越在表面都很平静时是如何区分出来。卓越的人更会相信自己会做到。</p>

<p>额，本来还是想写下去，发现自己已经不知不觉开始写心灵鸡汤了，看来我已经被毒害不少了，再删掉一大段之后，思路瞬间被阻塞了。一阵阵困意袭来，呼~，昨天睡得有一点少了。今天最开心的就是，去东直门上了一节跳舞课，按照我以往对我自己的了解，我应该死宅在家里才对，绝对不会出门，更别说走这么远。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocoapods 入门]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/13/cocoapods-tutorial/"/>
    <updated>2013-09-13T23:48:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/13/cocoapods-tutorial</id>
    <content type="html"><![CDATA[<h1>介绍</h1>

<p>最近一直在搞<a href="https://github.com/CocoaPods/CocoaPods">cocoapods</a>。 ios 这么多年终于有一个好使的包管理了。真的好激动好激动。。。
之前开发一些App的时候，在一开始的时候，总是需要手动添加framework， library，设置一些 search path，有时候还会忘记那么几个，然后出来一大堆的link error。当一些library更新的时候，还需要自己手动去更换。3句话说就是</p>

<ol>
<li>手动增加framework，library</li>
<li>手动增加编译参数</li>
<li>手动维护代码更新</li>
</ol>


<p>完全是一大堆的体力活，当然，这些简单的配置和复制并不会花费太多的时间，但是，还是觉得在浪费生命，而这时候CocoaPods就出来了。我们只需要设置一个Podfile文件，执行</p>

<pre><code>$ pod install 
</code></pre>

<p>CocoaPods会帮我们下载好代码，设置好编译参数，配置好framework， library。</p>

<h1>安装和更新</h1>

<pre><code>$ sudo gem install cocoapods
</code></pre>

<h1>使用</h1>

<p>在project根目录下，create Podfile文件，下面一个例子</p>

<pre><code>platform :ios, '5.0'
pod 'CURestKit', '~&gt;1.0.1' 
pod 'SDWebImage','~&gt;3.4'
pod 'MBProgressHUD', '~&gt; 0.7'
pod 'UALogger', '~&gt; 0.2.3'
</code></pre>

<p>CocoaPods 会帮我们从git clone下来配置好的这些代码。后面的部分表示代码的版本号，一般来说和tag挂钩。</p>

<p>配置好Podfile之后，执行</p>

<pre><code>$ pod install
</code></pre>

<p>则会帮我们配置好这些项目。并生成一个XXXX.xcworkspace。 以后project使用这个文件就可以了。CocoaPods其实就是帮我们配置一个静态库作为项目的依赖。</p>

<p>CocoaPods里面有大量的代码，现在最新的版本安装后是在这里</p>

<pre><code>~/.cocoapods/repo/master/ 
</code></pre>

<h1>制作自己的项目配置</h1>

<p>实际开发过程中，我们还有不少代码需要被改动，而CocoaPods上面的代码，大部分都比较旧，都是很稳定的代码，当然也有一些不能用的（大部分是国内的公司做的，大家都懂的）。另外还有一些我们自己写的一些其他代码，暂时还么有被CocoaPods收录的。这时候我们就需要配置自己的项目啦。</p>

<p>这里是我的一个项目配置例子。cocoapods的配置文件就是一个 *.podspec的文件，这是一个例子文件名ShareCenter.podspec。这是一个典型的ruby，</p>

<pre><code>Pod::Spec.new do |s|
s.name         = "ShareCenter"
s.version      = "2.0"
s.summary      = "share client include sina weibo ,tencent weibo, renren"

s.description  = &lt;&lt;-DESC
               share client include sina weibo ,tencent weibo, renren
               DESC

s.homepage     = "https://github.com/studentdeng/ShareCenterExample"
s.license      = 'MIT'
s.author       = { "curer" =&gt; "studentdeng@hotmail.com" }
s.platform     = :ios, '5.0'

s.source       = { :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git", :tag =&gt; s.version.to_s }
s.source_files  = 'ShareCenter', 'ShareCenter/**/*.{h,m}'

s.frameworks   = 'QuartzCore', 'Security', 'CoreGraphics', 'AudioToolbox'
s.library = 'sqlite3.0'
s.vendored_libraries = 'ShareCenter/Vender/sina/libWeiboSDK/libWeiboSDK.a'

s.prefix_header_contents = &lt;&lt;-EOS
#ifdef __OBJC__
#import "ROConnect.h"
#endif /* __OBJC__*/
EOS
end
</code></pre>

<p>这个基本上都是自解释的，这里有几个需要说明一下</p>

<h2>s.source s.source_files</h2>

<p>这里的 <em>source</em> 我们看出是一个git 的地址，这里我们调试的时候，可以先暂时设置成本地git，调试完毕之后就可以发布 增加tag。想要最新的代码只需要这样设置就好</p>

<pre><code>{ :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git"}
</code></pre>

<p>我们的git项目中，并不是所有的代码都需要被引用到我们的代码中，通常project还会包括一些example，test cases等，这里的 <em>source_files</em> 就是用来指定一些文件夹，或是文件。我这里的设置也很容易理解，就是ShareCenter下面的递归后的所有后缀是h、m的子文件。</p>

<h2>s.frameworks s.library</h2>

<p>这里配置的就是我们的framework 和 library，这里注意一下library的名字规则就好。</p>

<h2>vendored_libraries</h2>

<p>这里用来指定外部的静态库。这里我们指定了sina sso认证的SDK</p>

<h2>s.prefix_header_contents</h2>

<p>这里用来指定预编译的配置，这里一定要鄙视一下renren的超级渣渣SDK。这里提供一种解决方法。</p>

<h2>部署我们的配置到cocoapods中</h2>

<p>cocoapods的代码配置文件是在这里<a href="https://github.com/CocoaPods/Specs">Specs</a></p>

<p>这里最好是去fork一个自己的project，然后保存一个自己或是团队的配置，这样不会在更新cocoapods的时候，丢掉自己的配置。当然，如果觉得自己搞的还不错，也可以去pull requests。</p>

<p>在之前提到的目录<em>~/.cocoapods/repo/master/</em> 下面，我们可以看到已经有超级多的项目了，我们可以也可以通过</p>

<pre><code>$ pod search XXX
</code></pre>

<p>来查找项目，或是直接在这个文件夹下面找，可以学习不少project的配置技巧，我这里也是从他们学到的。</p>

<p>最后添加一个project的配置是这样子的。</p>

<p>例如上面的例子，
在<em>~/.cocoapods/repo/master/</em> 下面创建一个文件夹ShareCenter，然后在创建一个2.0的文件夹表示这是version2.0的配置。
然后在把之前的ShareCenter.podspec复制到2.0目录下面。</p>

<p>也就是最后的目录是这样子的</p>

<pre><code>~/.cocoapods/repo/master/ShareCenter/2.0/ShareCenter.podspec
</code></pre>

<p>如果希望更多的了解cocoapods，还是需要去<a href="https://github.com/CocoaPods/CocoaPods">Github</a>上面 :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis服务器启动流程]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/19/redis-start-up/"/>
    <updated>2013-08-19T10:26:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/19/redis-start-up</id>
    <content type="html"><![CDATA[<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<p>让我们从 redis.c -> main() 开始</p>

<h1>读取配置文件</h1>

<p>在初始化完毕一些系统时间之后，redis开始初始化服务器配置。</p>

<h2>initServerConfig</h2>

<p>在这个函数中，初始化全局变量</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>struct redisServer 结构体描述了服务器的状态。这种庞大的数据结构实在是看的烦躁。
这里可以很方便的看到redis的系统默认配置。另外还初始化了系统命令表。</p>

<pre><code>server.commands = dictCreate(&amp;commandTableDictType,NULL);
populateCommandTable();
</code></pre>

<p>这里我们可以找到redis的命令所对应的函数名称。</p>

<pre><code>struct redisCommand redisCommandTable[] = {
    {"get",getCommand,2,"r",0,NULL,1,1,1,0,0},
    {"set",setCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setnx",setnxCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setex",setexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"psetex",psetexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
    //...
}


struct redisCommand {
    // 命令的名字
    char *name;
    // 命令的实现函数
    redisCommandProc *proc;
    // 命令所需的参数数量
    int arity;
    // 字符形式表示的 FLAG 值
    char *sflags; /* Flags as string represenation, one char per flag. */
    // 实际的 FLAG 值，由 sflags 计算得出
    int flags;    /* The actual flags, obtained from the 'sflags' field. */
    /* Use a function to determine keys arguments in a command line.
     * Used for Redis Cluster redirect. */
    // 可选，在以下三个参数不足以决定命令的 key 参数时使用
    redisGetKeysProc *getkeys_proc;
    /* What keys should be loaded in background when calling this command? */
    // 第一个 key 的位置
    int firstkey; /* The first argument that's a key (0 = no keys) */
    // 第二个 key 的位置
    int lastkey;  /* THe last argument that's a key */
    // 两个 key 之间的空隔
    int keystep;  /* The step between first and last key */
    // 这个命令被执行所耗费的总毫秒数
    long long microseconds;
    // 这个命令被调用的总次数
    long long calls;
};
</code></pre>

<p>这里可以看出，redis的命令配置，保存在底层数据结构dic中。</p>

<h1>服务器初始化</h1>

<h2>initServer</h2>

<p>这里设置信号回调函数，和继续初始化</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>结构外，创建了SharedObjects。</p>

<h3>createSharedObjects</h3>

<pre><code>initServer-&gt;createSharedObjects
</code></pre>

<p>redis这里将除了把一些常用的字符串保存起来，目的就是为了减少不断申请释放时CPU时间，内存碎片等等,常用的返回客户端的命令，消息等。如</p>

<pre><code>shared.ok = createObject(REDIS_STRING,sdsnew("+OK\r\n"));
shared.err = createObject(REDIS_STRING,sdsnew("-ERR\r\n"));

//...

shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(
    "-WRONGTYPE Operation against a key holding the wrong kind of value\r\n"));
//...
</code></pre>

<p>还初始化了一个很大的共享数字对象。</p>

<pre><code>#define REDIS_SHARED_INTEGERS 10000

for (j = 0; j &lt; REDIS_SHARED_INTEGERS; j++) {
    shared.integers[j] = createObject(REDIS_STRING,(void*)(long)j);
    shared.integers[j]-&gt;encoding = REDIS_ENCODING_INT;
}
</code></pre>

<h3>aeCreateEventLoop</h3>

<pre><code>initServer-&gt;aeCreateEventLoop



/* Include the best multiplexing layer supported by this system.
* The following should be ordered by performances, descending. */
#ifdef HAVE_EVPORT
    #include "ae_evport.c"
#else
    #ifdef HAVE_EPOLL
        #include "ae_epoll.c"
    #else
        #ifdef HAVE_KQUEUE
            #include "ae_kqueue.c"
        #else
            #include "ae_select.c"
        #endif
    #endif
#endif
</code></pre>

<p>接下来创建eventloop。这里调用 aeApiCreate 创建event loop。redis这里根据不同平台会选择不同的event方式，
Linux 使用epoll，BSD上面使用kqueue，其他选择select</p>

<h3>初始化网络连接</h3>

<pre><code>if (server.port != 0) {
    server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);
    if (server.ipfd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening port %d: %s",
            server.port, server.neterr);
        exit(1);
    }
}

if (server.unixsocket != NULL) {
    unlink(server.unixsocket); /* don't care if this fails */
    server.sofd = anetUnixServer(server.neterr,server.unixsocket,server.unixsocketperm);
    if (server.sofd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening socket: %s", server.neterr);
        exit(1);
    }
}
</code></pre>

<h3>创建系统cron定时器</h3>

<pre><code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);

aeCreateTimeEvent
aeCreateTimeEvent accepts the following as parameters:
eventLoop: This is server.el in redis.c
milliseconds: The number of milliseconds from the current time after which the timer expires.
proc: Function pointer. Stores the address of the function that has to be called after the timer expires.
clientData: Mostly NULL.
finalizerProc: Pointer to the function that has to be called before the timed event is removed from the list of timed events.
</code></pre>

<p>aeCreateTimeEvent 创建一个定时器，redis会在这个serverCron中清理系统变量，判断是否需要写入文件等操作。</p>

<h3>在event loop中绑定回调函数</h3>

<pre><code>if (server.ipfd &gt; 0 &amp;&amp; aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,
    acceptTcpHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.ipfd file event.");            
</code></pre>

<h1>设置启动event loop</h1>

<pre><code>// 设置事件执行前要运行的函数
aeSetBeforeSleepProc(server.el,beforeSleep);

// 启动服务器循环
aeMain(server.el);

// 关闭服务器，删除事件
aeDeleteEventLoop(server.el);
</code></pre>

<p>aeMain函数和之前用的很多的windows中的message queue非常相似。redis不断循环等待执行event。这里不论是定时器还是socket event，都会在这个event loop中被执行。</p>

<pre><code>void aeMain(aeEventLoop *eventLoop) {

eventLoop-&gt;stop = 0;

while (!eventLoop-&gt;stop) {

    // 如果有需要在事件处理前执行的函数，那么运行它
    if (eventLoop-&gt;beforesleep != NULL)
        eventLoop-&gt;beforesleep(eventLoop);

    // 开始处理事件
    aeProcessEvents(eventLoop, AE_ALL_EVENTS);
    }
}
</code></pre>

<p>方便整理，这里重复一下一开始的流程图</p>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<h1>处理客户端命令流程</h1>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/request-response.png" alt="处理客户端命令流程图" /></p>

<p>之前我们已经注册了socket acceptTcpHandler 回调函数，现在的流程是</p>

<pre><code>acceptTcpHandler-&gt;acceptCommonHandler-&gt;createClient-&gt;aeCreateFileEvent

if (aeCreateFileEvent(server.el, c-&gt;fd, AE_READABLE,
    readQueryFromClient, c) == AE_ERR) {
    freeClient(c);
    return NULL;
}
</code></pre>

<p>这里又向event loop中加入一个新的事件callback函数：aeCreateFileEvent 用于把event loop中的监听的事件和回调函数绑定在一起。</p>

<p>readQueryFromClient 则是客户端一切命令的入口函数。</p>

<pre><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
    redisClient *c = (redisClient*) privdata;
    char buf[REDIS_IOBUF_LEN];
    int nread;
    // ...

    nread = read(fd, buf, REDIS_IOBUF_LEN);
    // ...
    if (nread) {
        size_t oldlen = sdslen(c-&gt;querybuf);
        c-&gt;querybuf = sdscatlen(c-&gt;querybuf, buf, nread);
        c-&gt;lastinteraction = time(NULL);
        /* Scan this new piece of the query for the newline. We do this
        * here in order to make sure we perform this scan just one time
        * per piece of buffer, leading to an O(N) scan instead of O(N*N) */
        if (c-&gt;bulklen == -1 &amp;&amp; c-&gt;newline == NULL)
            c-&gt;newline = strchr(c-&gt;querybuf+oldlen,'\n');
    } else {
        return;
    }
    Processinputbuffer(c);
}
</code></pre>

<p> readQueryFromClient读取客户端命令，交给Processinputbuffer处理。</p>

<pre><code>void processInputBuffer(redisClient *c) {
    //...

    if (processCommand(c) == REDIS_OK)
        resetClient(c);
}

int processCommand(redisClient *c) {
    //...
    call(c,REDIS_CALL_FULL);
}
</code></pre>

<p>这里call回根据command定义的callback函数，执行相对应的redis命令代码。</p>

<p>当command执行完毕之后，准备将结果传递给客户端。这里可以看到注册了sendReplyToClient回调函数。</p>

<pre><code>int prepareClientToWrite(redisClient *c) {
    if (c-&gt;flags &amp; REDIS_LUA_CLIENT) return REDIS_OK;
    if (c-&gt;fd &lt;= 0) return REDIS_ERR; /* Fake client */
    if (c-&gt;bufpos == 0 &amp;&amp; listLength(c-&gt;reply) == 0 &amp;&amp;
        (c-&gt;replstate == REDIS_REPL_NONE || c-&gt;replstate == REDIS_REPL_ONLINE) &amp;&amp;
        aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR)
            return REDIS_ERR;
    return REDIS_OK;
}
</code></pre>

<p>读到这里，我们已经看到了。redis在处理event loop的时候，不仅仅是处理客户端的连接，很多redis内部的流程也是通过event loop实现的。这个是event driven常常遇到的方式。</p>

<p>内容资料、图片、代码参考</p>

<ul>
<li><a href="https://github.com/huangz1990/annotated_redis_source">huangz的redis2.6代码注释</a></li>
<li><a href="http://pauladamsmith.com/articles/redis-under-the-hood.html#back-up-to-main">Redis: under the hood</a></li>
<li><a href="http://redis.io/topics/internals-rediseventlib">Redis Event Library</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box2d 05 RevoluteJoint and b2WeldJoint]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/08/box2d-05/"/>
    <updated>2013-08-08T15:11:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/08/box2d-05</id>
    <content type="html"><![CDATA[<p>资料代码，思路来自 <a href="http://www.raywenderlich.com/4756/how-to-make-a-catapult-shooting-game-with-cocos2d-and-box2d-part-1">raywenderlich</a>。这个只是自己学习时的笔记，非原创。</p>

<h1>b2RevoluteJoint</h1>

<ul>
<li>将刚体固定在一个点上，刚体可以围绕这个点旋转</li>
<li>可以提供马达，提供刚体旋转的动力</li>
</ul>


<p>所以，通过b2RevoluteJoint的第一个特性，我们可以很方便的模拟跷跷板。而第二个特性，我们可以很方便的实现汽车运动，或是弹弓类似的东西，今天实现一个类似疯狂小鸟的demo</p>

<p>创建b2RevoluteJoint很简单，但是里面有一些属性还是让人比较纠结，特别是好多中文blog，不知道是笔误还是无心，都是错的 =, =!</p>

<pre><code>b2RevoluteJointDef armJointDef;
armJointDef.Initialize(groundBody, armBody, b2Vec2(233.0 / PTM_RATIO, FLOOR_HEIGHT / PTM_RATIO));

armJointDef.enableLimit = true;
armJointDef.lowerAngle = CC_DEGREES_TO_RADIANS(9);
armJointDef.upperAngle = CC_DEGREES_TO_RADIANS(75);

armJointDef.enableMotor = true;
armJointDef.maxMotorTorque = 200;
armJointDef.motorSpeed = - 10;

armJoint = (b2RevoluteJoint *)world-&gt;CreateJoint(&amp;armJointDef);
</code></pre>

<p>这3个很好理解，就是对我们的旋转做限制。单位是弧度。</p>

<ul>
<li>enableLimit</li>
<li>lowerAngle</li>
<li>upperAngle</li>
</ul>


<p>这3个稍微不好理解</p>

<ul>
<li>enableMotor：     表示是否开启我们的旋转马达</li>
<li>motorSpeed：      表示我们希望马达给我们提供的速度是多少，小于0表示顺时针</li>
<li>maxMotorTorque：  表示马达给我们提供的扭矩有多少。</li>
</ul>


<p>简单的说，就是maxMotorTorque为我们提供改变速度的力。motorSpeed表示我们希望达到的最大速度是多少。</p>

<h1>b2WeldJoint</h1>

<p>b2WeldJoint又是一个很好理解的连接器。b2WeldJoint通过一个点把2个刚体绑定在一起运动。</p>

<pre><code>b2WeldJointDef weldJointDef;
weldJointDef.Initialize(bulletBody, armBody, b2Vec2(230.0f/PTM_RATIO,(155.0f+FLOOR_HEIGHT)/PTM_RATIO));
weldJointDef.collideConnected = false;

bulletJoint = (b2WeldJoint*)world-&gt;CreateJoint(&amp;weldJointDef);
</code></pre>

<p>在弹弓实例下，我们可以将炮弹绑定在我们的发射架上，当发射架运动到一定角度时，我们可以释放这个连接器，炮弹就可以射出了。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/05">source code</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTkzMzI0ODAw" frameborder=0 allowfullscreen></iframe>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跳跃表 skip list]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/08/skip-list/"/>
    <updated>2013-08-08T09:51:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/08/skip-list</id>
    <content type="html"><![CDATA[<p>最近在学习<a href="http://redis.cn">redis</a>，这时才知道了<a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>，结合<a href="http://v.163.com/movie/2010/12/7/S/M6UTT5U0I_M6V2TTJ7S.html">Mit 算法导论 lecture 12</a>，在奋斗了2个早上的时间后有了下面的东东。</p>

<p>对于我们熟悉的binary search来说，我们需要能够做到random access才行。但是在普通的link这种数据结构中却不能做到。而这种情况下我们有很多类似的工具比如heap，tree，b tree，red－black tree。等等类似的都是来自AVL的变种。但是说实话，这些东东，的确是挺难实现的，需要做各种的旋转啊，调整啊，来保持平衡。特别是red－black tree。而这时的skip list 就为我们提供了一个很好的思路。</p>

<h1>introduction</h1>

<p>让我们先从简单的开始</p>

<p><img src="http://studentdeng.github.io/images/skip_list1.png" alt="image" /></p>

<p>如果最下面的数字是已经排序好的数列，我们想要快速查找其中一项，而不是简单的便利。我们可以增加一个link，也就是上面的一条，来让我们能够“跳过”一些元素，也就是减少一些不必要的比较。</p>

<p>那么在2条时，我们的访问程度是多少呢？L2 + L1 / L2, 也就是第二条link的个数+ 每一个小端个数，这个是最差情况。显然，让这个不等式和最小，需要 L2 = L1 / L2。 显然L1是一个定值。这里设为N,那么，2条link下，我们的查找复杂度是 2 * √n</p>

<p>如何再优化呢？这个思路很简单，就是在L2上面再构建一个link L3. 整个时间也就是 L3 ＋ L2 ／ L3 ＋ L1 ／ L2 ，根据不等式性质，他们的和最小时，也就是 L3 ＝ L2 ／ L3 ＝ L1 ／ L2。当L1 ＝ N时，他们的和时 3 * 立方根（N）</p>

<p><img src="http://studentdeng.github.io/images/skip_list_l3.png" alt="image" /></p>

<p>当第k层时， 我们的时间则是 k * k次方跟（N）</p>

<p>当k = lgN 时，我们的时间为 lgN * lg 次方跟（N），根据对数的换底公式，我们可以得出 时间是 2lgN. 哈，我们现在已经降到O(lgN).我们满足了。</p>

<p>这时我们可以想象一下，这个skip list的结构，其实就是一个binary tree。我们通过最上面的一层访问类似跟节点的情况，然后一层层link 相当于tree的孩子节点，整个比较过程和binary search 非常的相似。</p>

<h1>insert</h1>

<p>对于这些结构来说，搞定search不是难点，插入和删除则是最麻烦的东西。这里我们可以自己思考一下，为了保证我们的link的结构足够完美，可能需要记录没一段的个数，然后我们可能有一些节点要上几层或是下几层。但是这个其实，本质上和那些avl树又一样了。skip list则是基于一种随机的策略来决定这些节点。其实我们可以思考一下，最完美的分法就是和binary tree一样的，所以这种2倍数的关系就可以用抛硬币的方式来决定。</p>

<p>这里为了程序时间方便，我们创建一个无穷小的节点作为我们的其实节点，这样，我们所有的开始都是从最左边。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_01.png" alt="image" /></p>

<p>我们插入一个元素30，这时我们可以判断一下这个新的元素是否需要“升级”，这里我扔了一下，反面，不用升级了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_02.png" alt="image" /></p>

<p>这里我们插入一个15，我扔了一下，反面。不用升级</p>

<p><img src="http://studentdeng.github.io/images/skip_list_03.png" alt="image" /></p>

<p>这里我们插入一个20，我扔了一个正面，又扔了一个正面，额，好吧第三次终于是反面了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_04.png" alt="image" /></p>

<p>这里涉及到了一点点的随机算法的证明，这些东西实在是让人烦躁。主要还是大学时候的概率学得就不咋地，现在也都忘了。从最直观的来看，就是一层层升级的概率会越来越低，在随机算法足够独立和大量的数目上来看，不难形成这样子的一个类似tree的结构。</p>

<h1>delete</h1>

<p>删除这里的操作简直就是blazingly simple,因为我们整个list layer 都是建立在随机上的，删除则是直接删除就好了</p>

<p>我在看到这里，基本已经受不了要吐槽了。实现这个也太简单了，相对red-black tree这种东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stanford 算法课上 Kosaraju algorithm]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/04/algorithms-class4/"/>
    <updated>2013-08-04T23:32:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/04/algorithms-class4</id>
    <content type="html"><![CDATA[<p>强连通图的应用场景我就不在这里赘述了。其中<a href="http://en.wikipedia.org/wiki/Kosaraju's_algorithm">Kosaraju</a>是最常见的一种。</p>

<p>这个也是Stanford 算法课<a href="https://class.coursera.org/algo-004/quiz/attempt?quiz_id=57">弟四周的作业</a>，现在看来是最难的一道题。那么这里我就给一个我自己的实现了。</p>

<p>这个作业的难度就在于他的输入是一个相当大的数据，处理不好，很容易溢出。那份大数据，我没有留在这里，感兴趣的同学可以自己下载。70多M，实在不适合放在github上面。</p>

<p><a href="https://github.com/studentdeng/algorithms_class">source_code</a></p>

<p>由于是xcode的环境，在g++下是过不去的。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apache 压力测试入门]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/03/apache-test/"/>
    <updated>2013-08-03T13:05:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/03/apache-test</id>
    <content type="html"><![CDATA[<p>最近一直想总结一点有关测试服务器性能的东西，今天先写一点入门的小东西了。
网站的stress test 工具很多，这里介绍一个我觉得最简单的webbench</p>

<h2>安装webbench</h2>

<pre><code>wget http://www.ha97.com/code/webbench-1.5.tar.gz
tar zxvf webbench-1.5.tar.gz
cd webbench-1.5
make
make install
</code></pre>

<h2>使用webbench</h2>

<pre><code>webbench -c 1000 -t 60 http://server_address/
</code></pre>

<p>c: 并发数， t 运行时间
下面是测试结果</p>

<pre><code>Speed=2798 pages/min, 53286 bytes/sec.
Requests: 2798 susceed, 0 failed.
</code></pre>

<p>表示 每分钟处理请求2798， 每秒钟传输量53286</p>

<h2>apache 的一点小问题</h2>

<p>前几天换了一个阿里云的服务器，最低配置。内存只有512M，在做测试的时候遇到了一点小问题，这里记录一下。
服务器使用lamp默认配置，在低配置的情况下，我发现在-c 100 的情况下 mysql 就已经crash了。</p>

<p>这里是mysql日志</p>

<pre><code>130803 13:26:40 InnoDB: Initializing buffer pool, size = 128.0M
InnoDB: mmap(137363456 bytes) failed; errno 12
130803 13:26:40 InnoDB: Completed initialization of buffer pool
130803 13:26:40 InnoDB: Fatal error: cannot allocate memory for the buffer pool
130803 13:26:40 [ERROR] Plugin 'InnoDB' init function returned error.
130803 13:26:40 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
130803 13:26:40 [ERROR] Unknown/unsupported storage engine: InnoDB
130803 13:26:40 [ERROR] Aborting
</code></pre>

<p>发现系统内存似乎已经不够用了。
用下面命令查看系统性能</p>

<pre><code>top -i

top - 13:32:45 up 4 days, 18:01,  2 users,  load average: 1.54, 9.10, 8.42
Tasks: 242 total,  74 running, 168 sleeping,   0 stopped,   0 zombie
Cpu(s): 85.1%us, 14.5%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st
Mem:    501892k total,   496672k used,     5220k free,     4000k buffers
Swap:        0k total,        0k used,        0k free,    35128k cached

PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
6527 www-data  20   0  295m  13m 3952 R  2.3  2.8   0:00.75 apache2
6531 www-data  20   0  294m  13m 3204 R  2.3  2.7   0:00.51 apache2
7439 www-data  20   0  293m  12m 3484 R  2.3  2.6   0:00.30 apache2
7441 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.21 apache2
7455 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.14 apache2
7456 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.14 apache2
7463 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.08 apache2
7465 www-data  20   0  294m  13m 3480 R  2.3  2.7   0:00.08 apache2
7466 www-data  20   0  294m  13m 3480 R  2.3  2.7   0:00.08 apache2
6491 www-data  20   0  294m  13m 3204 R  2.0  2.7   0:00.51 apache2
6495 www-data  20   0  294m  13m 3268 R  2.0  2.7   0:00.52 apache2
6526 www-data  20   0  295m  13m 3872 R  2.0  2.9   0:00.57 apache2
6529 www-data  20   0  294m  13m 3212 R  2.0  2.7   0:00.48 apache2
6536 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.48 apache2
6537 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.47 apache2
6538 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.48 apache2
7442 www-data  20   0  293m  12m 3484 R  2.0  2.6   0:00.21 apache2
7458 www-data  20   0  293m  12m 3476 R  2.0  2.6   0:00.13 apache2
7464 www-data  20   0  294m  12m 3480 R  2.0  2.6   0:00.08 apache2
7467 www-data  20   0  294m  13m 3480 R  2.0  2.7   0:00.08 apache2
7468 www-data  20   0  294m  12m 3480 R  2.0  2.6   0:00.08 apache2
6528 www-data  20   0  295m  13m 3884 R  1.7  2.8   0:00.62 apache2
7457 www-data  20   0  293m  12m 3480 R  1.7  2.6   0:00.13 apache2
7469 www-data  20   0  294m  13m 3480 R  1.7  2.7   0:00.07 apache2
7470 www-data  20   0  294m  13m 3480 R  1.7  2.7   0:00.07 apache2
7492 www-data  20   0  293m  12m 3484 R  1.7  2.6   0:00.05 apache2
7484 www-data  20   0  293m  12m 3484 R  1.3  2.6   0:00.04 apache2
…
</code></pre>

<p>一下子看到好多的apache procress，让我大吃一惊。。。可见我有多弱了。。。原来每一个http请求，apache都开了一个进程来处理，而一个进程需要13M的物理内存。 而这一台服务器总共物理内存只有512M</p>

<h2>apache 的工作模式</h2>

<p>apache 的工作模式有几种，我们可以通过下面命令查看</p>

<pre><code>apachectl -l

Compiled in modules:
core.c
mod_log_config.c
mod_logio.c
prefork.c
http_core.c
mod_so.c
</code></pre>

<p>这个表明我们在prefork工作模式下，也是最稳定用的最多的工作模式。
在这个模式下每一个用户的请求都会交给一个进程来处理，但是频繁的创建和销毁进程这种重量级操作降低不少系统性能，所以我们可以通过设置一些参数。但不管怎么样，都是一个请求一个进程。当进程数收到限制时，请求只能等待。而最大的请求书，显然受到系统硬件限制。</p>

<p>我们可以在查看默认配置</p>

<pre><code># prefork MPM
# StartServers: number of server processes to start
# MinSpareServers: minimum number of server processes which are kept spare
# MaxSpareServers: maximum number of server processes which are kept spare
# MaxClients: maximum number of server processes allowed to start
# MaxRequestsPerChild: maximum number of requests a server process serves
&lt;IfModule mpm_prefork_module&gt;
    StartServers          5
    MinSpareServers       5
    MaxSpareServers      10
    MaxClients           150
    MaxRequestsPerChild   0
&lt;/IfModule&gt;
</code></pre>

<p>这个已经说的很清楚了，对于现在的服务器配置，尝试MaxClients 修改成 40</p>

<p>再次查看系统性能</p>

<pre><code>top - 13:44:13 up 4 days, 18:12,  2 users,  load average: 12.10, 6.50, 8.88
Tasks: 209 total,  41 running, 168 sleeping,   0 stopped,   0 zombie
Cpu(s): 91.7%us,  7.9%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st
Mem:    501892k total,   399804k used,   102088k free,     6936k buffers
Swap:        0k total,        0k used,        0k free,    71048k cached 
</code></pre>

<p>这是-c 100 已经没有问题了。</p>

<pre><code>Speed=2780 pages/min, 52868 bytes/sec.
Requests: 2780 susceed, 0 failed.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git 部署代码到服务器]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/30/git-deploy/"/>
    <updated>2013-07-30T22:34:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/30/git-deploy</id>
    <content type="html"><![CDATA[<p>之前常用的部署代码就是用svn，或是更老土的ftp。今天在写一个新玩具的时候，突然发现，每次的git pull实在是一个让人烦躁的东西，就网上查找了一下，整理在这里。<a href="http://toroid.org/ams/git-website-howto">参考原文</a></p>

<p>实现原理是当我们push 代码到remote repository时，通过git的<a href="https://www.kernel.org/pub/software/scm/git/docs/githooks.html">post-receive hooks</a>。执行</p>

<pre><code>git checkout -f
</code></pre>

<p>来帮助我们实现自动部署</p>

<p>让我们从最简单的开始，现在<strong>本地创建</strong>一个git repository</p>

<pre><code>$ mkdir test &amp;&amp; cd test
$ git init 
$ echo 'Hello, world!' &gt; index.html
$ echo 'Hello, world!' &gt; index.html
$ git add index.html
$ git commit -q -m "The humble beginnings of my web site."
</code></pre>

<p>index.html 就是我们希望能够部署到服务器的代码</p>

<p>然后在<strong>服务器</strong>创建一个repository, 这里可不是服务器部署代码的位置</p>

<pre><code>$ mkdir test.git &amp;&amp; cd test.git
$ git init --bare
$ cat &gt; hooks/post-receive
#!/bin/sh
GIT_WORK_TREE=/mnt/www/test git checkout -f
$ chmod +x hooks/post-receive
</code></pre>

<p>这是服务器的git代码目录</p>

<pre><code>/repo/test.git
</code></pre>

<p>这里的 &#8216;/mnt/www/test&#8217; 就是我们将要部署服务器代码的位置，一般的lamp，我们喜欢放在www里，当然这里需要根据不同的环境更换就好了。</p>

<p>这里我们在<strong>本地</strong>的git目录下增加一个remote</p>

<pre><code>$ git remote add prod ssh://server_address/repo/test.git
$ git push prod +master:refs/heads/master
</code></pre>

<p>server_address 可以ip，域名。</p>

<p>我不太喜欢用这个命令行，我喜欢用<a href="http://www.sourcetreeapp.com">SourceTree</a>来做这个增加remote和最后的commit push 部分。</p>

<p>这时我们切换到<strong>服务器</strong>目录下，就可以看到我们的index.html 在我们向prod push的之后，已经自动check out 到我们指定目录下了。</p>

<p>之后我们只需要修改完成之后，git push prod 就可以自动部署代码了。</p>

<p>第一次用，这里标记一下，看看后面当发生冲突的时候，时一个什么样的情况。： ）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安装环境遇到的dt问题]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/26/tips-install/"/>
    <updated>2013-07-26T17:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/26/tips-install</id>
    <content type="html"><![CDATA[<h1>ruby on rails</h1>

<p>mysql2 image not found
<a href="http://stackoverflow.com/questions/4546698/library-not-loaded-libmysqlclient-16-dylib-error-when-trying-to-run-rails-serv">soluation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box2d 04 多边形刚体和鼠标连接器]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/22/box2d-04/"/>
    <updated>2013-07-22T13:34:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/22/box2d-04</id>
    <content type="html"><![CDATA[<p>我们在真正做一些物体的时候，有一些情况不是标准的圆形，矩形。这时我们需要创建多边形的刚体。这里推荐一个工具<a href="https://github.com/jfahrenkrug/VertexHelper">VertexHelper</a>来帮我们生成刚体的定义。</p>

<p>今天的东西似乎有一点太少了，再瞅瞅另一种连接器，b2MouseJoint——鼠标连接器。
在使用鼠标连接器之前，我们需要找到我们选择的是那一个物体。</p>

<ul>
<li>获取手势的位置，也就是坐标向量</li>
<li>创建一个小的物体，小到只是一个点，然后通过这个物体在物理世界中查找包含这个物体的刚体</li>
</ul>


<p>鼠标连接器的使用步骤
当检测到碰撞时，创建连接器</p>

<pre><code>b2MouseJointDef mouseJointDef;
mouseJointDef.bodyA = groundBody; //通常连接地面
mouseJointDef.bodyB = body;       //需要移动的刚体
mouseJointDef.target = locationWorld; //当前位置
mouseJointDef.maxForce = 1000 * body-&gt;GetMass(); //移动的最大力，这个决定移动的灵敏度
//mouseJointDef.collideConnected = true; //这个场景不需要

self.mouseJoint = (b2MouseJoint *) world-&gt;CreateJoint(&amp;mouseJointDef);
//body-&gt;SetAwake(true);         //很多地方指定了这个，但是我实际测试，这个场景也不需要
</code></pre>

<p>在手势移动的时候重新设置</p>

<pre><code>world-&gt;DestroyJoint(self.mouseJoint);
self.mouseJoint = NULL;
</code></pre>

<p>在手势取消和结束时销毁</p>

<pre><code>world-&gt;DestroyJoint(_mouseJoint);
</code></pre>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/04">demo</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTg2NDQxNzAw" frameborder=0 allowfullscreen></iframe>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box2d 03 b2Joint 连接器]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/20/box2d-03/"/>
    <updated>2013-07-20T13:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/20/box2d-03</id>
    <content type="html"><![CDATA[<p>在真实世界中，一个物体很难孤立的存在，比如一个我们的自行车，2个轮子除了可以自由滚动以外，还必须保证2个轮子之间的距离不变，而保证这个距离不变的就是自行车的大梁。我们的胳膊，需要保证在一定范围的情况下围绕一个点旋转等等。Box2D中 连接器就是用来保证刚体和刚体之间的某种关系而出现的。</p>

<p>我们先认识b2DistanceJoint——距离连接器。</p>

<p><img src="http://www.ladeng6666.com/blog/wp-content/uploads/2012/08/zixingche.jpg" alt="image" /></p>

<p>这是一个自行车的模型bodyA bodyB 就是之前熟悉的圆形刚体，中间的红线是我们的距离连接，anchorA，anchorB 则是连接器连接2个刚体的位置。非常的直观。</p>

<pre><code>b2DistanceJointDef jointDef;
jointDef.Initialize(ballA, ballB, ballA-&gt;GetPosition(), ballB-&gt;GetPosition());

b2DistanceJoint *join = (b2DistanceJoint *)world-&gt;CreateJoint(&amp;jointDef);
CGFloat distance = 30.0 / PTM_RATIO;
join-&gt;SetLength(distance);
</code></pre>

<p>非常的直观，制定连接的位置和距离，就创建完毕了。下面是一个demo，每当触摸屏幕的时候给自行车一个向右的冲量。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/03">demo代码</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTg1MjU2MTQ4" frameborder=0 allowfullscreen></iframe>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Box2D 02 刚体]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/19/box2d-02/"/>
    <updated>2013-07-19T15:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/19/box2d-02</id>
    <content type="html"><![CDATA[<p>刚体的属性有3种。</p>

<ul>
<li>staticBody</li>
<li>kinematicBody</li>
<li><p>dynamicBody</p>

<p>  staticzero mass, zero velocity, may be manually moved</p>

<p>  kinematic: zero mass, non-zero velocity set by user, moved by solver</p>

<p>  dynamic: positive mass, non-zero velocity determined by forces, moved by solver</p></li>
</ul>


<p>简单说就是static 的刚体没有质量，没有速度。
kinematic 的刚体没有质量，但是可以设置速度。
dynamic 的刚体就是之前我们写的小球。有质量有速度。</p>

<p>static 的常常用于游戏中的墙，这种不会移动的，而且不会受到力的作用改变他的位置，速度等。
kinematic 的常常用于游戏中的跳板这些，他们会移动，但是同样不会受到力的作用改变原来的运动轨迹。
dynamic 通常是我们的玩家，敌人。他们会移动，而且会受到力的作用，旋转，碰撞，加速等。</p>

<p>刚写好了几个demo，用来做这几种类型的区分，</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/02">demo代码</a></p>

<div class="video-container">
<iframe height=498 width=510 src="http://player.youku.com/embed/XNTg0OTM0OTg4" frameborder=0 allowfullscreen></iframe>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Box2D 01 基本概念]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/18/box2d-01/"/>
    <updated>2013-07-18T16:05:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/18/box2d-01</id>
    <content type="html"><![CDATA[<p>首先几个概念需要了解一下。</p>

<p><strong>world</strong>
就是engin需要模拟的世界，他有一个大家都很熟悉的重力</p>

<p><strong>body(刚体)</strong>
刚体的定义大家在物理中都熟悉了，在box2D世界中，刚体定义了物体一些重要的属性，比如质点位置，旋转角度，角速度，线性阻尼，等</p>

<p><strong>shape(形状)</strong>这里定义我们的物体的形状是圆的，方的还是多边形等</p>

<p><strong>fixture(材质？这个好难翻译中文)</strong>光是上面的东西，我们不能够完成物理世界的碰撞，fixture定义了几个重要的属性，包括摩擦系数，恢复系数，密度</p>

<p>回想当初学习的物理知识也就这么多了，当然后面还会介绍其他新的东西。有个形状，和密度我们可以计算质量，有了位置，速度，角速度，足够我们计算高中学到的简单碰撞了，在有恢复系数和线性阻尼，我们也能更好的模拟更真实的物理情景，而这也是大学物理的部分了。</p>

<p>好多的背景知识，让我们再看看如何在程序里面做一个真实的世界出来。</p>

<pre><code>b2Vec2 gravity;
gravity.Set(0.0f, -10.0f);
world = new b2World(gravity);
</code></pre>

<p>box2D的坐标是和笛卡尔坐标系一样的，向量 (0, -10) 表示我们真实世界的重力，大约为10米每秒</p>

<p>创建我们的第一个物体，一个圆球。
这里Box2D采用了工厂模式来创建一个我们需要的物体。我们首先描述一个需求，然后通过一个工厂来生产我们需要的产品。</p>

<pre><code>b2BodyDef bodyDef;//
bodyDef.type = b2_dynamicBody; //这里定义为动态刚体
bodyDef.position.Set(pt.x/PTM_RATIO, pt.y/PTM_RATIO);
body = world-&gt;CreateBody(&amp;bodyDef);

b2CircleShape bodyShape;
bodyShape.m_radius = 26.0 / PTM_RATIO; //定义球的半径

b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;bodyShape;
fixtureDef.density = 0.1f;  //密度
fixtureDef.friction = 0.1f; //摩擦力
fixtureDef.restitution = 0.9f; //恢复系数
body-&gt;CreateFixture(&amp;fixtureDef);
</code></pre>

<p>还急得之前的概念么？在定义好body，shape，创建好fixture之后。这些信息已经足够模拟真实运动了。因为是真实的世界，独立各个平台，box2D的单位是米，而不是程序图形图像的单位像素，PTM_RATIO这个宏用于转换单位。</p>

<p>当然，这些物理数据还不能让我们在程序中看到，为了美观，增加一点小东西，希望大家了解cocos2d。这里创建一个CCPhysicsSprite</p>

<pre><code>CCPhysicsSprite *sprite = [CCPhysicsSprite spriteWithFile:@"ball.png"];
[self addChild:sprite];

[sprite setPTMRatio:PTM_RATIO];
[sprite setB2Body:body];

//CCPhysicsSprite 的操作一定要在设置PTMRatio 和 body之后
[sprite setPosition: ccp(pt.x, pt.y)];
</code></pre>

<p>这时我们就可以看到一个小球自由落体，然后淡出世界，不过似乎有一种淡淡的忧伤，太无趣了这个世界。</p>

<p>让我们为这个世界创建一个边界，让小球不要运动超过屏幕。</p>

<pre><code>// Define the ground body.
b2BodyDef groundBodyDef;
groundBodyDef.position.Set(0, 0); // bottom-left corner

// Call the body factory which allocates memory for the ground body
// from a pool and creates the ground box shape (also from a pool).
// The body is also added to the world.
b2Body* groundBody = world-&gt;CreateBody(&amp;groundBodyDef);

// Define the ground box shape.
b2EdgeShape groundBox;      

// bottom

groundBox.Set(b2Vec2(0,0), b2Vec2(s.width/PTM_RATIO,0));
groundBody-&gt;CreateFixture(&amp;groundBox,0);

// top
groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO));
groundBody-&gt;CreateFixture(&amp;groundBox,0);

// left
groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(0,0));
groundBody-&gt;CreateFixture(&amp;groundBox,0);

// right
groundBox.Set(b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,0));
groundBody-&gt;CreateFixture(&amp;groundBox,0);
</code></pre>

<p>这里没有指定其他属性，默认创建的刚体是静态的，不会移动的。而这正是我们想要的。</p>

<p>这时小球会自由落体然后反弹，这时可以调整restitution，如果对这些不是很熟悉的话。但是总体感觉还是有一点无聊，让我们再来一点新东西。</p>

<pre><code>b2Vec2 force = b2Vec2(-30, 30);
body-&gt;ApplyLinearImpulse(force, body-&gt;GetPosition());
</code></pre>

<p>body是我们其中的一个小球。ApplyLinearImpulse的意思就是对body施加一个冲量。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/01">demo地址</a></p>

<div class="video-container">
<iframe height=498 width=510 src="http://player.youku.com/embed/XNTg0NTU4NzQ0" frameborder=0 allowfullscreen></iframe>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运动小结]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/09/exercise/"/>
    <updated>2013-07-09T08:02:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/09/exercise</id>
    <content type="html"><![CDATA[<p>有很多人觉得我能用1年的时间减肥30斤，并保持下来很牛，也许是有一点点的不容易吧。我这里纪录一下自己的心得。</p>

<h2>动力</h2>

<p>改变很难，减肥的确是一件非常难的事情，需要极大的意志力和时间的投入。我最开始的动力，可能说出来挺丢人，是因为自己喜欢的一个女孩，表白失败。然后顿时觉得浑身充满负能量没有地方发泄。再加上那会工作压力不大。然后便开始减肥。办了1年的会员，我告诉所有人，我要把肚子上的赘肉练下去，把胳膊上的肌肉练出来。几乎所有人都告诉我，这是不可能的，可能我脾气倔吧，我就越要把这件事情做好。</p>

<h2>第一个月减了20斤</h2>

<p>开始的第一个月是大家最容易坚持下来的，那会浑身都是负能量，我每天游泳1.5到2km，周末会游的远一点。运动了整整一个月，减了20斤。这个对于当时170斤的我来说，这个运动量已经是身体负荷的极限了，要知道铁人三项其中的游泳项目也就是1.5km。这会计算都有一点害怕，那会我一周累计起来要游泳1W米。。。</p>

<p>另外时间上的成本也很高，那会体力不好，基本上要游泳1个半小时多，加上洗澡的时间和收拾东西的时间，即便游泳池就在楼下这么近的位置，每天都需要花费至少2个小时。所以，可见我当时是有多么的闲。: (</p>

<h2>接下来的10个月</h2>

<p>我的经验是当运动到1个月的时候，是身体最疲劳的时候，懒惰情绪抬头，同时身体的疲劳积累越来越多，1个月就是这样的一个拐点。</p>

<p>1个月后，我不得不调整我的计划，我没有办法再坚持每天游泳的运动量了，我减少了1半，一个星期保证至少去3次，一般4次，每次1.5km，1个小时。体重没有变化，一直在保持，这里有一点很重要，中间因为一些假期休息导致反弹了至少3次，每次至少5斤。</p>

<p>有一些有趣的事情，比如情人节那天，大家都出去约妹子了，孤单的我一个人去游了3km，回来整个人就瘦了7斤。当时自己觉得那些运动节目弱爆了，一个星期减个7斤还要好意思觉得效果不错。当然，副作用非常明显，第二天我就起不了床，连续2天都没有去游泳。: D</p>

<p>在我运动了大概6-7个月的时候，我开始做腹部的训练。之前也曾经做过很多，但都没有能够坚持下来，而这次我准备来真的。一开始我只能做30个，用了一个月的时间到每天180个。和我之前说的一样，1个月是一个门槛，</p>

<p>然后又发生了一件事情，可以说是我人生的又一个拐点吧，和一个女孩分手，大量的负能量转换为了健身的动力，又坚持了4个月，而且加大游泳的运动量，于是我又减了5斤。</p>

<h2>最近5个月</h2>

<p>慢慢快1年了，我减了25斤，并保持了下来。这让我的精神状态得到了超级大的改观，我开始意识到运动给我带来的好处不仅仅是排解负能量。由于投入了大量的时间并形成习惯之后，我觉得我需要做一点变化，来提高我的健身效率。然后我找了健身教练来帮助我制定运动计划。</p>

<p>这个可以说是一个魔鬼计划吧，我先锻炼的是腹部，从一些比较入门的动作，当然这些动作已经比我之前做的动作要难好多了，而且数量也增加，每次做的动作都在200个以上，一周至少3次。一般4次。一个月后，达到了520个。然后随着每次运动量增加，我减少到了每周3次，其中1周2次私教课，我自己练一次，间隔游泳1.5km。也就是每天至少花1个小时健身。</p>

<p>1个月后果然是最难熬的腹部下去了一大块，腰围小了1寸，其实好多时候我都想把运动量减少到一周2次腹肌，其他时间游泳，因为练腹肌实在是太苦逼了，撕裂的疼。</p>

<p>我其实挺不好意思的，因为在我快要坚持不下去的时候，又遇到一个妹子，可能是我还没有从之前的那个人走出来，对妹子挺冷淡的，当我准备进入状态的时候，妹子觉得不合适走了。然后我就又获得了不少负能量，然后又坚持了一个月，每周3-4次，一次520个腹部动作。</p>

<p>然后还是吃素，尽量不吃肉，我需要改善我的体质，否则我坚持不下来这么大的运动量。
这2个月，我又减了5斤。非常不容易的5斤。非常开心，这时候所有人见到我都不得不相信我做到了1年前我说的，我要把肚子上的肉移动到胳膊上面。而且我的确是瘦了好多。</p>

<p>然后我开始纪录我的健身时间和计划。到现在正好3个月。上个月我开始更科学的健身，腹部训练我降到了一周2次，每次300个动作（我更换了新的动作，这300个比之前的520个难多了）。增加了胳膊，肩膀，腿部，背部，肩膀的训练。每天基本上身体挨个部位轮流练，坚持不下去了就去游个1.5km。最近开始做yoga。</p>

<p>这3个月，每个月都锻炼25天以上，每次不少于45分钟，</p>

<p>健身的误区有很多，比如很多妹子都不敢练器械，因为害怕练出肌肉，作为一个坚持做腹肌5个月的家伙来看，练出肌肉绝对没有想象的那么容易，抛开休息，饮食不说，只说运动量，我之前500多个的时候只是热身，如果想要有6块，运动量至少得增加1倍每天差不多1000个，当然，最好换动作，要不太浪费时间。</p>

<p>回头看，我能坚持下来，“妹子”的原因虽然上不了台面，但是的确是真真正正的导火索，感谢她们，让我养成了这样一个好习惯。</p>

<p>写到这里，我又看了一边我的运动时间表。很有意思的，有一周，我几乎从早上忙到晚上12点，每天大概15个小时工作，而我那周，居然健身375分钟.所以忙，只是借口而已。</p>

<p>希望我可以再坚持1年。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[唯一有益的怀旧是想像未来的自己怀旧现在]]></title>
    <link href="http://studentdeng.github.com/blog/2013/06/24/remember/"/>
    <updated>2013-06-24T13:34:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/06/24/remember</id>
    <content type="html"><![CDATA[<p>豆瓣的CEO阿北说过，唯一有益的怀旧是想像未来的自己怀旧现在。很奇葩的，就在几天前，这个事情真真切切的发生在了我的身上。这是我几天前写的，当时以为自己已经工作3年了。我从07年毕业开始计算工作正好2年，从创业的时间开始计算，也就是2年7个月。也就是说，我在半年后的“未来”，回头看了一下自己，瞬间觉得浑身充满正能量，我还有半年的时间去改变。</p>

<p>3年的工作是一个门槛，我这里也算是总结自己3年的经历，也可以说是分享吧。</p>

<p>毕业那会我也许有步入外企的机会，但是最后被cube这个家伙忽悠来了北京，我和cube认识很长时间，我在学校的时候，就和他一起工作了。后来他去了微软，等我大四了，他给我描述了一下他的idea，介绍了一起创业的团队，然后我就被他“骗”来了北京。cube是一个对工作有洁癖的人，他对自己的要求非常高，对parter的要求也非常高，事实上，这个最后被证明对团队是非常错误的。但是，对于一个即将毕业的我来说，则是一段非常好的经历。他为了激发我的热情，总是把有挑战的东西交给我来做，而他则负责扫尾。我们2个算是“结对编程”的经典例子————这是一种在IT领域非常高效的合作方式。而且我的团队给予了我充分的自由空间，真的没有任何要求和约束，完全靠着激情在工作。当然，最后这个也被证明是错误的。</p>

<p>时间飞快的就过了1年，cube当时有一句话，我记得非常清楚，也是我很认同的事情“我要在1年里积累别人3年的经验”。cube对工作非常认真，而且非常喜欢总结和分享。我受他影响很大，也非常喜欢写blog和分享，所以我们在创业的小圈圈里面还算有一点小名气，中间还有出版社找过我问我是否出书，后来也极大的方便我们招人。这是好的事情。</p>

<p>坏的事情就是，这1年过的也算是苦了。没有假期，没有周末，每天工作超过15个小时。但这1年也是我过的最快乐的1年。我的职业规划，完全在我的设想之中。从技能的提高角度来看，几乎不可能比这个做得更好。但是也为我们后来的失败埋下了伏笔，我们的team从来没有一个正式的公司架构，没有想过挣钱，只是觉得，几个哥们一起干，然后拿投资、融资，坐着一夜暴富的白日梦。</p>

<p>我们team算是中国第一批移动互联网创业的小公司了，我们的产品是要做一个类似wechart，米聊的东西。呵呵，现在想起来都觉得疯狂。当然，很现实，我们失败了，我们不得不转去做另一个东西，而且我们还遇到了一个更严重的问题，没钱了，因为激情不能当饭吃，有哥们开始离开了，因为各种各样的原因。而我也慢慢在团队中扮演更重要的角色，我才意识到，我那过去的1年是多么的幸运，我是team中唯一一个在做自己喜欢做的事情，而且只有一件事情。</p>

<p>创业第二个年头了，功夫不负有心人，在熬了不知道多少个通宵之后，在我们钱彻底完全花完之前，我们的东西还算得到了认可，拿到了200W的天使投资，我只能说，我的老大的“忽悠”能力的确很厉害，而且运气好得不得了。因为当时的资本市场已经很冷了，拿到投资之后，我们team还在创业的小圈圈里面风光了一把。太大的压力，导致我们休息了大概2个月的时间，我们挑新的办公室，布置新的生活工作环境，招人。我当时老开心了，我面试比我年纪大的人。呵呵。看到这里，一般人可能会觉得，终于雨过天晴了。没钱的日子终于结束了。但实际上却是一个新的深渊。在拿到投资之后，我们9个月，没有发布新产品，没有做软件更新。年底，老大和投资人谈崩，问我怎么想，我说本来就是追求自由的，没有自由，和他就别干了。在差，还能差过之前的日子。哈哈，可见我当时是多么幼稚，更坑的日子果然还在后面。。。。</p>

<p>俗话说得好，由俭入奢易，由奢入俭难。在放弃好的办公环境，不得已的情况下裁员，而且我们显然也没有什么好的计划，接不到项目，产品也没有打算。迷茫等消极情绪又开始蔓延。更糟的是cube要走了，也是因为女朋友的问题，要结婚了。之前有一个大哥对我很好很好的，我在北京第一年的房租都是他替我偷偷垫付的。也因为女朋友的问题离开了。然后team就这么半死不活的干熬。我的状态还没有很糟，我从EF那里得到了不少正能量，从游泳中发泄了不少负能量，但是team还是处在没有希望的状态。一切问题在我失恋之后彻底爆发了，所有的负面情绪完全淹没了我。我第一次和老大谈，我不干了。我想出国玩玩，或是回家睡觉。总之不想在北京待了。这让我老大疯了，说他认识的都是一群什么人啊，都是因为女人散伙？呵呵，当然，我们都很清楚，这个只是给自己一个听上去不错的借口而已。</p>

<p>在京城，对于像我们这种team的很多很多，大家都过的很苦，每天奋斗着只是为了能够在北京活下去，听上去很残酷，但现实的确是这样，好多好多次，都没钱活下去了，但是事情又有了转机，整个生活就是不断的从一个坑里面爬出来，再掉另一个坑里。come on, 当初怀着改变世界想法来到北京，显然被现实残酷的践踏掉了。因为创业，我和老大的关系很特别，我甚至知道他银行账户有多少钱，我也知道他发工资就是靠信用卡拆借，无抵押贷款这种非常危险的行为过着。更让我害怕的是，从他的身上我看到了我的未来，我在他手下做，到他的年纪，不会比他做得更好，看不到未来，那我为什么还要继续呢？</p>

<p>创业第三个年头，一天我和老大谈了很长很长时间，我质问他你30了，你觉得咱们继续这样下去，还有意义么？而且我也很冷静的表达出我的意愿，我觉得是该中止我们的创业了，老大表示他也累了。我们都希望大家能有一个好的结局吧，毕竟一起这么长时间了，然后我们team又开始很努力的做事情，很累，在1个月搞定了4个项目，然后我们挣到了后半年的生活费，但谁也没再提散伙了。</p>

<p>从我工作3年的结果来看，我除了第一年的进步很大以外，后2年几乎就是在原地踏步。听上去好像经历了不少事情，但是其实也没有什么价值，没有能够量化的价值，只是知道了什么是错误的而已，还是不知道以后该怎么办，未来在那里。</p>

<p>我曾经觉得我很清楚自己要做什么，不需要其他人的任何意见，只是聆听自己内心的声音就好，但是我却发现我居然浑浑噩噩的过了9个月。</p>

<p>我曾经觉得我一个非常有毅力的人，我想做的没有什么是执行不下去的，但是我却几乎要放弃我最喜欢的事情，而且还不只一次。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些早该知道的东西]]></title>
    <link href="http://studentdeng.github.com/blog/2013/06/20/something-should-already-known/"/>
    <updated>2013-06-20T22:18:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/06/20/something-should-already-known</id>
    <content type="html"><![CDATA[<p>今天真NM是个奇葩的一天，我居然在泡吧之后，开始写blog，我去，刚刚小区门我都没有想明白到底应该是拉还是推。但是我的确想把我的所思所想纪录下来，我的确不知道，在睡醒一觉之后，我还是否能够记住我现在的想法。</p>

<p>最近面试了好多人，也有和我同样年龄的家伙，让我不禁感叹，我的运气实在是好的不得了，我在一开始工作的时候，和一个对工作有洁癖的人－－cube 一起工作。一开始我做重复的活，干得我实在是荡漾得不行。没想到最后居然是cube来帮我做那些琐碎得事情，而我自己去做那些我真正感兴趣得，复杂的，有挑战得活。Oh my god， 我得运气的确是好的不得了，就像普通人一样，我遇到了我个人发展得瓶颈，当然，只不过是早了那么一点，只用了1年。</p>

<p>sometimes I just wonder why did it happen，就在今天，我看了一本非常非常非常好得书，里面正好讲到这个personal wall， 其实我一直在思考这个问题，这堵墙已经堵了我2年，就在前几天，我突然意识到我已经毕业3年了。我在思考为什么会有这么一个wall在那里。为什么我总是想不开。</p>

<p>有一个观点非常有趣，传统得教育，让我们已经习惯于独立承担压力，个人的努力换取分数，换取排名。而考试则作为一个人能力的最终评价标准。能够考一个牛B的分数，而这个排名，无疑形成了一个非常恶略的影响，其中的关键在于，过于强调了个人利益的得失。而且往往提供了一个唯一的正确的通往成功的路子。而这个schema则是非常致命的一个问题，当我们第一次步入社会的时候。</p>

<p>离开学校意味着，现在已经不存在正确答案这样的命题了，这个意味着不会有人来告诉你，你的选择是否正确。尽管你会有一大堆的朋友，一大堆的亲人，老师，学长 whatever， 很愿意告诉你，或是提供一些建议。但事实上，这些都是一些别人嚼过的馒头，是在精神上对你的强奸。因为你最后必须要靠自己作出决定。而且有趣的是，在社会这个环境中，一个团队的成功，才是个人成功的体现。你需要带领一个团队，你需要去share你的idea给你团队，也就是你不是像学校那样独立战斗。what&#8217;s more, 这个的正确答案，往往不是一个。</p>

<p>当然，有所失，也就意味这有所得。当结果不变得那么确定时， 也就意味着有很多惊奇得方法，可以去更加多元化去看待问题，用你得天赋，技巧和热情。</p>

<p>我相信到我这个年级得男孩，都努力得追过那么一个女孩子。这个就是TMD一个非常好得例子。这个不想学习那样是你一个人得事情，至少是2个人得事情。你需要学会share。当然，有人情商高，可以很轻松得搞定，但我也相信有很多想我这样得屌丝，始终搞不定，你可能已经用尽了所有得方法，努力，但仍然是没有打动那个女孩，有人会告诉你，这是你们2个人不合适。嗯，可能吧，这是一个挺好得答案，但这个始终不是一个我想要得答案。</p>

<p>就在今天，在听着DJ舞曲，强烈的beat在敲击我的心脏的时候，我突然想明白了。当你所有的思维都放在“如何让XXX喜欢上你”这个命题时，你已经将自己陷入到了一个非常大的误区，而当你确定用尽所有的方法，但还不能奏效时，你就遇到了那个wall， 就像你在工作中遇到的，技术瓶颈，技能瓶颈，对未来没有希望的想法一样。</p>

<p>而这个时候，一般人会绕过去，我去旅游，我去换一个工作，我去换一个女孩，我就会找到那个看上去更加“合适”的，岂不知，无论下一个是多么的好，看上去是多么的时候，你是还会遇到那堵墙。</p>

<p>聪明人的看法，则是是一个更加包容，广泛的看法。 我需要做的不只是让这个女孩子喜欢我， 我应该做的是如何才能成为一个让更多一女孩子喜欢的人。
okay， 这个idea最大的区别在于，你需要跳出你之前对那个女孩所作的一切，而且，还需要一个更加宽广的视野，这样才会发现，你可以做的事情，还有很多很多很多很多。而这里面得关键,就在于改变。</p>

<p>工作，爱情，任何事情都会遇到wall， 你copeed， 成长收获，逃避，分手，换工作。 当然这个比喻不是那么恰当。但是，在遇到困难的时候，用一个更加宽广的视野，的确可以把一件不可能再继续的事情， 再继续下去。</p>

<p>我的脑袋好晕好晕， 今天和老大喝了不算多，但是却还是晕，我们在想一个问题， 五道口这里，每天晚上都在high， 我在17楼都可以听到楼下happy的声音， 这里面有多少人是每天都来这里混的。 毫无疑问，这些人都是弱者。 有那些怀着改变世界梦想的人会在这里混的？</p>

<p>看着眼前的小蜡烛， 只要还没有完全熄灭，他总会重新燃烧起来。fabulous！</p>

<p>我去，真得好像继续写下去，但是实在是太困了，在跳完之后，更加身体疼得厉害， 胸部，胳膊，腿，除了没有训练得腹部以外，都在疼。 fuck，明天可能没法走楼梯了。 而刚才喝得酒，显然让我把这周得运动量提前透支了，anyway， 困得实在是不行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《20个月赚130亿》笔记]]></title>
    <link href="http://studentdeng.github.com/blog/2013/06/12/note-book/"/>
    <updated>2013-06-12T20:25:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/06/12/note-book</id>
    <content type="html"><![CDATA[<p>今天花整个中午读完得，不禁感叹一下自己。当时从老妈书柜里无意找到得一本编程书，让我写下了生平第一个程序，一个非常简单的计算器，同样是在小学6年级。甚至语言都是同样的Basic，当作者写到因为没有硬盘而无法保存程序时，很搞笑的是，我当时还不知道什么叫做硬盘，所有的程序也没有办法保存。</p>

<p>我也曾有一段时间沉浸在寻找肉鸡，寻找系统后门，黑别人电脑，盗窃别人qq号码等等一些现在想起来都很dt的事情。但是也许是上天和我开的一个玩笑吧，我并没有想作者那样努力的学习编程，而是走向了另一条路，沉迷电子游戏，游戏人生。</p>

<p>我不知道是幸运还是不幸，我从小的教育和大多数同龄人都不一样，我是完全完全自由发展的，我母亲或是没有时间，或是也不想过多的约束我，就像朋友一样，她玩我玩过的电子游戏，到最后，甚至和我一样沉迷网络。还说过“游戏谁不上瘾，只是因为玩得太烂”这样搞笑的话。</p>

<p>但是，最后，我肯定让她失望透顶了。她也对我说过，如果小时候要求严格一点是不是会很不一样。</p>

<p>有人多人认为作者实在是太幸运，我也是这么想的。在叛逆期，没有游戏更好的去发泄那些多余的精力了。但是作者显然找到了一个更加科学的方式，而且作者足够有天赋，而且也真的超级超级超级努力。不是一般的努力。完全源自内心的力量趋势作者每周工作超过80个小时，突击时甚至超过100个小时。在高中的时候就已经在计算机公司实习，等等的一切。让他能够在足够短的时间里面，在很年轻的时候，积累比别人多的多的多的能力，认识一帮一起改变世界的人。</p>

<p>现实就是非常残酷的，资源总是集中在那一帮少数人手中，不管是在国内还是在国外。而且那帮人还是极其有天赋，而且还在比我这种屌丝还在努力的进步。</p>

<p>所以说，看这种自传对我来说，只是自取其辱而已，但是今天却不一样了。</p>

<pre><code>每一个创业的成功当然都免不了运气的成分，但是现在回想起来，最重要的是你得抓得住这些运气，也就是俗称的“在正确的时间做正确的事情”
</code></pre>

<p>但是这个真的好难判断，神马是正确的事情。因为可以简单的回想一下，自己的人生中有没有那么认为是正确的时间做了正确的事情。一个例子，我在大学的大部分时间逃课掉了，要不是玩游戏，要不就是自学编程。这个最后造成的结果是，我彻底对游戏丧失了之前的狂热————因为我认为在游戏上面已经不可能做的更好，而自学编程，让我的计算机基础扎实无比，这为我后面1年积累别人3年的技术积累分不开。但是，这个惨烈的GPA，也让我现在决定是否出国上学无比头疼。</p>

<p>呼，总之，这本书让我产生了好多共鸣。<a href="http://book.douban.com/subject/6920100/">《20个月赚130亿》</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[code snippets]]></title>
    <link href="http://studentdeng.github.com/blog/2013/05/08/code-snippets/"/>
    <updated>2013-05-08T11:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/05/08/code-snippets</id>
    <content type="html"><![CDATA[<p>Recently I found a fascinated feature of Xcode is the Code Snippets feature. It allows you to just type few characters instead of requiring you retype them over and over.</p>

<p>In my opinion, this is feature is not very obvious. The snippets library is fairly well hidden. Luckily, I&#8217;ve found it. There&#8217;s no sort of + button or something on the bottom of IDE. Apple just add a gesture to it. The only way you add a new snippet is to write a chunk of code and drag it into the Code Snippet Library window, and then it creates a default snippet and you can modify it, do whatever you want.</p>

<p>add dynamic fields</p>

<pre><code>&lt;#something...#&gt;
</code></pre>

<p>Finally I also found the same feature of Netbeans. It&#8217;s called Code Templates. and this feature is much easier to use than xcode.</p>

<p>add dynamic fields</p>

<pre><code>${something...}
</code></pre>

<p>It&#8217;s really fascinated feature and avoid retype the same piece of code again and again.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apple Script 可执行的伪代码]]></title>
    <link href="http://studentdeng.github.com/blog/2013/04/24/apple-script-1/"/>
    <updated>2013-04-24T19:21:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/04/24/apple-script-1</id>
    <content type="html"><![CDATA[<p>apple script 这种脚本语言就是精炼, 可执行的伪代码</p>

<pre><code>tell application "Finder"

display dialog "选择源文件目录"
set sourcepath to quoted form of POSIX path of (choose folder)

display dialog "选择输出目录"
set destinationpath to quoted form of POSIX path of (choose folder)

end tell

do shell script "/usr/bin/php /Users/ygcurer/apigen/apigen.php --source " &amp; sourcepath &amp; " --destination " &amp; destinationpath &amp; " --title curer --charset UTF-8 --access-levels public,protected --internal no --php yes --tree yes --deprecated no --todo no --download no --source-code yes --colors yes --progressbar no --update-check no"
</code></pre>

<p>这里把php document generate 的shell command 包装进了application中</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[numb]]></title>
    <link href="http://studentdeng.github.com/blog/2013/03/31/numb/"/>
    <updated>2013-03-31T16:31:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/03/31/numb</id>
    <content type="html"><![CDATA[<p>前几天运气很好和一大堆朋友吃饭和一个老外boss吃饭, 他很牛, 20岁从MIT毕业, 第一份工作是参与波音777的设计制作, 做了当时波音第一个用电脑辅助设计飞机的软件. 在控制项目的时候, 他们当时犯了相当大的错误, 18个月30W行的C代码, 被重新推倒重来, 再用18个月一个team从头学习然后最后项目上线, 他说777是当时最安全的飞机. 因为在这个之前,的飞机一直是手写设计稿做的, 不是通过计算机. 然后我问他为什么要离开波音呢? 他说因为他觉得没有意思, 他在波音继续待下去,也就是一个非常出色的工程师, 这个不是他想要的, 他想去做一点更新的,更cool的东西, 但是这个似乎很矛盾的, 因为我知道他现在是做传统行业石油的, 每天都是谈论石头, 这个和做飞机根本不是一个概念啊.我问他这个似乎很矛盾啊, 他说恩,是的. 他离开波音之后, 花了6,7年. 知道了什么事情是不对的.2000年那会, 他做自己第一个公司, 是做电商, 当时风投给他们了$1500W, 最后还是没做下去, 没想到最后居然被NSA看中了, 因为这里面他们实现了一个根据兴趣爱好推荐内容的算法, 而这个算法,正好适合间谍交易的使用场景. =. =!</p>

<p>最后bob说了一句非常感动我的话, 想得到自己想要的东西, 非常难, 即便自己很努力的去做, 最后得到的和之前想象的完全不一样. 是的, 如果让我来总结我这2年来的收获,用一句话来说就是 &#8220;很多东西觉得真心过不去这个坎了, 但是这个事情却做到了, 而有些东西觉得挺简单的,但最后却一直没有做到&#8221;.而有意思的是,我再写这篇blogs之前的2个小时之前, 还在愁一个项目无法交付,但是,有时候运气就这样子砸下来了.</p>

<p>2年来, 就是不断地在从一个坑里爬出来,然后跌进去,再爬出来,再跌进去. 昨天晚上和老大聊到晚上3点.呵呵, 真得, 我们只是知道了什么事情是不对的.</p>

<p>2年前,我觉得我虽然是一个很diaosi的家伙,但是我有一点是觉得很少人能够做到我这点的, 就是我知道我想要做什么, 我喜欢做什么,我适合做什么, 能够在22岁的时候想明白这个事情,让我非常开心,而且也一直向这个目标前进, 而为了这个,当然, 我放弃了非常多的东西, 其实我现在也不知道,因为一个东西,你付出了大量的时间,即便是没啥天赋, 也会做得不错, 这个世界上有太多的东西,我没有做过, 甚至都没有听到, 我凭什么说我适合做这个呢?</p>

<p>唯一能确定的就是,&#8221;天道酬勤&#8221;,&#8221;机会只会留给有准备的人&#8221;</p>
]]></content>
  </entry>
  
</feed>
