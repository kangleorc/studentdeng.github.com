<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[不会开机的男孩]]></title>
  <link href="http://studentdeng.github.com/atom.xml" rel="self"/>
  <link href="http://studentdeng.github.com/"/>
  <updated>2013-12-30T23:45:54+08:00</updated>
  <id>http://studentdeng.github.com/</id>
  <author>
    <name><![CDATA[studentdeng]]></name>
    <email><![CDATA[studentdeng@hotmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2013年度总结]]></title>
    <link href="http://studentdeng.github.com/blog/2013/12/14/25years/"/>
    <updated>2013-12-14T22:24:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/12/14/25years</id>
    <content type="html"><![CDATA[<h1>过去的一年</h1>

<p>人生的第25个年头就要过去了，现在是14号，离25岁的终点还有一个星期。这个意味着我马上就要26岁了。25岁的人生马上就要结束了。为什么这么害怕25岁。25岁到底意味着什么？身体开始衰老而且入行3年。身体衰老意味着如果希望有一个好身材，那么需要付出比之前大的多的时间和毅力，甚至保持都是一件越来越难的事情。入行3年意味着你完成1W小时体验，科学上意味着你应该是一个专家且小有成就了。你已经不是一个小孩子，那种看一篇文章，听一个演讲就马上行动起来的年轻人。你需要能够制定适合自己的计划，而且稳定靠谱的执行下去，没有为什么，因为这个就是这个时候应该做到的。你的试错的成本会变得越来越高，而且你不得不面对一些自己在年轻的时候不愿意面对的问题。那么看看这1年来我做的事情吧。</p>

<p>我养成了2个好习惯，一个健身一个学英语。而且这2个方面都有了不少的进步，之前已经写得太多，这里不多说了。旅行过一次，一次接力马拉松，另外看了52本书。下面是具体的统计</p>

<p><img src="http://studentdeng.github.io/images/25-1.png" alt="image" /></p>

<p><img src="http://studentdeng.github.io/images/25-2.png" alt="image" /></p>

<p>其中小说最多16篇，心理学6本，计算机5本。20篇读书笔记，5个书评。</p>

<p>翻翻去年给自己定得目标，除了雅思没有搞定以外，其他的还算过去了。</p>

<h1>我是谁</h1>

<p>现在的社交工具越来越多，会有越来越多人的生活不经意之间闯进我们的生活里。你需要学会辨别他们。就拿一个跑马拉松来说，有人会说敢于参加就好了。但是实际上你不会知道她背后做了什么，各种准备，训练，以及比赛当天的赛程详细计划，多少米需要做什么，以及自己的目标，多少是基本目标，多少是超额的。我这么说并不说一些人会刻意隐瞒什么，而是这些一切的小事情上面所积累的习惯，造就了一个人的做事态度，价值观。</p>

<p>1年前的这会，我写下了这样的一段话。</p>

<p>“I would not be able to find the most difficult task in my life that is changing myself. 我将失去,或是更晚的意识到, 这个人生中最困难的任务,就是改变自己, 因为有太多的人, 别说改变自己, 面对自己都做不到, 因为自己可以骗得了任何人,但唯独骗不了自己。”</p>

<p>今天和一个朋友聊天，也正好聊到了这个。人们最大的敌人是自己，真的真的只有极少数的人可以做到面对自己，可以自己揭开自己心中的伤疤。今天我清晰的感觉到了我心脏的跳动，那种砰砰砰跳动的感觉，我很害怕。非常害怕，害怕到想哭却哭不出来。因为很简单，这一年来不管我做过哪些改变以及努力，其实可以用8个字概况“看似忙碌，实则焦虑”——纤细的胳膊，蹩脚的英语，以及居无定所没有稳定收入来源的生活。</p>

<p>不管是工作上面的总结，还是人际交往的总结，还是我做的一切一切的东西的源动力在于我过的生活和我想的不一样。胸围长5cm腰围小12cm绝对不会是“我希望我的身体强壮一点”一句话搞定的，同样那个钢筋铁骨的30多岁大姐姐也不是一句“我希望更漂亮健康”搞定的，有谁会理解从一个相夫教子的全职太太到孤身一人的心理落差呢？</p>

<p>这就是现实的生活，生活中永远不缺努力的人，也不缺焦虑。虽然我现在要比1年前做得要好很多。我不会去抱怨。学会把用来抱怨的时间去做事情。人总会慢慢的发现自己似乎强壮起来了，就像温水煮青蛙，看上去不错，但实际上根本没有变化，我只是学得更会掩饰自己的内心，更会假装而已。</p>

<p>越忙碌，学得越多，做的越多，只是在给自己掩饰自己的焦虑,暗示自己过的还好，但其实一点也不好。不得不承认自己处在一个下降的电梯，这就是我心中的“坑”。</p>

<p>当然也有好消息。好消息就是不是我才有焦虑，这个几乎只要是一个有想法的年轻人都有的（好阴暗的感觉&#8230;）</p>

<h1>要到那里去</h1>

<p>当我们回头看自己走过来的路时，看到的似乎只是依稀莫辩的“或许”。我们所能明确认知的仅仅是现在这一瞬间，而这也只是与我们擦肩而过。看看自己，除了青春，什么都没有。青春就是时间，时间不像钱，可以存，可以攒，时间只能用于消费或是投资。不得不承认，过去的日子里面，我浪费了太多的时间，有太多的遗憾，小时候有太多的不懂事，让自己现在变成这个样子，但是我不后悔。我认定的事情我都全力去做，有部分做到了，有部分延期做到了，也有一部分最后失败了。</p>

<p>2014年，把2013年的一些遗憾弥补上之后，给自己一个新的平台。到了找一个新电梯的时候了。多年以前做的决定，现在也是搏一把的时候了。</p>

<h1>后记</h1>

<p>这篇是在14号写的，实际上，在14号之前我已经想了1个多月了。如果一件事情还有遗憾，那么就还没有到放弃的时候。我从来没有这么长时间的思考过自己，也第一次帮别人思考自己。回头看自己思路的时候，发现还是有很多坑和不足，但我也看到了我在慢慢的变好。即将的26岁这一年，真的将是我非常重要的一年。鸡血又开始打上了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译 《Getting Pixels onto the Screen》]]></title>
    <link href="http://studentdeng.github.com/blog/2013/12/09/getting-pixels-onto-the-screen/"/>
    <updated>2013-12-09T15:55:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/12/09/getting-pixels-onto-the-screen</id>
    <content type="html"><![CDATA[<p><a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html#pixels">原文</a></p>

<h1>绘制像素到屏幕</h1>

<p>像素是如何绘制到屏幕上面的？有非常多的方式输出数据到屏幕，通过调用很多不同的framework和不同的函数。这里我们讲一下这个过程背后的东西。希望能够帮助大家了解什么时候该使用什么API，特别是当遇到性能问题需要调试的时候。当然，我们这里主要讲iOS，但是事实上，很多东西也是可以应用到OSX上面的。</p>

<h2>Graphics Stack</h2>

<p>绘制屏幕的过程中又很多都是不被人了解的。但是一旦像素被绘制到屏幕上面，那么像素就是有3种颜色组成：红绿蓝。这3个颜色单元通过特定的强弱组合形成一个特定的颜色。对于iPhone5 <a href="https://en.wikipedia.org/wiki/IPS_LCD">IPS_LCD</a> 的分辨率是1,136×640 = 727,040个像素，也就是有2,181,120个颜色单元。对于一个15寸高清屏幕的MacBook Pro来说，这个数字差不多是1500万。Graphics Stack 就是确保每一个单元的强弱都正确。当滑动整个屏幕的时候，上百万的颜色单元需要在每秒60次的更新。</p>

<h2>The Software Components</h2>

<p>下面是一个简单的例子，整个软件看起来是这个样子</p>

<p><img src="http://www.objc.io/images/issue-3/pixels-software-stack@2x.png" alt="image" /></p>

<p>显示器上面的就是GPU，图像处理单元。GPU是一个高度并发计算的硬件单元，特别是处理图形图像的并行计算。这就是为什么可以这么快的更新像素并输出到屏幕的原因。并行计算的设计让GPU可以高效的混合图像纹理。我们会在后面详细解释混合图像纹理这个过程。现在需要知道的就是GPU是被高度优化设计的，因此非常适合计算图像这种类型的工作。他比CPU计算的更快，更节约能耗。因为CPU是为了更一般的计算设计的硬件。CPU虽然可以做很多事情，但是在图像这方面还是远远慢于GPU。</p>

<p>GPU驱动是一些直接操作GPU的代码，由于各个GPU是不同的，驱动在他们之上创建一个层，这个层通常是OpenGL/OpenGL ES。</p>

<p>OpenGL（<a href="http://en.wikipedia.org/wiki/OpenGL">Open Graphics Library)</a>）是用来做2D和3G图形图像渲染的API。由于GPU是一个非常定制化的硬件，OpenGL和GPU紧密合作充分发挥GPU的能力来实现图形图像渲染硬件加速。对大多数情况，OpenGL太底层了。但是当1992年第一个版本发布后（20多年前），它就成为主流的操作GPU的方式，并且前进了一大步。因为程序员再也不用为了每一个GPU编写不同的应用程序。</p>

<p>在OpenGL上面，分开了几个。iOS设备几乎所有的东西变成了Core Animation，但是在OSX，绕过Core Animation而使用Core Graphic 并不是不常见。有一些特别的应用程序，特别是游戏，可能直接使用OpenGL/OpenGL ES. 然后事情变得让人疑惑起来，因为有些渲染Core Animation 使用 Core Graphic。类似AVFoundation， Core Image 这样的框架，或是其他的一些混合的方式。</p>

<p>这里提醒一件事情， GPU是一个强有力的图形图像硬件，在显示像素方面起着核心作用。它也连接着CPU。从硬件方面讲就是有一些总线把他们连接了起来。也有一些框架比如 OpenGL， Core Animation。Core Graphic控制GPU和CPU之间的数据传输。为了让像素能够显示到屏幕上面，有一些工作是需要CPU的。然后数据会被传给GPU，然后数据再被处理，最后显示到屏幕上面。</p>

<p>每一个过程中都有自己的挑战，在这个过程中也存在很多权衡。</p>

<h1>硬件层</h1>

<p><img src="http://www.objc.io/images/issue-3/pixels%2C%20hardware%402x.png" alt="image" /></p>

<p>这是一个很简单的图表用来描述一个挑战。GPU有纹理（位图）合成为一帧（比如1秒60帧）每一个纹理占用VRAM（显卡）因此GPU一次处理的纹理有大小限制。GPU处理合成方面非常高效，但是有一些合成任务比其他要复杂，所以GPU对处理能力有一个不能超过16.7ms的限制（1秒60帧）。</p>

<p>另一个挑战是把数据传给GPU。为了让GPU能够访问数据，我们需要把数据从内存复制到显存。这个过程叫做上传到GPU。这个可能看上去不重要，但是对于一个大的纹理来说，会非常耗时。</p>

<p>最后CPU运行程序。你可能告诉CPU从资源文件夹中加载一个PNG图片，并解压。这些过程都发生在CPU。当需要显示这些解压的图片时，就需要上传数据到GPU。一些事情看似非常简单，比如显示一段文字，对CPU来说是一个非常复杂的任务。需要调用Core Text 和 Core Graphic框架去根据文字生成一个位图。完成后，以纹理的方式上传到GPU，然后准备显示。当你滑动或是移动一段屏幕上面的文字时，同样的纹理会被重用，CPU会简单的告诉GPU只是需要一个新的位置，所以GPU可以重新利用现有的纹理。CPU不需要重新绘制文字，位图也不需要重新上传到GPU。</p>

<p>上面的有一点复杂，在有一个整体概念之后，我们会开始解释里面的技术细节。</p>

<h1>图像合成</h1>

<p>图像合成的字面意思就是把不同的位图放到一起创建成最后的图像然后显示到屏幕上面。在很多方面来看，这个过程都是显而易见的，所以很容易忽视其中的复杂性和运算量。</p>

<p>让我们忽视一些特殊情况，假设屏幕上面都是纹理。纹理就是一个RGBA值的矩形区域。每一个像素包括红，绿，蓝，透明度。在Core Animation世界里面，基本上相当于CALayer。</p>

<p>在这个简单的假设中，每一个层是一个纹理，所有的纹理通过栈的方式排列起来。屏幕上的每一个像素，CPU都需要明白应该如何混合这些纹理，从而得到相对应的RGB值。这就是合成的过程。</p>

<p>如果我们只有一个纹理，而且这个纹理和屏幕大小一致。每一个像素就和纹理中得一个像素对应起来。也就是说这个纹理的像素就是最后屏幕显示的样子。</p>

<p>如果我们有另一个纹理，这个纹理覆盖在之前的纹理上面。GPU需要首先把第二个纹理和第一个纹理合成。这里面有不同的覆盖模式，但是如果我们假设所有的纹理都是像素对齐且我们使用普通的覆盖模式。那么最后的颜色就是通过下面的公式计算出来的。</p>

<pre><code>R = S + D * (1 - Sa)
</code></pre>

<p>最后的结果是通过源的颜色（最上面的纹理）加目标颜色（下面的纹理） 乘以（1 - 源颜色的透明度）公式里面所有的颜色就假定已经预先乘以了他们的透明度。</p>

<p>很显然，这里面很麻烦。让我们再假设所有的颜色都是不透明的，也就是alpha = 1. 如果目标纹理（下面的纹理）是蓝色的（RGB = 0，0，1）源纹理（上面的纹理）是红色（RGB = 1，0，0）。因为Sa = 1， 那么这个公式就简化为</p>

<pre><code>R = S
</code></pre>

<p>结果就是源的红色，这个和你预期一致。</p>

<p>如果源（上面的）层50%透明，比如 alpha = 0，5. 那么 S 的RGB值需要乘以alpha会变成 （0.5,0,0）。这个公式会变成这个样子</p>

<pre><code>                   0.5   0               0.5
</code></pre>

<p>R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</p>

<pre><code>                   0     1               0.5
</code></pre>

<p>我们最后得到的RGB颜色是紫色(0.5, 0, 0.5) 。这个和我们的直觉预期一致。透明和红色和蓝色背景混合后成为紫色。</p>

<p>要记住，这个只是把一个纹理中的一个像素和另一个纹理中的一个像素合成起来。GPU需要把2个纹理之间覆盖的部分中的像素都合成起来。大家都知道，大多数的app都有多层，因此很多纹理需要被合成起来。这个对GPU的开销很大，即便GPU已经是被高度硬件优化的设备。</p>

<h1>不透明 VS 透明</h1>

<p>当源纹理是完全不透明，最终的颜色和源纹理一样。这就可以节省GPU的很多工作，因为GPU可以简单的复制源纹理而不用合成所有像素值。但是GPU没有办法区别纹理中的像素是不透明的还是透明。只有程序员才能知道CALayer里面的到底是什么。这也就是CAlayer有opaque属性的原因。如果opaque = YES, 那么GPU将不会做任何合成计算，而是直接直接简单的复制颜色，不管下面还有什么东西。GPU可以减少大量的工作。这就是Instruments（Xcode 的性能测试工具）中 <strong>color blended layers</strong> 选项做的事情。（这个选项也在模拟器菜单里面）。它可以让你了解哪一个层（纹理）被标记成透明，也就是说，GPU需要做合成工作。合成不透明层要比透明的层工作量少很多，因为没有那么多的数学运算在里面。</p>

<p>如果你知道哪一个层是不透明的，那么一定确保opaque = YES。如果你载入一个没有alpha通道的image，而且在UIImageView显示，那么UIImageView会自动帮你设置opaque = YES。但是需要注意一个没有alpha通道的图片和每个地方的alpha都是100%的图片区别很大。后面的情况，Core Animation 需要假定所有像素的alpha都不是100%。在Finder中，你可以使用Get Info并且检查More Info部分。它将告诉你这张图片是否拥有alpha通道。</p>

<h1>像素对齐和不对齐</h1>

<p>到目前为止，我们考虑的层都是完美的像素对齐的。当所有的像素都对齐时，我们有一个相对简单的公式。当GPU判断屏幕上面的一个像素应该是什么时，只需要看一下覆盖在屏幕上面的所有层中的单个像素，然后把这些像素合成起来，或者如果最上面的纹理是不透明的，GPU只需要简单的复制最上面的像素就好了。</p>

<p>当一个层上面的所有像素和屏幕上面的像素完美对应，我们就说这个层是像素对齐的。主要有2个原因导致可能不对齐。第一个是放大缩小；当放大或是缩小是，纹理的像素和屏幕像素不对齐。另一个原因是当纹理的起点不在一个像素边界上。</p>

<p>这2种情况，GPU不得不做额外的计算。这个需要从源纹理中混合很多像素来创建一个像素用来合成。当所有像素对齐时，GPU就可以少做很多工作。</p>

<p>注意，Core Animation Instrument和模拟器都有color misaligned images 选项，当CALayer中存在像素不对齐的时候，把问题显示出来。</p>

<h1>遮罩（mask）</h1>

<p>一个层可以有一个和它相关联的遮罩。遮罩是一个有alpha值的位图，而且在合成像素之前需要被应用到层的contents属性上。当你这顶一个层为圆角时，一就在设置一个遮罩在这个层上面。然而，我们也可以指定一个任意的遮罩。比如我们有一个形状像字母A的遮罩。只有CALayer的contents中的和字母A重合的一部分被会被绘制到屏幕。</p>

<h1>离屏渲染（Offscreen rendering）</h1>

<p>离屏渲染可以被Core Animation 自动触发或是应用程序手动触发。离屏渲染绘制layer tree中的一部分到一个新的缓存里面（这个缓存不是屏幕，是另一个地方），然后再把这个缓存渲染到屏幕上面。</p>

<p>你可能希望强制离屏渲染，特别是计算很复杂的时候。这是一种缓存合成好的纹理或是层的方式。如果你的呈现树（render tree）是复杂的。那么就希望强制离屏渲染到缓存这些层，然后再使用缓存合成到屏幕。</p>

<p>如果你的APP有很多层，而且希望增加动画。GPU一般来说不得不重新合成所有的层在1秒60帧的速度下。当使用离屏渲染时，GPU需要合成这些层到一个新的位图纹理缓存里面，然后再用这个纹理绘制到屏幕上面。当这些层一起移动时，GPU可以重复利用这个位图缓存，这样就可以提高效率。当然，如果这些层没有修改的化，才能有效。如果这些层被修改了，GPU就不得不重新创建这个位图缓存。你可以触发这个行为，通过设置shouldRasterize = YES</p>

<p>这是一个权衡，如果只是绘制一次，那么这样做反而会更慢。创建一个额外的缓存对GPU来说是一个额外的工作，特别是如果这个位图永远没有被复用。这个实在是太浪费了。然而，如果这个位图缓存可以被重用，GPU也可能把缓存删掉了。所以你需要计算GPU的利用率和帧的速率来判断这个位图是否有用</p>

<p>离屏渲染也可以在一些其他场景发生。如果你直接或是间接的给一个层增加了遮罩。Core Animation 会为了实现遮罩强制做离屏渲染。这个增加了GPU的负担，因为一般上来，这些都是直接在屏幕上面渲染的。</p>

<p>Instrument的Core Animation 有一个叫做Color Offscreen-Rendered Yellow的选项。它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时确保勾选Color Hits Green and Misses Red选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>

<p>一般来说，你需要避免离屏渲染。因为这个开销很大。在屏幕上面直接合成层要比先创建一个离屏缓存然后在缓存上面绘制，最后再绘制缓存到屏幕上面快很多。这里面有2个上下文环境的切换（切换到屏幕外缓存环境，和屏幕环境）。</p>

<p>所以当你打开Color Offscreen-Rendered Yellow后看到黄色，这便是一个警告，但这不一定是不好的。如果Core Animation能够复用屏幕外渲染的结果，这便能够提升性能，当绘制到缓存上面的层没有被修改的时候，就可以被复用了。</p>

<p>注意，缓存位图的尺寸大小是有限制的。Apple 提示大约是2倍屏幕的大小。</p>

<p>如果你使用的层引发了离屏渲染，那么你最好避免这种方式。增加遮罩，设置圆角，设置阴影都造成离屏渲染。</p>

<p>对于遮罩来说，圆角只是一个特殊的遮罩。clipsToBounds 和 masksToBounds 2个属性而已。你可以简单的创建一个已经设置好遮罩的层创建内容。比如，使用已经设置了遮罩的图片。当然，这个也是一种权衡。如果你希望在层的contents属性这只一个矩形的遮罩，那你更应该使用contentsRect而不是使用遮罩。</p>

<p>如果你最后这是shouldRasterize = YES，记住还要设置rasterizationScale = contentsScale</p>

<h1>更多的关于合成</h1>

<p>通常，维基百科上面有许多关于图像合成的<a href="https://en.wikipedia.org/wiki/Alpha_compositing">背景知识</a>。我们这里简单的拓展一下像素中的红、绿、蓝以及alpha是如何呈现在内存中的。</p>

<h1>OSX</h1>

<p>如果你在OSX上面工作，你会发现大部分的这些调试选项在一个独立的叫做“Quartz Debug”的程序里面。而并不在 Instruments 中。Quartz Debug是Graphics Tools中的一部分，这可以在苹果的developer portal中下载到</p>

<h1>Core Animation &amp; OpenGL ES</h1>

<p>就像名字所建议的那样，Core Animation 让我们可以创建屏幕动画。我们将跳过大部分的动画，关注于绘制部分。重要的是，Core Animation允许你坐高效的渲染。这就是为什么你可以通过Core Animation 实现每秒60帧的动画。</p>

<p>Core Animation 的核心就是基于OpenGL ES的抽象。简单说，它让你使用OpenGL ES的强大能力而不需要知道OpenGL ES的复杂性。当我讨论像素合成的时候，我们提到的层（layer）和 纹理（texture）是等价的。他们准确来说不是一个东西，但是缺非常类似。</p>

<p>Core Animation的层可以有多个子层。所以最后形成了一个layer tree。Core Animation做的最复杂的事情就是判断出那些层需要被绘制或重新绘制，那些层需要OpenGL ES 去合成到屏幕上面。</p>

<p>例如，当你这是一个layer的contents属性是一个CGImageRef时，Core Animation创建一个OpenGL 纹理，然后确保这个图片中的位图上传到指定的纹理中。或者，你重写了-drawInContext方法，Core Animation 会分配一个纹理，确保你的Core Graphics的调用将会被作用到这个纹理中。层的
性质和CALayer的子类会影响OpenGL渲染方式的效率。很多底层的OpenGL ES行为被简单的封装到容易理解的CALayer的概念中去。</p>

<p>Core Animation通过Core Graphics和OpenGL ES，精心策划基于CPU的位图绘制。因为Core Animation在渲染过程中处于非常重要的地位，所以如何使用Core Animation，将会对性能产生极大影响。</p>

<h1>CPU限制 vs GPU限制（CPU bound vs. GPU bound）</h1>

<p>当在屏幕上面显示的时候，有很多组件都参与其中。这里面有2个主要的硬件分别是CPU和GPU。P和U的意思就是处理单元。当东西被显示到屏幕上面是，CPU和GPU都需要处理计算。他们也都受到限制。</p>

<p>为了能够达到每秒60帧的效果，你需要确保CPU和GPU都不能过载。也就是说，即使你当前能达到60fps,你还是要尽可能多的绘制工作交给GPU做。CPU需要做其他的应用程序代码，而不是渲染。通常，GPU的渲染性能要比CPU高效很多，同时对系统的负载和消耗也更低一些。</p>

<p>因为绘制的性能是基于GPU和CPU的。你需要去分辨哪一个是你绘制的瓶颈。如果你用尽的GPU的资源，GPU是性能的瓶颈，也就是绘制是GPU的瓶颈，反之就是CPU的瓶颈。</p>

<p>如果你是GPU的瓶颈，你需要为GPU减负（比如把一些工作交给CPU），反之亦然。</p>

<p>如果是GPU瓶颈，可以使用OpenGL ES Driver instrument，然后点击 i 按钮。配置一下，同时注意查看Device Utilization % 是否被选中。然后运行app。你会看到GPU的负荷。如果这个数字接近100%，那么你交给GPU的工作太多了。</p>

<p>CPU瓶颈是更加通常的问题。可以通过Time Profiler instrument，找到问题所在。</p>

<h1>Core Graphics / Quartz 2D</h1>

<p>通过Core Graphics这个框架名字，Quartz 2D更被人所知。</p>

<p>Quartz 2D 有很多小功能，我们不会在这里提及。我们不会讲有关PDF创建，绘制，解析或打印。只需要了解答应PDF和创建PDF和在屏幕上面绘制位图原理几乎一致，因为他们都是基于Quartz 2D。</p>

<p>让我们简单了解一下Quartz 2D的概念。更多细节可以参考Apple的 <a href="https://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html">官方文档</a></p>

<p>Quartz 2D是一个处理2D绘制的非常强大的工具。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立等很多特性。因为是更为底层的基于C的API，所以看上去会有一点让人恐惧。</p>

<p>主要概念是非常简单的。UIKit和AppKit都封装了Quartz 2D的一些简单API，一旦你熟练了，一些简单C的API也是很容易理解的。最后你可以做一个引擎，它的功能和Photoshop一样。Apple提到的一个 <a href="https://developer.apple.com/videos/wwdc/2011/?id=129">app</a>，就是一个很好的Quartz 2D例子。</p>

<p>当你的程序进行位图绘制时，不管使用哪种方式，都是基于Quartz 2D的。也就是说，CPU通过Quartz 2D绘制。尽管Quartz可以做其他事情，但是我们这里还是集中于位图绘制，比如在缓存(一块内存)绘制位图会包括RGBA数据。</p>

<p>比方说，我们要画一个八角形，我们通过UIKit能做到这一点</p>

<pre><code>UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
[path addLineToPoint:CGPointMake(0.4, 18.05)];
[path addLineToPoint:CGPointMake(18.8, -0.47)];
[path addLineToPoint:CGPointMake(37.21, 18.05)];
[path addLineToPoint:CGPointMake(34.31, 20.83)];
[path addLineToPoint:CGPointMake(20.88, 7.22)];
[path addLineToPoint:CGPointMake(20.88, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 7.22)];
[path closePath];
path.lineWidth = 1;
[[UIColor redColor] setStroke];
[path stroke];
</code></pre>

<p>Core Graphics 的代码差不多</p>

<pre><code>CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
CGContextAddLineToPoint(ctx, 0.4, 18.05);
CGContextAddLineToPoint(ctx, 18.8, -0.47);
CGContextAddLineToPoint(ctx, 37.21, 18.05);
CGContextAddLineToPoint(ctx, 34.31, 20.83);
CGContextAddLineToPoint(ctx, 20.88, 7.22);
CGContextAddLineToPoint(ctx, 20.88, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 7.22);
CGContextClosePath(ctx);
CGContextSetLineWidth(ctx, 1);
CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
CGContextStrokePath(ctx);
</code></pre>

<p>问题就是，绘制到哪里呢？ 这就是CGContext做的事情。我们传递的ctx这个参数。这个context定义了我们绘制的地方。如果我们实现了CALayer的-drawInContext:方法。我们传递了一个参数context。在context上面绘制，最后会在layer的一个缓存里面。我们也可以创建我们自己的context，比如 CGBitmapContextCreate（）。这个函数返回一个context，然后我们可以传递这个context，然后在刚刚创建的这个context上面绘制。</p>

<p>这里我们发现，UIKit的代码并没有传递context。这是因为UIKit或AppKit的context是隐形的。UIKit和UIKit维护着一个context栈。这些UIKit的方法始终在最上面的context绘制。你可以使用UIGraphicsPushContext（）和 UIGraphicsPopContext（）来push和pop对应的context。</p>

<p>UIKit有一个简单的方式，通过 UIGraphicsBeginImageContextWithOptions（） 和 UIGraphicsEndImageContext()来创建一个位图context，和 CGBitmapContextCreate（）一样。混合UIKit和 Core Graphics调用很简单。</p>

<pre><code>UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2);
CGContextRef ctx = UIGraphicsGetCurrentContext();
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
...
CGContextStrokePath(ctx);
UIGraphicsEndImageContext();
</code></pre>

<p>或其他方式</p>

<pre><code>CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo);
CGContextScaleCTM(ctx, 0.5, 0.5);
UIGraphicsPushContext(ctx);
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
...
[path stroke];
UIGraphicsPopContext(ctx);
CGContextRelease(ctx);
</code></pre>

<p>通过 Core Graphics可以做很多有趣的事情。苹果的文档有很多例子，我们这里就不太细说他们了。但是Core Graphics有一个非常接近Adobe Illustrator和Adobe Photoshop如何工作的绘图模型，并且大多数工具的理念翻译成Core Graphics了。毕竟这就是NextStep一开始做的。</p>

<h1>CGLayer</h1>

<p>一件非常值得提起的事，便是CGLayer。它经常被忽视，并且它的名字有时会造成困惑。他不是Photoshop中的图层的意思，也不是Core Animation中的层的意思。</p>

<p>把CGLayer想象成一个子context。它共用父context的所有特性。你可以独立于父context，在它自己的缓存中绘制。并且因为它跟context紧密的联系在一起，CGLayer可以被高效的绘制到context中。</p>

<p>什么时候这将变得有用呢?如果你用Core Graphics来绘制一些相当复杂的，并且部分内容需要被重新绘制的，你只需将那部分内容绘制到CGLayer一次，然后便可绘制这个CGLayer到父context中。这是一个非常优雅的性能窍门。这和我们前面提到的离屏绘制概念有点类似。你需要做出权衡，是否需要为CGLayer的缓存申请额外的内存，确定这是否对你有所帮助。</p>

<h1>像素（Pixels）</h1>

<p>屏幕上面的像素是通过3个颜色组成的：红，绿，蓝。因此位图数据有时候也被成为RGB数据。你可能想知道这个数据在内存中是什么样子。但是实际上，有非常非常多的方式。</p>

<p>后面我们会提到压缩，这个和下面讲得完全不一样。现在我们看一下RGB位图数据。RGB位图数据的每一个值有3个组成部分，红，绿，蓝。更多的时候，我们有4个组成部分，红，绿，蓝，alpha。这里我们讲4个组成部分的情况。</p>

<h1>默认的像素布局</h1>

<p>iOS和OS X上面的最通常的文件格式是32 bits-per-pixel (bpp),8 bits-per-component (bpc)，alpha会被预先计算进去。在内存里面像这个样子</p>

<pre><code>  A   R   G   B   A   R   G   B   A   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这个格式经常被叫做ARGB。每一个像素使用4个字节，每一个颜色组件1个字节。每一个像素有一个alpha值在R，G，B前面。最后RGB分别预先乘以alpha。如果我们有一个橘黄的颜色。那么看上去就是 240，99，24. ARGB就是 255，240，99，24 如果我们有一个同样的颜色，但是alpha是0.33，那么最后的就是 ARGB就是 84，80，33，8</p>

<p>另一个常见的格式是32bpp，8bpc，alpha被跳过了。</p>

<pre><code>x   R   G   B   x   R   G   B   x   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这个也被称为xRGB。像素并没有alpha（也就是100%不透明），但是内存结构是相同的。你可能奇怪为什么这个格式很流行。因为如果我们把这个没用的字节从像素中去掉，我们可以节省25%的空间。实际上，这个格式更适合现代的CPU和图像算法。因为每一个独立的像素和32字节对齐。现代CPU不喜欢读取不对其的数据。算法会处理大量的位移，特别是这个格式和ARGB混合在一起的时候。</p>

<p>当处理xRGB时，Core Graphic也需要支持把alpha放到最后的格式，比如RGBA，RGBx（RGB已经预先乘以alpha的格式）</p>

<h1>深奥的布局</h1>

<p>大多数时候，当我们处理位图数据时，我们就在使用Core Graphic 或是 Quartz 2D。有一个列表包括了所有的支持的文件格式。让我们先看一下剩余的RGB格式。</p>

<p>有16bpp，5bpc，不包括alpha。这个格式比之前节省50%空间（2个字节一个像素）。但是如果解压成RGB数据在内存里面或是磁盘上面就有用了。但是，因为只有5个字节一个像素，图像特别是一些平滑的渐变，可能就混合到一起了。（图像质量下降）。</p>

<p>还有一个是64bpp，16bpc，最终为128bpp，32bpc，浮点数组件(有或没有alpha值)。它们分别使用8字节和16字节，并且允许更高的精度。当然，这会造成更多的内存和更复杂的计算。</p>

<p>最后，Core Graphics 也支持一些其他格式，比如CMYK，还有一些只有alpha的格式，比如之前提到的遮罩。</p>

<h1>平面数据 （Planar Data color plane）</h1>

<p>大多数的框架（包括 Core Graphics）使用的像素格式是混合起来的。这就是所谓的 planar components, or component planes。每一个颜色组件都在内存中的一个区域。比如，对于RGB数据。我们有3个独立的内存空间，分别保存红色，绿色，和蓝色的数值。</p>

<p>在某些情况下，一些视频框架会使用 Planar Data。</p>

<h1>YCbCr</h1>

<p>YCbCr 是一个常见的视频格式。同样有3个部分组成（Y，Cb，Cr）。但是它更倾向于人眼识别的颜色。人眼是很难精确识别出来Cb和Cr的色彩度。但是却能很容易识别出来Y的亮度。在相同的质量下，Cb和Cr要比Y压缩的更多。</p>

<p>JPEG有时候把RGB格式转换为YCbCr格式。JPEG单独压缩每一个color plane。当压缩YCbCr格式时，Cb和Cr比Y压缩得更好。</p>

<h1>图片格式</h1>

<p>iOS和OSX上面的大多数图片都是JPEG和PNG格式。下面我们再了解一下</p>

<h1>JPEG</h1>

<p>每个人都知道JPEG，他来自相机。他代表了图片是图和存储在电脑里，即时是你的妈妈也听过JPEG。</p>

<p>大家都认为JPEG就是一个像素格式。就像我们之前提到的RGB格式一样，但是实际上并不是这样。</p>

<p>真正的JPEG数据变成像素是一个非常复杂的过程。一个星期都没有办法讲清楚，或是更久。对于一个color plane， JPEG使用一种离散余弦变换的算法。讲空间信息转换为频率（convert spatial information into the frequency domain）。然后通过哈夫曼编码的变种来压缩。一开始会把RGB转换成YCbCr，解压缩的时候，再反过来。</p>

<p>这就是为什么从一个JPEG文件创建一个UIImage然后会知道屏幕上面会有一点点延迟的原因。因为CPU正在忙于解压图片。如果每个TableViewCell都需要解压图片的话，那么你的滚动效果就不会平滑。</p>

<p>那么，为什么使用JPEG文件呢？因为JPEG可以把图片压缩的非常非常好。一个没有压缩过的IPhone5拍照的图片差不多24MB。使用默认的压缩设置，这个只有2-3MB。JPEG压缩效果非常好，因为几乎没有损失。他把那些人眼不能识别的部分去掉了。这样做可以远远的超过gzip这样的压缩算法。但是，这个仅仅在图片上面有效。因为，JPEG依赖于丢掉那些人眼无法识别的数据。如果你从一个基本是文本的网页截取一张图片，JPEG就不会那么高效，压缩效率会变得低下。你甚至都可以看出图片已经变形了。</p>

<h1>PNG</h1>

<p>PNG读作“ping”，和JPEG相反，他是无损压缩的。当你保存图片成PNG时，然后再打开。所有的像素数据和之前的完全一样。因为有这个限制，所有PNG压缩图片的效果没有JPEG那么好。但是对于app中的设计来说，比如按钮，icon，PNG就非常适合。而且PNG的解码工作要比JPEG简单很多。</p>

<p>在真实的世界里面，事情没有这么简单。有很多不同的PNG格式。维基百科上面有很多细节。但是简单说，PNG支持压缩有alpha或是没有alpha通道的RGB像素，这也就是为什么他适合app上面的原因。</p>

<h1>格式挑选</h1>

<p>当在app中使用颜色是，你需要使用者2种格式中得一个，PNG和JPEG。他们的解码和压缩算法都是被高度硬件优化的。有些情况甚至支持并行计算。同时Apple也在不断地提高解码的能力在未来的操作系统版本中。如果使用其他格式，这可能会对你的程序性能产生影响，而且可能会产生漏洞，因为图像解码的算法是黑客们最喜欢攻击的目标。</p>

<p>已经讲了好多有关<a href="https://duckduckgo.com/?q=%22optimizing%20PNG%22">PNG</a>的优化了，你可以在互联网上面自己查找。这里需要注意一点，Xcode的压缩算法和大部分的压缩引擎不一样。</p>

<p>当Xcode压缩png时，技术上来说，已经不是一个有效的PNG文件了。但是iOS系统可以读取这个文件，然后比通常的PNG图片处理速度更快。Xcode这样做，是为了更好地利用解码算法，而这些解码算法不能在一般的PNG文件上面适用。就像上面提到的，有非常多的方法去表示RGB数据。而且如果这个格式不是iOS图形图像系统需要的，那么就需要增加额外的计算。这样就不会有性能上的提高了。</p>

<p>再抢到一次，如果你可以，你需要设置 resizable images。你的文件会变得更小，因此，这样就会有更小的文件需要从文件系统里面读取，然后在解码。</p>

<h1>UIKit and Pixels</h1>

<p>UIKit中得每一个view都有自己的CALayer，一般都有一个缓存，也就是位图，有一点类似图片。这个缓存最后会被绘制到屏幕上面。</p>

<h1>-drawRect：</h1>

<p>如果你的自定义view的类实现了-drawRest：，那么就是这样子工作的：</p>

<p>当你调用-setNeedsDisplay时，UIKit会调用这个view的层的 -setNeedsDisplay方法。这个设置一个标记，表明这个层已经脏了（dirty，被修改了）。实际上，并没有做任何事情，所以，调用多次-setNeedsDisplay 没有任何问题。</p>

<p>当渲染系统准备好后，会调用层的-display方法。这时，层会设置缓存。然后设置缓存的Core Graphics的上下文环境（CGContextRef）。后面的绘制会通过这个CGContextRef绘制到缓存中。</p>

<p>当你调用UIKit中的函数，比如UIRectFill() 或者 -[UIBezierPath fill]时，会通过这个CGContextRef调用你的drawRect方法。他们是通过把上面的CGContextRef push 到 图形图像堆栈中，也就是设置成当前的上下文环境。UIGraphicsGetCurrent（）会返回刚才push的那个context。由于UIKit绘制方法使用UIGraphicsGetCurrent（），所以这些绘制会被绘制到缓存中。如果你希望直接使用 Core Graphics 方法，那么你需要调用UIGraphicsGetCurrent（）方法，然后自己手动传递context参数到Core Graphics的绘制函数中去。</p>

<p>那么，一个个层的缓存都会被绘制到屏幕上面，知道下一次设置-setNeedsDisplay，然后再重新更新缓存，再重复上面的过程。</p>

<h1>不使用 drawRect</h1>

<p>当你使用UIImageView的时候，有一点点的不同。这个view依然包含一个CALayer，但是这个层并不会分配一个缓存空间。而是使用CGImageRef作为CALayer的contents属性，渲染系统会把这个图片绘制到帧的缓存，比如屏幕。</p>

<p>这个情况下，就没有继续绘制的过程了。我们就是简单的通过传递位图这种方式把图片传递给UIImageView，然后传递给Core Animation，然后传递给渲染系统。</p>

<h1>使用drawRect 还是不使用drawRect</h1>

<p>听上去不怎么样，但是，最快速的方法，就是不使用。</p>

<p>大多数情况，你可以通过自定义view或是组合其他层来实现。可以看一下Chris的文章，有关<a href="http://www.objc.io/issue-3/custom-controls.html">自定义控件</a>。这个方法是推荐的，因为UIKit非常高效。</p>

<p>当你需要自定义绘制的时候 <a href="https://developer.apple.com/videos/wwdc/2012/?id=506">WWDC2012 session 506 Optimizing 2D Graphics and Animation Performance</a>是一个非常好的例子 。</p>

<p>另一个地方需要自定义绘制的是iOS的股票软件。这个股票图是通过Core Graphics实现的。注意，这个只是你需要自定义绘制，并不是一定要实现drawRect函数，有时候通过UIGraphicsBeginImageContextWithOptions（）或是 CGBitmapContextCreate（）创建一个额外的位图，然后再上面绘制图片，然后传递给CALayer的contents会更容易。下面有一个测试<a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html#concurrent-drawing">例子</a></p>

<h1>单色</h1>

<p>这是一个简单的例子</p>

<pre><code>// Don't do this
- (void)drawRect:(CGRect)rect
{
    [[UIColor redColor] setFill];
    UIRectFill([self bounds]);
}
</code></pre>

<p>我们知道为什么这样做很烂，我们让Core Animation创建了一个额外的缓存，然后我们让Core Graphics 在缓存上面填充了一个颜色。然后上传给了GPU。</p>

<p>我们可以不实现-drawRect:函数来省去这些步骤。只是简单的设置view的backgroundColor就好了。如果这个view有CAGradientLayer，那么同样的方法也可以设置成渐变的颜色。</p>

<h1>可变大小的图片（resizable image）</h1>

<p>你可以简单的通过可变大小的图片减少图形系统的工作压力。如果你原图上面的按钮大小是300*50。那么就有 600 * 100 = 60k 像素 * 4 = 240KB的内存数据需要传递给GPU。传递给显存。如果我们使用resizable image。我们可以使用一个 52 * 12 大小的图片，这样可以节省10kb的内存。这样会更快。</p>

<p>Core Animation 通过 contentsCenter 来resize图片，但是，更简单的是通过 -[UIImage resizableImageWithCapInsets:resizingMode:]。</p>

<p>而且，在第一次绘制的时候，我们并不需要从文件系统读取60K像素的PNG文件，然后解码。越小的图片解码越快。这样，我们的app就可以启动的更快。</p>

<h1>并发绘制</h1>

<p><a href="http://www.objc.io/issue-2/index.html">上一个</a>我们讲到了并发。UIKit的线程模型非常简单，你只能在主线程使用UIKit。所以，这里面还能有并发的概念？</p>

<p>如果你不得不实现-drawRect:，并且你必须绘制大量的东西，而这个会花费不少时间。而且你希望动画变得更平滑，除了在主线程中，你还希望在其他线程中做一些工作。并发的绘图是复杂的，但是除了几个警告，并发的绘图还是比较容易实现的。</p>

<p>你不能在CAlayer的缓存里面做任何事情出了主线程，否则不好的事情会发生。但是你可以在一个独立的位图上面绘制。</p>

<p>所有的Core Graphics的绘制方法需要一个context参数，指定这个绘制到那里去。UIKit有一个概念是绘制到当前的context上。而这个当前的context是线程独立的。</p>

<p>为了实现异步绘制，我们做下面的事情。我们在其他队列（queue，GCD中的概念）中创建一个图片，然后我们切换到主队列中把结果传递给UIImageView。这个技术被<a href="https://developer.apple.com/videos/wwdc/2012/?id=211">WWDC 2012 session 211</a>中提到</p>

<pre><code>- (UIImage *)renderInImageOfSize:(CGSize)size;
{
    UIGraphicsBeginImageContextWithOptions(size, NO, 0);

    // do drawing here

    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return result;
}
</code></pre>

<p>这个函数通过UIGraphicsBeginImageContextWithOptions 创建一个新的CGContextRef。这个函数也修改了当前的UIKit的context。然后可以铜鼓UIKit的方法绘制，然后通过UIGraphicsGetImageFromCurrentImageContext（）根据位图数据生成一个UIImage。然后关闭掉创建的这个context。</p>

<p>保证线程安全是非常重要的，比如你访问UIKit的属性，必须线程安全。如果你在其他队列调用这个方法，而这个方法在你的view类里面，这个事情就可能古怪了。更简单的方法是创建一个独立的渲染类，然后当触发绘制这个图片的时候才设置这些必须得属性。</p>

<p>但是UIKit的绘制函数是可以在其他队列中调用的，只需要保证这些操作在 UIGraphicsBeginImageContextWithOptions（） 和 UIGraphicsEndImageContext （）之前就好。</p>

<p>你可以通过下面的方法触发绘制</p>

<pre><code>UIImageView *view; // assume we have this
NSOperationQueue *renderQueue; // assume we have this
CGSize size = view.bounds.size;
[renderQueue addOperationWithBlock:^(){
    UIImage *image = [renderer renderInImageOfSize:size];
    [[NSOperationQueue mainQueue] addOperationWithBlock:^(){
        view.image = image;
    }];
}];
</code></pre>

<p>注意view.image = image; 必须在主队列调用。这是非常重要的细节。你不能在其他队列中调用。</p>

<p>通常来说，异步绘制会带来很多复杂度。你需要实现取消绘制的过程。你还需要限制异步操作的最大数目。</p>

<p>所以，最简单的就是通过NSOperation的子类来实现renderInImageOfSize方法。</p>

<p>最后，有一点非常重要的就是异步设置UITableViewCell 的content有时候很诡异。因为当异步绘制结束的时候，这个Cell很可能已经被重用到其他地方了。</p>

<h1>CALayer的奇怪和最后</h1>

<p>现在你是到了CALayer某种程度上很像GPU中的纹理。层有自己的缓存，缓存就是一个会被绘制到屏幕上的位图。
大多数情况，当你使用CALayer时，你会设置contents属性给一个图片。这个意思就是告诉 Core Animation，使用这个图片的位图数据作为纹理。 如果这个图片是PNG或JPEG，Core Animation 会解码，然后上传到GPU。</p>

<p>当然，还有其他种类的层，如果你使用CALayer，不设置contents，而是这事background color，  Core Animation不会上传任何数据给GPU，当然这些工作还是要被GPU运算的，只是不需要具体的像素数据，同理，渐变也是一个道理，不需要把像素上传给GPU。</p>

<h1>图层和自定义绘制</h1>

<p>如果CALayer或是子类实现了 -drawInContext 或是-drawLayer:inContext delegate。Core Animation会为这个layer创建一个缓存，用来保存这些函数中绘制的结果。这些代码是在CPU上面运行的，结果会被传递给GPU。</p>

<h1>形状和文本层（Shape and Text Layers）</h1>

<p>形状和文本层会有一点不同。首先，Core Animation 会为每一个层生成一个位图文件用来保存这些数据。然后Core Animation 会绘制到layer的缓存上面。如果你实现了-drawInContext方法，结果和上面提到的一样。最后性能会受到很大影响。</p>

<p>当你修改形状层或是文本层导致需要更新layer的缓存时，Core Animation会重新渲染缓存，比如。当实现shape layer的大小动画时，Core Animation会在动画的每一帧中重新绘制形状。</p>

<h1>异步绘制</h1>

<p>CALayer 有一个属性是 drawsAsynchronously。这个似乎看上去很不错，可以解决所有问题。实际上虽然可能会提高效率，但是可能会让事情更慢。</p>

<p>当你设置 drawsAsynchronously = YES 后，-drawRect: 和 -drawInContext: 函数依然实在主线程调用的。但是所有的Core Graphics函数（包括UIKit的绘制API，最后其实还是Core Graphics的调用）不会做任何事情，而是所有的绘制命令会被在后台线程处理。</p>

<p>这种方式就是先记录绘制命令，然后在后台线程执行。为了实现这个过程，更多的事情不得不做，更多的内存开销。最后只是把一些工作从主线程移动出来。这个过程是需要权衡，测试的。</p>

<p>这个可能是代价最昂贵的的提高绘制性能的方法，也不会节省很多资源。</p>

<h1>翻译吐槽</h1>

<p>这篇文章实在是太长了，而且太啰嗦了。真是累觉不爱。觉得侮辱读者智商，不过内容还是非常值得学习的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译：《iOS7 新功能 视图控制器API》]]></title>
    <link href="http://studentdeng.github.com/blog/2013/11/19/ios7-viewcontroller/"/>
    <updated>2013-11-19T18:12:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/11/19/ios7-viewcontroller</id>
    <content type="html"><![CDATA[<p>这篇文章投稿在 <a href="http://blog.jobbole.com/51588/">伯乐在线</a></p>

<p>原文出处: <a href="http://www.objc.io/issue-5/view-controller-transitions.html">objc</a></p>

<h1>View Controller Transitions</h1>

<p><a href="http://www.objc.io/issue-5/index.html">Issue #5 iOS 7</a>, October 2013</p>

<p>作者 <a href="http://twitter.com/chriseidhof">Chris Eidhof</a></p>

<h1>自定义动画</h1>

<p>iOS7对我来说最激动人心的特性就是新的 View Controller Transitioning API。 iOS7之前，View Controller之间切换，我需要创建自定义的transitions。 而且这些方法都支持不完整，让人头疼。在transitions中增加交互功能就更难了。</p>

<p>在开始这篇文章之前，我要提醒一下：这是一个新的API，我们尽最大努力让他可以实用，但是并不能保证是最佳。可能需要至少一个月后才能确定，这篇文章是不是最佳的实用方案，这里只是一个对新功能的探索。如果有更好的使用这个API的方法，请联系我们，这样就可以修正这篇文章。</p>

<p>在开始介绍这个API之前，我们需要知道导航控制器的默认行为在iOS7下已经改变了：导航控制器下，切换2个view controller的动画有一点细微的改变，变得更有交互性。例如，当你希望弹出一个view controller时，可以从屏幕左边开始拖动，把整个内容拖动到屏幕右边。</p>

<p>让我们仔细看一下这个API，我发现这个被重度使用的接口是协议并不是一个实体。虽然一上来看上去有一点怪，但是我喜欢这个API，它给了我们更多的灵活性。我们从简单开始：用自定义动画代替原有的view controller的push动画（这里是<a href="https://github.com/objcio/issue5-view-controller-transitions">sample project</a> 在github）。我们首先需要实现这个新的 UINavigationControllerDelegate 方法：</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
               navigationController:(UINavigationController *)navigationController
    animationControllerForOperation:(UINavigationControllerOperation)operation
                 fromViewController:(UIViewController*)fromVC
                   toViewController:(UIViewController*)toVC
{
    if (operation == UINavigationControllerOperationPush) {
        return self.animator;
    }
    return nil;
}
</code></pre>

<p>我们可以观察一下这种类型的操作（push 和 pop）返回一个不同的 animator。如果我们分享代码的话，这个可能是一个对象。我们可能需要把这个变量通过property保存下来。我们也可以为不同的操作创建不同的对象，这里有很高的灵活性。</p>

<p>让这个动画运行起来，我们创建一个自定义对象实现 UIViewControllerContextTransitioning 协议。</p>

<pre><code>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end
</code></pre>

<p>这个协议要求我们实现2个方法，其中一个是描述动画的执行时间</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    return 0.25;
}
</code></pre>

<p>另一个是描述动画的执行。</p>

<pre><code>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    [[transitionContext containerView] addSubview:toViewController.view];
    toViewController.view.alpha = 0;

    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
        toViewController.view.alpha = 1;
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];

    }];

}
</code></pre>

<p>这里你可以看到这个协议是怎么用的：没有提供实体的对象参数，而是通过这个类型 id<UIViewControllerContextTransitioning> 得到transitionContext
唯一的最重要的东西就是在完成动画之后要调用 completeTransition 这个告诉 transitionContext 我们已经完成动画并且相应的更新了 view controller的状态。其他代码是标准的，我们通过transitionContext得到2个UIViewController，然后使用简单的 UIView 动画，这里我们很简单的做了一个zooming的动画</p>

<p>注意，我们只是写了push的自定义动画，当view controller pop时,iOS系统还是会使用默认的滑动动画。而且，实现这个方法后。导航栏也不能交互了（就是从左到右拖动实现pop view controller）。下面完善他</p>

<h1>交互动画</h1>

<p>让之前的动画变得能够交互起来非常简单。我们需要实现另一个UINavigationControllerDelegate</p>

<pre><code>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
{
    return self.interactionController;
}
</code></pre>

<p>注意，如果在一个不能交互的动画中，这里会返回nil。（译注：当不能交互时 self.interactionController 为 nil）</p>

<p>interactionController是UIPercentDrivenInteractionTransition的实例，没有必要更多的设置。我们通过创建拖动手势（UIPanGestureRecognizer）来实现：</p>

<pre><code>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
    }
} 
</code></pre>

<p>只有当用户在屏幕右边操作时，我们才设置动画是可以交互的（通过设置interactionController 属性）。然后我们调用performSegueWithIdentifier（或是不用storyboards，直接push view controller）
在这个手势变化中，我们调用interactionController 的一个方法 updateInteractiveTransition:</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
    [interactionController updateInteractiveTransition:d];
} 
</code></pre>

<p>这里根据拖动的距离设置百分比，非常cool的事情是交互控制器（interactionController）和 动画控制器（animation controller）相互协作。而且因为是普通的 UIView 动画，它控制着动画的进程。我们不需要处理他们之前的事情，
所有的事情都在背后默默的自动搞定了。</p>

<p>最后，当手势停止或是取消掉，我们需要调用interaction controller相应的方法</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
        [interactionController finishInteractiveTransition];
    } else {
        [interactionController cancelInteractiveTransition];
    }
    navigationControllerDelegate.interactionController = nil;
}
</code></pre>

<p>当切换动画完毕时，设定interactionController为nil非常重要。如果下一个动画是非交互的，我们不希望得到一个奇怪的 interactionController</p>

<p>现在我们已经有一个完整的自定义的可交互的过度变换（transition）了。通过普通的拖动手势和一个UIKit提供的实体对象，几行代码就搞定了。对于大多数的自定义交互过度变换，你可以在这里停下来，用上面提到的方法做任何你想做得动画
或是交互。</p>

<h1>GPUImage自定义动画</h1>

<p>我们现在已经能够实现一个完整的自定义动画了，可以不用UIView 甚至Core Animation，做自己喜欢的动画。一开始，我用Core Image实现了一个项目<a href="http://www.macstories.net/featured/a-conversation-with-loren-brichter/">Letterpress-style</a>。但是在我的旧iPhone4上面只能跑到大约9FPS，这个和我所期望的60FPS差距太大了。</p>

<p>但是当我使用<a href="https://github.com/BradLarson/GPUImage">GPUImage</a>后，实现一个非常漂亮的自定义动画效果变得非常简单。我们希望这个动画能够做到像素级的消融在2个view controller切换的时候。这个是通过分别对2个view controller 截屏，然后应用GPUImage的图片滤镜实现的。</p>

<p>首先，我们创建一个自定义类，实现animation 和 interactive transition 协议。</p>

<pre><code>@interface GPUImageAnimator : NSObject
  &lt;UIViewControllerAnimatedTransitioning,
   UIViewControllerInteractiveTransitioning&gt;

@property (nonatomic) BOOL interactive;
@property (nonatomic) CGFloat progress;

- (void)finishInteractiveTransition;
- (void)cancelInteractiveTransition;

@end
</code></pre>

<p>为了让这个动画跑的飞快，我们只把图片传给GPU一次，然后把所有的图像处理绘制交给GPU，而不是传给CPU（GPU和CPU之间的数据传输非常慢）。通过GPUImageView，我们可以用OpenGL绘制动画效果（不需要手动编写底层的OpenGL代码，我们可以继续编写上层代码）</p>

<p>创建这样的滤镜链非常方便。这里可以看一下下面的例子。有一点挑战的是实现动态的滤镜。GPUImage不能给我们直接提供动画效果。这里我们通过在每一帧的时候更新滤镜来实现动画的绘制。我们使用CADisplayLink类来做这个。</p>

<pre><code>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
</code></pre>

<p>在frame:方法中，我们根据时间更新动画进度，然后更新滤镜</p>

<pre><code>- (void)frame:(CADisplayLink*)link
{
    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
    self.blend.mix = self.progress;
    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
    [self triggerRenderOfNextFrame];
}
</code></pre>

<p>以上就是我们所有要讲得了。在交互变换中，我们需要确保我们的进度是根据手势识别设置的，而不是根据时间。但是剩下的代码几乎都一样了。</p>

<p>这个真的太强大了，你可以使用GPUImage提供的任何滤镜或是自己写的OpenGL代码来实现上面的效果。</p>

<h1>小结</h1>

<p>我们这里仅仅提到了导航控制器下面的2个 view controller 之间的动画，事实上你可以做相同的事情在tabbar controller 或是自定义的container view controller。而且 UICollectionViewController 现在已经可以在layout上面自动实现交互动画了。他们都是使用相同的机制。这个真的太强大了。</p>

<p>当我和<a href="https://twitter.com/orta">Orta</a>提到这个API时，他指出他已经使用这个功能创建了一些轻量级的view controller。不要在每一个view controller 保存管理动画的代码，而是创建一个新的view controller，然后实现2个view controlller视图切换时的自定义的动画效果。</p>

<h1>更多</h1>

<ul>
<li><a href="http://asciiwwdc.com/2013/sessions/218">WWDC: Custom Transitions using View Controllers</a></li>
<li><a href="http://www.teehanlax.com/blog/custom-uiviewcontroller-transitions/">Custom UIViewController transitions</a></li>
<li><a href="http://www.doubleencore.com/2013/09/ios-7-custom-transitions/">iOS 7: Custom Transitions</a></li>
<li><a href="http://whoisryannystrom.com/2013/10/01/View-Controller-Transition-Orientation/">Custom View Controller Transitions with Orientation
</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一次马拉松，也是这段时间健身的总结]]></title>
    <link href="http://studentdeng.github.com/blog/2013/11/17/sports-nov/"/>
    <updated>2013-11-17T21:41:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/11/17/sports-nov</id>
    <content type="html"><![CDATA[<h1>第一次接力马拉松</h1>

<p>11月16日是个特别的日子，健身满16个月，更重要的是参加了人生第一次马拉松，香山接力赛，平均坡度35，一次往返3km，一个队伍4个人，每人4圈，每人总共12km。时间从上午11点，跑到下午4点。16个月前，当我开始准备减肥的时候，我从来没有想过可以一口气做6个引体向上，没有想过可以一口气600多个仰卧起坐，也没有想过我的胸围可以长5cm，没有想过我的腰围可以减少12cm，没有想到我可以减40斤，更没有想过，我居然有了参加山地马拉松的能力，虽然仅仅是接力赛。</p>

<p>说道马拉松，不得不多说几句，跑一次全程马拉松是我30岁前必须完成的人生目标之一。为了方便去香山，15日我暂住一个朋友家，在14日在家的时候，我开心的一晚上睡不着觉，弄得我不得不担心我会不会因为过于兴奋而导致体力消耗太大最后不能完赛。好在16日的时候，我已经完全调整过来，而且老天也特别配合，PM2.5出奇的低，给我一个风和日丽的早上。整个比赛还算轻松，或是对自己要求不够高吧，除了第一圈比较吃力以外，后面越来越好，特别是最后一圈，如果再给我一次机会，我会更努力的跑。</p>

<h1>16个月运动统计</h1>

<p>说了这么多虚的，这是我运动的统计，由于没有想到过自己能够坚持这么长时间，统计只是从2013年4月5日开始到今天。总共226天的时间其中健身160.73小时,下面是每个月的运动时间统计，纵坐标单位分钟。</p>

<p><img src="http://studentdeng.github.com/images/sports-nov1.png" alt="image" /></p>

<p>一个月的维度已经很大了。这个充分说明，即便我已经有了这样大的运动效果，16个月，我的健身习惯还没有真正的养成，不管是计划制定，还是执行层面，因为一个习惯的正常曲线应该是这样子的。</p>

<p><img src="http://studentdeng.github.com/images/sports-nov2.png" alt="image" /></p>

<p>这是我的英语听写计划时间统计，英语计划相对健身更简单可控。记得有一本书中写道，一个成熟的人制定的计划是稳步递增的，而那些年轻人的计划，往往都是大起大落。好吧，这里就不嘲笑自己了。</p>

<p>很多人都问我，坚持下来的原因是什么，这个真的很难说，在一开始的时候，想法总是很简单的，和很多人一样，希望更好看一点，更健壮一点。但是如果一直是这么简单的想法，必然不能长久，很多东西会在这个改变的过程中加入进来，甚至变成最重要的东西。反之也会有很多东西变得不那么重要最后离我而去。现在来说，最大的原因在于我的性格上的变化。这半年来，我性格上面最大的变化就是变得越来越goal oriented， 在健身的过程中，最能体现的就是一个个目标达成的幸福感，这个让我非常开心，因为就目前我能做的事情来看，像健身这种只要做，就比不做强的事情，而且还有不少附加价值的实在是少之又少。</p>

<h1>意志力</h1>

<p>健身的过程的确是很苦的，当然这个世界上被认为有价值的习惯都是很难达到，需要花费大量的时间，不仅是健身，还是英语我实际花费的时间都比上面统计的要多的多。比如你可能需要学习做饭，你可能需要控制饮食，我在减脂的3个月中，几乎不吃肉，把一切零食，甜食，饮料当成毒药。忌口对于我这种意志力薄弱的人来说，真的是相当的难。不管是再好吃的东西，要做到能够停下来，或是坚决不吃。一个朋友说过这样子的话“我常常把吃得放在一边，人必须学会控制自己的嘴巴，这是一种训练意志力的方式，因为很简单，如果自己的嘴巴都控制不了，还指望她能做点什么”。这个怎么说呢，话粗理不粗吧。我反正是不同意这个观点，但是喜欢这个做事态度。</p>

<p>说道意志力，让我想起了施瓦辛格说的一句话“健身的精髓在于力竭后的最后一个”，同样还有很多类似的话“马拉松比赛在20km之后才开始”。对现在的我来说，健身在跑完5km，或是300个仰卧起坐，或是300个深蹲又或是10组pull ups，俯卧撑，推胸之后才真正开始，之前做得一切运动都只是为了积累身体疲劳到一定程度,这样才能有意义，因为力竭之后的动作，才是给身体最好的信号“我要变得更强壮”。</p>

<p>讲锻炼意志力的书有很多很多，方法也很多很多，在健身的方面，我最喜欢的就是P90X里面教练提到的方法，另外我增加了最后面一条。</p>

<p>1、设定目标
2、达成目标
3、记录下来
4、忘掉它</p>

<h3>设定目标</h3>

<p><strong>设定目标</strong>的动机很明白，跑马拉松的时候，大家不会设定一个终点这样的目标，而是将这个过程分解成一个弯角，一段斜坡。同样力量训练也是分成25个一组的小重量，8-12个的大重量。设定目标最大得作用在于clear your mind and focus on the things。</p>

<h3>达成目标</h3>

<p><strong>达成目标</strong>，这个毋庸置疑，目标就是要被达成的。</p>

<h3>记录下来</h3>

<p>前2个一般人都可以做到，但是后面的2个才是真正的精髓。在任何过程中都会产生迷茫，哪怕是改变一个小小的习惯，因为不管怎样你都无法逃避掉一个问题“How to be better XXX”。<strong>记录下来</strong>就是为了这个准备的。我是那种容易消极的人，数据让我不会把一些局部失败看得太重，把局部成功看得太重。这一点对我帮助很大，我看到了我最近3个月器械力量增大一倍，但是整体时间依然波动很大等等这些都是帮助我抵抗不良情绪最好的良药。</p>

<h3>忘掉它</h3>

<p><strong>忘掉它</strong>是一个很神奇的东西，在跳出舒适区的过程中，特别有用。比如你已经做了500多个仰卧起坐，每一个都已经burning，如果你脑子里面想得是我已经做了500个了，一般人200个都做不了，那么就很难做到600+。忘掉它是一种归零的心态，每一组动作都是一个新的起点，新的开始。也是对抗懒惰最好的良药，特别是我这种对自己要求比较低，喜欢放纵自己的人。我是真的对自己要求低，特别是在健身上面。我见过非常多的人一起跑步的时候吐过，一起踢球的时候抽筋过，也亲眼见过跑步训练跑到眼底角膜充血的，也见过做yoga把腿都拉伤的，很多很多的例子。而我则是被教练说“你就是对自己要求太低”，“你之前炼过吧，额，你怎么不跑了？还有5圈呢？”，从小到大一直都是。</p>

<h1>后记</h1>

<p>健身已经从一开始的甩掉大肚子，变成了我生活的一部分或是他本身就是我生活的缩影。在香山认识了也见识了很多牛人，有骑行川藏的，海拔5000km，有跑戈壁滩的，一天30km，连续跑4天的。而他们有的甚至平均年龄高达45岁。除了这些已经几乎bt的人以外，也有30大几的已婚姐姐锻炼成“钢筋铁骨”的，相比而言我这25岁的“小娃娃”，记得当时我开始健身的时候，最大的原因就在于，我已经25岁了，老了，而且我之前2次减肥失败，这次再不减肥肯定就完蛋了的心态。呵呵，现在想起来还是蛮好笑的。虽然人的确在经过25岁之后，心肺，肌肉等等身体各项机能都会开始退化开始衰老，更容易产生脂肪，但是我很开心，在我25岁的时候，我所做的一切。身体和灵魂，至少有一个需要在路上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stanford 算法课 part 2 Scheduling]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/16/algo-class-02-scheduling/"/>
    <updated>2013-09-16T20:46:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/16/algo-class-02-scheduling</id>
    <content type="html"><![CDATA[<p>当一个人每天都有做不完的事情时，不知道大家又没有这种感觉。各种各样的事情，各种deadline，甚至是一些无关紧要的琐碎事情也会不断的在大脑中被回想，而且还是反复的，没有任何理由的会冒出来。对像我这样非常懒惰的人来说，这就是一个非常致命的打击，因为我需要中断当前的事情，这会让我多消耗不少脑力。。。</p>

<p>这应该算是时间管理中的一部分，如何给自己安排任务。人的大脑和电脑的工作模式还是有一些类似的，比如如果一直不断的记录一大堆事情而不是执行，那么就会影响到他们的工作效率。同样，如果重要的事情不作，最后也会不断的在大脑里面被回想，而造成效率降低。</p>

<p>在我看来，解决这些回想问题最关键的事情就是把这些东西搞定，这样才能把大脑清空，然后去做那些更加有意义的事情。</p>

<p>最近再跟algorithm part2里面正好有一个scheduling application的东西，挺有意思的。这里记录一下。</p>

<h1>问题描述</h1>

<h2>Setup</h2>

<p>scheduling 的基本模型是有一个shared resource，比如CPU。但是有许多jobs，比如很多线程，需要使用CPU才能运行。</p>

<h2>Question</h2>

<p>我们应该如何调度这个jobs的顺序，哪一个job优先于其他job执行，从而让整个计划执行时间最少。</p>

<h2>Assume</h2>

<p>为了更清楚的定义数学模型，每一个job有2个维度。</p>

<ul>
<li>weight 重要性</li>
<li>length 时间</li>
</ul>


<h2>Defintion</h2>

<p>Completion time。 第J个任务的完成时间（Completion time）Cj 是 （任务J之前的等待时间 + 任务J的length）* 任务J的weight</p>

<h1>思路</h1>

<p>这里根据直觉可以很明显的知道 我们需要把重要的事情放在前面，把时间短的事情放置在前面，这样可以很快的打一个勾勾，清空大脑中的这个任务。也就是说Cj 和 Wj 正相关，和 Lj负相关。但是总是有一些事情让人欲罢不能，就是那些很重要，而且做起来还比较费劲，时间花费长的事情，和那些不重要但是时间花费短的事情。真实世界的事情太复杂，还是回到我们这个简单的模型中。</p>

<p>一种常见的思维是设法将问题转换成之前我们已经解决了的思路之中，所以很容易想到我们需要找到单位长度中最重要的事情先做。因为我们的这个模型的任务调度不是抢占式的么。</p>

<p>将上面的单位时间的含义翻译过来就是 wj / lj。 也就是我们的调度程序将按照w / l的值，从大到小排列
<img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_01.png" alt="scheduling 1" /></p>

<p>这里我们假定任务i > j。这个图则表示这2个任务相连在一起，stuff表示之前的任务，more stuff表示之后的任务。</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_02.png" alt="scheduling 2" /></p>

<p>而这里，我们做一次任务i、j的交换，就像这样</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_03.png" alt="image" /></p>

<p>那个这2个scheduling中，i,j之前的任务的完成时间不会变，之后的任务完成时间也不会变。那么受到影响的只是任务i，j。</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_04.png" alt="image" /></p>

<p>那么这里显然scheduling 2 也就是后面的那张图的顺序比第一个要小。</p>

<p>然后我们可以想象最后的任务流程，就如果冒泡排序一样，一次次的比较把相对重要的数据一次次的放置到前面。</p>

<p>而当所有相邻的任务都按照这样的规则排列完毕后，得到的就是一个 wj / lj 的从大到小的序列。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[calm down]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/15/calm-down/"/>
    <updated>2013-09-15T23:03:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/15/calm-down</id>
    <content type="html"><![CDATA[<p>最近已经发生了很多事情，将来也会发生一些事情，这里为了不让我负能量爆发，就不写这些细节了。昨天和老大聊到晚上3点半，这里我还很dt的查了一下，上一次聊这么晚也就是2个月前。刚刚突然发现有人赞了一下我的微博，哦，很好，长出一口气，终于不是强X的无脑赞了。微博的内容是一篇关于《女人明白要趁早》的读书笔记，书里写过一句这样的话“这世上只有快乐的猪和悲伤的哲学家”，但在我看来，还有另一类人是悲伤的猪，而我显然属于后者。当然这不是我想说的，书中有一些这样的话。</p>

<p>“当你一无所知、一无所有、一无所成的时候,没事不要去想“个人尊严”和“个人价值”这 类虚词儿。一、做好眼前事。二、假以时日。 有完美榜样是好的,能让我们矢志不渝地去为追求完美努力;知道榜样其实不完美也是好的, 避免我们成为偏执狂,或者因为目标难以企及而自暴自弃。”</p>

<p>这个世界上面充斥这这样子的言论，你没有办法去反驳它，因为他本身说的就是事实，是正确的，而且是毫无疑问正确的，但是如果只是做到这些是不可能成功，或是更严格讲，这些都不是成功的关键因素，从心理学角度来看，这些话没有办法被证伪。这些话就是一个个成功人士为了安慰屌丝们的心灵鸡汤而已。</p>

<p>对于年轻的人们来说，经历的苦难和挫折大概都是因为阅历，资历不足，内心却比地球还大，一开始就像构建一艘航空母舰。但最后发现这样的航母根本做不出来，或是做出来随便小小的浪头就能把它拍的粉碎。而也有不少人意识到了这一点，做出了一艘艘驱逐舰，潜艇。但最后发现，光这艘船，根本不可能带你穿过那些暴风雨频发的海域。</p>

<p>我们害怕跌入日复一日平淡庸碌的结婚、生子、还房贷、终老一生的生活中去。但是现实就是这个社会最不缺的就是空想家，社会不仅不看你的想法，不在意你的未来，更不在意你的过去，只是看你的现在，你的所作所为。你所能掌握的资源，你能做出多少选择的能力。</p>

<p>大家都会成长，会慢慢看淡这些ups and downs，大家都在说，现在社会多么浮躁，年轻人要学会等待，假以时日，每天坚持，就会变好的。我只想说“呵呵”。平静会很容易的掩饰内心的平庸，诚然平静很重要，但绝对不是逃避，需要cope，而这需要一个强大的内心。只有内心足够强大才能做出抵挡风浪的船，而不是随流漂动的木板，虽然他们都是在水上浮着，当然木板也有好处，船会翻。木板不会。</p>

<p>一个朋友曾今问过我为什么给自己设定一个30岁的目标，因为有太多的东西我们不能左右，在到一定年纪就不得不考虑，作为一个男孩子，不得不去承担一些该来的责任，那么自由时间必定要被压缩，而且有一些事情，年纪大了，也就错过机会了，或是需要付出比年轻时候更多的投入。所以必须趁年轻，因为在再不疯狂就来不及了。</p>

<p>Tal在幸福课中提到一句，平庸和卓越在表面都很平静时是如何区分出来。卓越的人更会相信自己会做到。</p>

<p>额，本来还是想写下去，发现自己已经不知不觉开始写心灵鸡汤了，看来我已经被毒害不少了，再删掉一大段之后，思路瞬间被阻塞了。一阵阵困意袭来，呼~，昨天睡得有一点少了。今天最开心的就是，去东直门上了一节跳舞课，按照我以往对我自己的了解，我应该死宅在家里才对，绝对不会出门，更别说走这么远。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocoapods 入门]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/13/cocoapods-tutorial/"/>
    <updated>2013-09-13T23:48:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/13/cocoapods-tutorial</id>
    <content type="html"><![CDATA[<h1>介绍</h1>

<p>最近一直在搞<a href="https://github.com/CocoaPods/CocoaPods">cocoapods</a>。 ios 这么多年终于有一个好使的包管理了。真的好激动好激动。。。
之前开发一些App的时候，在一开始的时候，总是需要手动添加framework， library，设置一些 search path，有时候还会忘记那么几个，然后出来一大堆的link error。当一些library更新的时候，还需要自己手动去更换。3句话说就是</p>

<ol>
<li>手动增加framework，library</li>
<li>手动增加编译参数</li>
<li>手动维护代码更新</li>
</ol>


<p>完全是一大堆的体力活，当然，这些简单的配置和复制并不会花费太多的时间，但是，还是觉得在浪费生命，而这时候CocoaPods就出来了。我们只需要设置一个Podfile文件，执行</p>

<pre><code>$ pod install 
</code></pre>

<p>CocoaPods会帮我们下载好代码，设置好编译参数，配置好framework， library。</p>

<h1>安装和更新</h1>

<pre><code>$ sudo gem install cocoapods
</code></pre>

<h1>使用</h1>

<p>在project根目录下，create Podfile文件，下面一个例子</p>

<pre><code>platform :ios, '5.0'
pod 'CURestKit', '~&gt;1.0.1' 
pod 'SDWebImage','~&gt;3.4'
pod 'MBProgressHUD', '~&gt; 0.7'
pod 'UALogger', '~&gt; 0.2.3'
</code></pre>

<p>CocoaPods 会帮我们从git clone下来配置好的这些代码。后面的部分表示代码的版本号，一般来说和tag挂钩。</p>

<p>配置好Podfile之后，执行</p>

<pre><code>$ pod install
</code></pre>

<p>则会帮我们配置好这些项目。并生成一个XXXX.xcworkspace。 以后project使用这个文件就可以了。CocoaPods其实就是帮我们配置一个静态库作为项目的依赖。</p>

<p>CocoaPods里面有大量的代码，现在最新的版本安装后是在这里</p>

<pre><code>~/.cocoapods/repo/master/ 
</code></pre>

<h1>制作自己的项目配置</h1>

<p>实际开发过程中，我们还有不少代码需要被改动，而CocoaPods上面的代码，大部分都比较旧，都是很稳定的代码，当然也有一些不能用的（大部分是国内的公司做的，大家都懂的）。另外还有一些我们自己写的一些其他代码，暂时还么有被CocoaPods收录的。这时候我们就需要配置自己的项目啦。</p>

<p>这里是我的一个项目配置例子。cocoapods的配置文件就是一个 *.podspec的文件，这是一个例子文件名ShareCenter.podspec。这是一个典型的ruby，</p>

<pre><code>Pod::Spec.new do |s|
s.name         = "ShareCenter"
s.version      = "2.0"
s.summary      = "share client include sina weibo ,tencent weibo, renren"

s.description  = &lt;&lt;-DESC
               share client include sina weibo ,tencent weibo, renren
               DESC

s.homepage     = "https://github.com/studentdeng/ShareCenterExample"
s.license      = 'MIT'
s.author       = { "curer" =&gt; "studentdeng@hotmail.com" }
s.platform     = :ios, '5.0'

s.source       = { :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git", :tag =&gt; s.version.to_s }
s.source_files  = 'ShareCenter', 'ShareCenter/**/*.{h,m}'

s.frameworks   = 'QuartzCore', 'Security', 'CoreGraphics', 'AudioToolbox'
s.library = 'sqlite3.0'
s.vendored_libraries = 'ShareCenter/Vender/sina/libWeiboSDK/libWeiboSDK.a'

s.prefix_header_contents = &lt;&lt;-EOS
#ifdef __OBJC__
#import "ROConnect.h"
#endif /* __OBJC__*/
EOS
end
</code></pre>

<p>这个基本上都是自解释的，这里有几个需要说明一下</p>

<h2>s.source s.source_files</h2>

<p>这里的 <em>source</em> 我们看出是一个git 的地址，这里我们调试的时候，可以先暂时设置成本地git，调试完毕之后就可以发布 增加tag。想要最新的代码只需要这样设置就好</p>

<pre><code>{ :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git"}
</code></pre>

<p>我们的git项目中，并不是所有的代码都需要被引用到我们的代码中，通常project还会包括一些example，test cases等，这里的 <em>source_files</em> 就是用来指定一些文件夹，或是文件。我这里的设置也很容易理解，就是ShareCenter下面的递归后的所有后缀是h、m的子文件。</p>

<h2>s.frameworks s.library</h2>

<p>这里配置的就是我们的framework 和 library，这里注意一下library的名字规则就好。</p>

<h2>vendored_libraries</h2>

<p>这里用来指定外部的静态库。这里我们指定了sina sso认证的SDK</p>

<h2>s.prefix_header_contents</h2>

<p>这里用来指定预编译的配置，这里一定要鄙视一下renren的超级渣渣SDK。这里提供一种解决方法。</p>

<h2>部署我们的配置到cocoapods中</h2>

<p>cocoapods的代码配置文件是在这里<a href="https://github.com/CocoaPods/Specs">Specs</a></p>

<p>这里最好是去fork一个自己的project，然后保存一个自己或是团队的配置，这样不会在更新cocoapods的时候，丢掉自己的配置。当然，如果觉得自己搞的还不错，也可以去pull requests。</p>

<p>在之前提到的目录<em>~/.cocoapods/repo/master/</em> 下面，我们可以看到已经有超级多的项目了，我们可以也可以通过</p>

<pre><code>$ pod search XXX
</code></pre>

<p>来查找项目，或是直接在这个文件夹下面找，可以学习不少project的配置技巧，我这里也是从他们学到的。</p>

<p>最后添加一个project的配置是这样子的。</p>

<p>例如上面的例子，
在<em>~/.cocoapods/repo/master/</em> 下面创建一个文件夹ShareCenter，然后在创建一个2.0的文件夹表示这是version2.0的配置。
然后在把之前的ShareCenter.podspec复制到2.0目录下面。</p>

<p>也就是最后的目录是这样子的</p>

<pre><code>~/.cocoapods/repo/master/ShareCenter/2.0/ShareCenter.podspec
</code></pre>

<p>如果希望更多的了解cocoapods，还是需要去<a href="https://github.com/CocoaPods/CocoaPods">Github</a>上面 :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis服务器启动流程]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/19/redis-start-up/"/>
    <updated>2013-08-19T10:26:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/19/redis-start-up</id>
    <content type="html"><![CDATA[<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<p>让我们从 redis.c -> main() 开始</p>

<h1>读取配置文件</h1>

<p>在初始化完毕一些系统时间之后，redis开始初始化服务器配置。</p>

<h2>initServerConfig</h2>

<p>在这个函数中，初始化全局变量</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>struct redisServer 结构体描述了服务器的状态。这种庞大的数据结构实在是看的烦躁。
这里可以很方便的看到redis的系统默认配置。另外还初始化了系统命令表。</p>

<pre><code>server.commands = dictCreate(&amp;commandTableDictType,NULL);
populateCommandTable();
</code></pre>

<p>这里我们可以找到redis的命令所对应的函数名称。</p>

<pre><code>struct redisCommand redisCommandTable[] = {
    {"get",getCommand,2,"r",0,NULL,1,1,1,0,0},
    {"set",setCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setnx",setnxCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setex",setexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"psetex",psetexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
    //...
}


struct redisCommand {
    // 命令的名字
    char *name;
    // 命令的实现函数
    redisCommandProc *proc;
    // 命令所需的参数数量
    int arity;
    // 字符形式表示的 FLAG 值
    char *sflags; /* Flags as string represenation, one char per flag. */
    // 实际的 FLAG 值，由 sflags 计算得出
    int flags;    /* The actual flags, obtained from the 'sflags' field. */
    /* Use a function to determine keys arguments in a command line.
     * Used for Redis Cluster redirect. */
    // 可选，在以下三个参数不足以决定命令的 key 参数时使用
    redisGetKeysProc *getkeys_proc;
    /* What keys should be loaded in background when calling this command? */
    // 第一个 key 的位置
    int firstkey; /* The first argument that's a key (0 = no keys) */
    // 第二个 key 的位置
    int lastkey;  /* THe last argument that's a key */
    // 两个 key 之间的空隔
    int keystep;  /* The step between first and last key */
    // 这个命令被执行所耗费的总毫秒数
    long long microseconds;
    // 这个命令被调用的总次数
    long long calls;
};
</code></pre>

<p>这里可以看出，redis的命令配置，保存在底层数据结构dic中。</p>

<h1>服务器初始化</h1>

<h2>initServer</h2>

<p>这里设置信号回调函数，和继续初始化</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>结构外，创建了SharedObjects。</p>

<h3>createSharedObjects</h3>

<pre><code>initServer-&gt;createSharedObjects
</code></pre>

<p>redis这里将除了把一些常用的字符串保存起来，目的就是为了减少不断申请释放时CPU时间，内存碎片等等,常用的返回客户端的命令，消息等。如</p>

<pre><code>shared.ok = createObject(REDIS_STRING,sdsnew("+OK\r\n"));
shared.err = createObject(REDIS_STRING,sdsnew("-ERR\r\n"));

//...

shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(
    "-WRONGTYPE Operation against a key holding the wrong kind of value\r\n"));
//...
</code></pre>

<p>还初始化了一个很大的共享数字对象。</p>

<pre><code>#define REDIS_SHARED_INTEGERS 10000

for (j = 0; j &lt; REDIS_SHARED_INTEGERS; j++) {
    shared.integers[j] = createObject(REDIS_STRING,(void*)(long)j);
    shared.integers[j]-&gt;encoding = REDIS_ENCODING_INT;
}
</code></pre>

<h3>aeCreateEventLoop</h3>

<pre><code>initServer-&gt;aeCreateEventLoop



/* Include the best multiplexing layer supported by this system.
* The following should be ordered by performances, descending. */
#ifdef HAVE_EVPORT
    #include "ae_evport.c"
#else
    #ifdef HAVE_EPOLL
        #include "ae_epoll.c"
    #else
        #ifdef HAVE_KQUEUE
            #include "ae_kqueue.c"
        #else
            #include "ae_select.c"
        #endif
    #endif
#endif
</code></pre>

<p>接下来创建eventloop。这里调用 aeApiCreate 创建event loop。redis这里根据不同平台会选择不同的event方式，
Linux 使用epoll，BSD上面使用kqueue，其他选择select</p>

<h3>初始化网络连接</h3>

<pre><code>if (server.port != 0) {
    server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);
    if (server.ipfd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening port %d: %s",
            server.port, server.neterr);
        exit(1);
    }
}

if (server.unixsocket != NULL) {
    unlink(server.unixsocket); /* don't care if this fails */
    server.sofd = anetUnixServer(server.neterr,server.unixsocket,server.unixsocketperm);
    if (server.sofd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening socket: %s", server.neterr);
        exit(1);
    }
}
</code></pre>

<h3>创建系统cron定时器</h3>

<pre><code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);

aeCreateTimeEvent
aeCreateTimeEvent accepts the following as parameters:
eventLoop: This is server.el in redis.c
milliseconds: The number of milliseconds from the current time after which the timer expires.
proc: Function pointer. Stores the address of the function that has to be called after the timer expires.
clientData: Mostly NULL.
finalizerProc: Pointer to the function that has to be called before the timed event is removed from the list of timed events.
</code></pre>

<p>aeCreateTimeEvent 创建一个定时器，redis会在这个serverCron中清理系统变量，判断是否需要写入文件等操作。</p>

<h3>在event loop中绑定回调函数</h3>

<pre><code>if (server.ipfd &gt; 0 &amp;&amp; aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,
    acceptTcpHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.ipfd file event.");            
</code></pre>

<h1>设置启动event loop</h1>

<pre><code>// 设置事件执行前要运行的函数
aeSetBeforeSleepProc(server.el,beforeSleep);

// 启动服务器循环
aeMain(server.el);

// 关闭服务器，删除事件
aeDeleteEventLoop(server.el);
</code></pre>

<p>aeMain函数和之前用的很多的windows中的message queue非常相似。redis不断循环等待执行event。这里不论是定时器还是socket event，都会在这个event loop中被执行。</p>

<pre><code>void aeMain(aeEventLoop *eventLoop) {

eventLoop-&gt;stop = 0;

while (!eventLoop-&gt;stop) {

    // 如果有需要在事件处理前执行的函数，那么运行它
    if (eventLoop-&gt;beforesleep != NULL)
        eventLoop-&gt;beforesleep(eventLoop);

    // 开始处理事件
    aeProcessEvents(eventLoop, AE_ALL_EVENTS);
    }
}
</code></pre>

<p>方便整理，这里重复一下一开始的流程图</p>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<h1>处理客户端命令流程</h1>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/request-response.png" alt="处理客户端命令流程图" /></p>

<p>之前我们已经注册了socket acceptTcpHandler 回调函数，现在的流程是</p>

<pre><code>acceptTcpHandler-&gt;acceptCommonHandler-&gt;createClient-&gt;aeCreateFileEvent

if (aeCreateFileEvent(server.el, c-&gt;fd, AE_READABLE,
    readQueryFromClient, c) == AE_ERR) {
    freeClient(c);
    return NULL;
}
</code></pre>

<p>这里又向event loop中加入一个新的事件callback函数：aeCreateFileEvent 用于把event loop中的监听的事件和回调函数绑定在一起。</p>

<p>readQueryFromClient 则是客户端一切命令的入口函数。</p>

<pre><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
    redisClient *c = (redisClient*) privdata;
    char buf[REDIS_IOBUF_LEN];
    int nread;
    // ...

    nread = read(fd, buf, REDIS_IOBUF_LEN);
    // ...
    if (nread) {
        size_t oldlen = sdslen(c-&gt;querybuf);
        c-&gt;querybuf = sdscatlen(c-&gt;querybuf, buf, nread);
        c-&gt;lastinteraction = time(NULL);
        /* Scan this new piece of the query for the newline. We do this
        * here in order to make sure we perform this scan just one time
        * per piece of buffer, leading to an O(N) scan instead of O(N*N) */
        if (c-&gt;bulklen == -1 &amp;&amp; c-&gt;newline == NULL)
            c-&gt;newline = strchr(c-&gt;querybuf+oldlen,'\n');
    } else {
        return;
    }
    Processinputbuffer(c);
}
</code></pre>

<p> readQueryFromClient读取客户端命令，交给Processinputbuffer处理。</p>

<pre><code>void processInputBuffer(redisClient *c) {
    //...

    if (processCommand(c) == REDIS_OK)
        resetClient(c);
}

int processCommand(redisClient *c) {
    //...
    call(c,REDIS_CALL_FULL);
}
</code></pre>

<p>这里call回根据command定义的callback函数，执行相对应的redis命令代码。</p>

<p>当command执行完毕之后，准备将结果传递给客户端。这里可以看到注册了sendReplyToClient回调函数。</p>

<pre><code>int prepareClientToWrite(redisClient *c) {
    if (c-&gt;flags &amp; REDIS_LUA_CLIENT) return REDIS_OK;
    if (c-&gt;fd &lt;= 0) return REDIS_ERR; /* Fake client */
    if (c-&gt;bufpos == 0 &amp;&amp; listLength(c-&gt;reply) == 0 &amp;&amp;
        (c-&gt;replstate == REDIS_REPL_NONE || c-&gt;replstate == REDIS_REPL_ONLINE) &amp;&amp;
        aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR)
            return REDIS_ERR;
    return REDIS_OK;
}
</code></pre>

<p>读到这里，我们已经看到了。redis在处理event loop的时候，不仅仅是处理客户端的连接，很多redis内部的流程也是通过event loop实现的。这个是event driven常常遇到的方式。</p>

<p>内容资料、图片、代码参考</p>

<ul>
<li><a href="https://github.com/huangz1990/annotated_redis_source">huangz的redis2.6代码注释</a></li>
<li><a href="http://pauladamsmith.com/articles/redis-under-the-hood.html#back-up-to-main">Redis: under the hood</a></li>
<li><a href="http://redis.io/topics/internals-rediseventlib">Redis Event Library</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box2d 05 RevoluteJoint and b2WeldJoint]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/08/box2d-05/"/>
    <updated>2013-08-08T15:11:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/08/box2d-05</id>
    <content type="html"><![CDATA[<p>资料代码，思路来自 <a href="http://www.raywenderlich.com/4756/how-to-make-a-catapult-shooting-game-with-cocos2d-and-box2d-part-1">raywenderlich</a>。这个只是自己学习时的笔记，非原创。</p>

<h1>b2RevoluteJoint</h1>

<ul>
<li>将刚体固定在一个点上，刚体可以围绕这个点旋转</li>
<li>可以提供马达，提供刚体旋转的动力</li>
</ul>


<p>所以，通过b2RevoluteJoint的第一个特性，我们可以很方便的模拟跷跷板。而第二个特性，我们可以很方便的实现汽车运动，或是弹弓类似的东西，今天实现一个类似疯狂小鸟的demo</p>

<p>创建b2RevoluteJoint很简单，但是里面有一些属性还是让人比较纠结，特别是好多中文blog，不知道是笔误还是无心，都是错的 =, =!</p>

<pre><code>b2RevoluteJointDef armJointDef;
armJointDef.Initialize(groundBody, armBody, b2Vec2(233.0 / PTM_RATIO, FLOOR_HEIGHT / PTM_RATIO));

armJointDef.enableLimit = true;
armJointDef.lowerAngle = CC_DEGREES_TO_RADIANS(9);
armJointDef.upperAngle = CC_DEGREES_TO_RADIANS(75);

armJointDef.enableMotor = true;
armJointDef.maxMotorTorque = 200;
armJointDef.motorSpeed = - 10;

armJoint = (b2RevoluteJoint *)world-&gt;CreateJoint(&amp;armJointDef);
</code></pre>

<p>这3个很好理解，就是对我们的旋转做限制。单位是弧度。</p>

<ul>
<li>enableLimit</li>
<li>lowerAngle</li>
<li>upperAngle</li>
</ul>


<p>这3个稍微不好理解</p>

<ul>
<li>enableMotor：     表示是否开启我们的旋转马达</li>
<li>motorSpeed：      表示我们希望马达给我们提供的速度是多少，小于0表示顺时针</li>
<li>maxMotorTorque：  表示马达给我们提供的扭矩有多少。</li>
</ul>


<p>简单的说，就是maxMotorTorque为我们提供改变速度的力。motorSpeed表示我们希望达到的最大速度是多少。</p>

<h1>b2WeldJoint</h1>

<p>b2WeldJoint又是一个很好理解的连接器。b2WeldJoint通过一个点把2个刚体绑定在一起运动。</p>

<pre><code>b2WeldJointDef weldJointDef;
weldJointDef.Initialize(bulletBody, armBody, b2Vec2(230.0f/PTM_RATIO,(155.0f+FLOOR_HEIGHT)/PTM_RATIO));
weldJointDef.collideConnected = false;

bulletJoint = (b2WeldJoint*)world-&gt;CreateJoint(&amp;weldJointDef);
</code></pre>

<p>在弹弓实例下，我们可以将炮弹绑定在我们的发射架上，当发射架运动到一定角度时，我们可以释放这个连接器，炮弹就可以射出了。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/05">source code</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTkzMzI0ODAw" frameborder=0 allowfullscreen></iframe>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跳跃表 skip list]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/08/skip-list/"/>
    <updated>2013-08-08T09:51:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/08/skip-list</id>
    <content type="html"><![CDATA[<p>最近在学习<a href="http://redis.cn">redis</a>，这时才知道了<a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>，结合<a href="http://v.163.com/movie/2010/12/7/S/M6UTT5U0I_M6V2TTJ7S.html">Mit 算法导论 lecture 12</a>，在奋斗了2个早上的时间后有了下面的东东。</p>

<p>对于我们熟悉的binary search来说，我们需要能够做到random access才行。但是在普通的link这种数据结构中却不能做到。而这种情况下我们有很多类似的工具比如heap，tree，b tree，red－black tree。等等类似的都是来自AVL的变种。但是说实话，这些东东，的确是挺难实现的，需要做各种的旋转啊，调整啊，来保持平衡。特别是red－black tree。而这时的skip list 就为我们提供了一个很好的思路。</p>

<h1>introduction</h1>

<p>让我们先从简单的开始</p>

<p><img src="http://studentdeng.github.io/images/skip_list1.png" alt="image" /></p>

<p>如果最下面的数字是已经排序好的数列，我们想要快速查找其中一项，而不是简单的便利。我们可以增加一个link，也就是上面的一条，来让我们能够“跳过”一些元素，也就是减少一些不必要的比较。</p>

<p>那么在2条时，我们的访问程度是多少呢？L2 + L1 / L2, 也就是第二条link的个数+ 每一个小端个数，这个是最差情况。显然，让这个不等式和最小，需要 L2 = L1 / L2。 显然L1是一个定值。这里设为N,那么，2条link下，我们的查找复杂度是 2 * √n</p>

<p>如何再优化呢？这个思路很简单，就是在L2上面再构建一个link L3. 整个时间也就是 L3 ＋ L2 ／ L3 ＋ L1 ／ L2 ，根据不等式性质，他们的和最小时，也就是 L3 ＝ L2 ／ L3 ＝ L1 ／ L2。当L1 ＝ N时，他们的和时 3 * 立方根（N）</p>

<p><img src="http://studentdeng.github.io/images/skip_list_l3.png" alt="image" /></p>

<p>当第k层时， 我们的时间则是 k * k次方跟（N）</p>

<p>当k = lgN 时，我们的时间为 lgN * lg 次方跟（N），根据对数的换底公式，我们可以得出 时间是 2lgN. 哈，我们现在已经降到O(lgN).我们满足了。</p>

<p>这时我们可以想象一下，这个skip list的结构，其实就是一个binary tree。我们通过最上面的一层访问类似跟节点的情况，然后一层层link 相当于tree的孩子节点，整个比较过程和binary search 非常的相似。</p>

<h1>insert</h1>

<p>对于这些结构来说，搞定search不是难点，插入和删除则是最麻烦的东西。这里我们可以自己思考一下，为了保证我们的link的结构足够完美，可能需要记录没一段的个数，然后我们可能有一些节点要上几层或是下几层。但是这个其实，本质上和那些avl树又一样了。skip list则是基于一种随机的策略来决定这些节点。其实我们可以思考一下，最完美的分法就是和binary tree一样的，所以这种2倍数的关系就可以用抛硬币的方式来决定。</p>

<p>这里为了程序时间方便，我们创建一个无穷小的节点作为我们的其实节点，这样，我们所有的开始都是从最左边。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_01.png" alt="image" /></p>

<p>我们插入一个元素30，这时我们可以判断一下这个新的元素是否需要“升级”，这里我扔了一下，反面，不用升级了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_02.png" alt="image" /></p>

<p>这里我们插入一个15，我扔了一下，反面。不用升级</p>

<p><img src="http://studentdeng.github.io/images/skip_list_03.png" alt="image" /></p>

<p>这里我们插入一个20，我扔了一个正面，又扔了一个正面，额，好吧第三次终于是反面了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_04.png" alt="image" /></p>

<p>这里涉及到了一点点的随机算法的证明，这些东西实在是让人烦躁。主要还是大学时候的概率学得就不咋地，现在也都忘了。从最直观的来看，就是一层层升级的概率会越来越低，在随机算法足够独立和大量的数目上来看，不难形成这样子的一个类似tree的结构。</p>

<h1>delete</h1>

<p>删除这里的操作简直就是blazingly simple,因为我们整个list layer 都是建立在随机上的，删除则是直接删除就好了</p>

<p>我在看到这里，基本已经受不了要吐槽了。实现这个也太简单了，相对red-black tree这种东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stanford 算法课上 Kosaraju algorithm]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/04/algorithms-class4/"/>
    <updated>2013-08-04T23:32:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/04/algorithms-class4</id>
    <content type="html"><![CDATA[<p>强连通图的应用场景我就不在这里赘述了。其中<a href="http://en.wikipedia.org/wiki/Kosaraju's_algorithm">Kosaraju</a>是最常见的一种。</p>

<p>这个也是Stanford 算法课<a href="https://class.coursera.org/algo-004/quiz/attempt?quiz_id=57">弟四周的作业</a>，现在看来是最难的一道题。那么这里我就给一个我自己的实现了。</p>

<p>这个作业的难度就在于他的输入是一个相当大的数据，处理不好，很容易溢出。那份大数据，我没有留在这里，感兴趣的同学可以自己下载。70多M，实在不适合放在github上面。</p>

<p><a href="https://github.com/studentdeng/algorithms_class">source_code</a></p>

<p>由于是xcode的环境，在g++下是过不去的。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apache 压力测试入门]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/03/apache-test/"/>
    <updated>2013-08-03T13:05:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/03/apache-test</id>
    <content type="html"><![CDATA[<p>最近一直想总结一点有关测试服务器性能的东西，今天先写一点入门的小东西了。
网站的stress test 工具很多，这里介绍一个我觉得最简单的webbench</p>

<h2>安装webbench</h2>

<pre><code>wget http://www.ha97.com/code/webbench-1.5.tar.gz
tar zxvf webbench-1.5.tar.gz
cd webbench-1.5
make
make install
</code></pre>

<h2>使用webbench</h2>

<pre><code>webbench -c 1000 -t 60 http://server_address/
</code></pre>

<p>c: 并发数， t 运行时间
下面是测试结果</p>

<pre><code>Speed=2798 pages/min, 53286 bytes/sec.
Requests: 2798 susceed, 0 failed.
</code></pre>

<p>表示 每分钟处理请求2798， 每秒钟传输量53286</p>

<h2>apache 的一点小问题</h2>

<p>前几天换了一个阿里云的服务器，最低配置。内存只有512M，在做测试的时候遇到了一点小问题，这里记录一下。
服务器使用lamp默认配置，在低配置的情况下，我发现在-c 100 的情况下 mysql 就已经crash了。</p>

<p>这里是mysql日志</p>

<pre><code>130803 13:26:40 InnoDB: Initializing buffer pool, size = 128.0M
InnoDB: mmap(137363456 bytes) failed; errno 12
130803 13:26:40 InnoDB: Completed initialization of buffer pool
130803 13:26:40 InnoDB: Fatal error: cannot allocate memory for the buffer pool
130803 13:26:40 [ERROR] Plugin 'InnoDB' init function returned error.
130803 13:26:40 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
130803 13:26:40 [ERROR] Unknown/unsupported storage engine: InnoDB
130803 13:26:40 [ERROR] Aborting
</code></pre>

<p>发现系统内存似乎已经不够用了。
用下面命令查看系统性能</p>

<pre><code>top -i

top - 13:32:45 up 4 days, 18:01,  2 users,  load average: 1.54, 9.10, 8.42
Tasks: 242 total,  74 running, 168 sleeping,   0 stopped,   0 zombie
Cpu(s): 85.1%us, 14.5%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st
Mem:    501892k total,   496672k used,     5220k free,     4000k buffers
Swap:        0k total,        0k used,        0k free,    35128k cached

PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
6527 www-data  20   0  295m  13m 3952 R  2.3  2.8   0:00.75 apache2
6531 www-data  20   0  294m  13m 3204 R  2.3  2.7   0:00.51 apache2
7439 www-data  20   0  293m  12m 3484 R  2.3  2.6   0:00.30 apache2
7441 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.21 apache2
7455 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.14 apache2
7456 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.14 apache2
7463 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.08 apache2
7465 www-data  20   0  294m  13m 3480 R  2.3  2.7   0:00.08 apache2
7466 www-data  20   0  294m  13m 3480 R  2.3  2.7   0:00.08 apache2
6491 www-data  20   0  294m  13m 3204 R  2.0  2.7   0:00.51 apache2
6495 www-data  20   0  294m  13m 3268 R  2.0  2.7   0:00.52 apache2
6526 www-data  20   0  295m  13m 3872 R  2.0  2.9   0:00.57 apache2
6529 www-data  20   0  294m  13m 3212 R  2.0  2.7   0:00.48 apache2
6536 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.48 apache2
6537 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.47 apache2
6538 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.48 apache2
7442 www-data  20   0  293m  12m 3484 R  2.0  2.6   0:00.21 apache2
7458 www-data  20   0  293m  12m 3476 R  2.0  2.6   0:00.13 apache2
7464 www-data  20   0  294m  12m 3480 R  2.0  2.6   0:00.08 apache2
7467 www-data  20   0  294m  13m 3480 R  2.0  2.7   0:00.08 apache2
7468 www-data  20   0  294m  12m 3480 R  2.0  2.6   0:00.08 apache2
6528 www-data  20   0  295m  13m 3884 R  1.7  2.8   0:00.62 apache2
7457 www-data  20   0  293m  12m 3480 R  1.7  2.6   0:00.13 apache2
7469 www-data  20   0  294m  13m 3480 R  1.7  2.7   0:00.07 apache2
7470 www-data  20   0  294m  13m 3480 R  1.7  2.7   0:00.07 apache2
7492 www-data  20   0  293m  12m 3484 R  1.7  2.6   0:00.05 apache2
7484 www-data  20   0  293m  12m 3484 R  1.3  2.6   0:00.04 apache2
…
</code></pre>

<p>一下子看到好多的apache procress，让我大吃一惊。。。可见我有多弱了。。。原来每一个http请求，apache都开了一个进程来处理，而一个进程需要13M的物理内存。 而这一台服务器总共物理内存只有512M</p>

<h2>apache 的工作模式</h2>

<p>apache 的工作模式有几种，我们可以通过下面命令查看</p>

<pre><code>apachectl -l

Compiled in modules:
core.c
mod_log_config.c
mod_logio.c
prefork.c
http_core.c
mod_so.c
</code></pre>

<p>这个表明我们在prefork工作模式下，也是最稳定用的最多的工作模式。
在这个模式下每一个用户的请求都会交给一个进程来处理，但是频繁的创建和销毁进程这种重量级操作降低不少系统性能，所以我们可以通过设置一些参数。但不管怎么样，都是一个请求一个进程。当进程数收到限制时，请求只能等待。而最大的请求书，显然受到系统硬件限制。</p>

<p>我们可以在查看默认配置</p>

<pre><code># prefork MPM
# StartServers: number of server processes to start
# MinSpareServers: minimum number of server processes which are kept spare
# MaxSpareServers: maximum number of server processes which are kept spare
# MaxClients: maximum number of server processes allowed to start
# MaxRequestsPerChild: maximum number of requests a server process serves
&lt;IfModule mpm_prefork_module&gt;
    StartServers          5
    MinSpareServers       5
    MaxSpareServers      10
    MaxClients           150
    MaxRequestsPerChild   0
&lt;/IfModule&gt;
</code></pre>

<p>这个已经说的很清楚了，对于现在的服务器配置，尝试MaxClients 修改成 40</p>

<p>再次查看系统性能</p>

<pre><code>top - 13:44:13 up 4 days, 18:12,  2 users,  load average: 12.10, 6.50, 8.88
Tasks: 209 total,  41 running, 168 sleeping,   0 stopped,   0 zombie
Cpu(s): 91.7%us,  7.9%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st
Mem:    501892k total,   399804k used,   102088k free,     6936k buffers
Swap:        0k total,        0k used,        0k free,    71048k cached 
</code></pre>

<p>这是-c 100 已经没有问题了。</p>

<pre><code>Speed=2780 pages/min, 52868 bytes/sec.
Requests: 2780 susceed, 0 failed.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git 部署代码到服务器]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/30/git-deploy/"/>
    <updated>2013-07-30T22:34:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/30/git-deploy</id>
    <content type="html"><![CDATA[<p>之前常用的部署代码就是用svn，或是更老土的ftp。今天在写一个新玩具的时候，突然发现，每次的git pull实在是一个让人烦躁的东西，就网上查找了一下，整理在这里。<a href="http://toroid.org/ams/git-website-howto">参考原文</a></p>

<p>实现原理是当我们push 代码到remote repository时，通过git的<a href="https://www.kernel.org/pub/software/scm/git/docs/githooks.html">post-receive hooks</a>。执行</p>

<pre><code>git checkout prod -f
</code></pre>

<p>来帮助我们实现自动部署</p>

<p>让我们从最简单的开始，现在<strong>本地创建</strong>一个git repository</p>

<pre><code>$ mkdir test &amp;&amp; cd test
$ git init 
$ echo 'Hello, world!' &gt; index.html
$ echo 'Hello, world!' &gt; index.html
$ git add index.html
$ git commit -q -m "The humble beginnings of my web site."
</code></pre>

<p>index.html 就是我们希望能够部署到服务器的代码</p>

<p>然后在<strong>服务器</strong>创建一个repository, 这里可不是服务器部署代码的位置</p>

<pre><code>$ mkdir test.git &amp;&amp; cd test.git
$ git init --bare
$ cat &gt; hooks/post-receive
#!/bin/sh
GIT_WORK_TREE=/mnt/www/test git checkout prod -f
$ chmod +x hooks/post-receive
</code></pre>

<p>这是服务器的git代码目录</p>

<pre><code>/repo/test.git
</code></pre>

<p>这里的 &#8216;/mnt/www/test&#8217; 就是我们将要部署服务器代码的位置，一般的lamp，我们喜欢放在www里，当然这里需要根据不同的环境更换就好了。</p>

<p>这里我们在<strong>本地</strong>的git目录下增加一个remote</p>

<pre><code>$ git remote add prod ssh://server_address/repo/test.git
$ git push prod +master:refs/heads/master
</code></pre>

<p>server_address 可以ip，域名。</p>

<p>我不太喜欢用这个命令行，我喜欢用<a href="http://www.sourcetreeapp.com">SourceTree</a>来做这个增加remote和最后的commit push 部分。</p>

<p>这时我们切换到<strong>服务器</strong>目录下，就可以看到我们的index.html 在我们向prod push的之后，已经自动check out 到我们指定目录下了。</p>

<p>之后我们只需要修改完成之后，git push prod 就可以自动部署代码了。</p>

<p>第一次用，这里标记一下，看看后面当发生冲突的时候，时一个什么样的情况。： ）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安装环境遇到的dt问题]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/26/tips-install/"/>
    <updated>2013-07-26T17:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/26/tips-install</id>
    <content type="html"><![CDATA[<h1>ruby on rails</h1>

<p>mysql2 image not found
<a href="http://stackoverflow.com/questions/4546698/library-not-loaded-libmysqlclient-16-dylib-error-when-trying-to-run-rails-serv">soluation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box2d 04 多边形刚体和鼠标连接器]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/22/box2d-04/"/>
    <updated>2013-07-22T13:34:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/22/box2d-04</id>
    <content type="html"><![CDATA[<p>我们在真正做一些物体的时候，有一些情况不是标准的圆形，矩形。这时我们需要创建多边形的刚体。这里推荐一个工具<a href="https://github.com/jfahrenkrug/VertexHelper">VertexHelper</a>来帮我们生成刚体的定义。</p>

<p>今天的东西似乎有一点太少了，再瞅瞅另一种连接器，b2MouseJoint——鼠标连接器。
在使用鼠标连接器之前，我们需要找到我们选择的是那一个物体。</p>

<ul>
<li>获取手势的位置，也就是坐标向量</li>
<li>创建一个小的物体，小到只是一个点，然后通过这个物体在物理世界中查找包含这个物体的刚体</li>
</ul>


<p>鼠标连接器的使用步骤
当检测到碰撞时，创建连接器</p>

<pre><code>b2MouseJointDef mouseJointDef;
mouseJointDef.bodyA = groundBody; //通常连接地面
mouseJointDef.bodyB = body;       //需要移动的刚体
mouseJointDef.target = locationWorld; //当前位置
mouseJointDef.maxForce = 1000 * body-&gt;GetMass(); //移动的最大力，这个决定移动的灵敏度
//mouseJointDef.collideConnected = true; //这个场景不需要

self.mouseJoint = (b2MouseJoint *) world-&gt;CreateJoint(&amp;mouseJointDef);
//body-&gt;SetAwake(true);         //很多地方指定了这个，但是我实际测试，这个场景也不需要
</code></pre>

<p>在手势移动的时候重新设置</p>

<pre><code>world-&gt;DestroyJoint(self.mouseJoint);
self.mouseJoint = NULL;
</code></pre>

<p>在手势取消和结束时销毁</p>

<pre><code>world-&gt;DestroyJoint(_mouseJoint);
</code></pre>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/04">demo</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTg2NDQxNzAw" frameborder=0 allowfullscreen></iframe>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box2d 03 b2Joint 连接器]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/20/box2d-03/"/>
    <updated>2013-07-20T13:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/20/box2d-03</id>
    <content type="html"><![CDATA[<p>在真实世界中，一个物体很难孤立的存在，比如一个我们的自行车，2个轮子除了可以自由滚动以外，还必须保证2个轮子之间的距离不变，而保证这个距离不变的就是自行车的大梁。我们的胳膊，需要保证在一定范围的情况下围绕一个点旋转等等。Box2D中 连接器就是用来保证刚体和刚体之间的某种关系而出现的。</p>

<p>我们先认识b2DistanceJoint——距离连接器。</p>

<p><img src="http://www.ladeng6666.com/blog/wp-content/uploads/2012/08/zixingche.jpg" alt="image" /></p>

<p>这是一个自行车的模型bodyA bodyB 就是之前熟悉的圆形刚体，中间的红线是我们的距离连接，anchorA，anchorB 则是连接器连接2个刚体的位置。非常的直观。</p>

<pre><code>b2DistanceJointDef jointDef;
jointDef.Initialize(ballA, ballB, ballA-&gt;GetPosition(), ballB-&gt;GetPosition());

b2DistanceJoint *join = (b2DistanceJoint *)world-&gt;CreateJoint(&amp;jointDef);
CGFloat distance = 30.0 / PTM_RATIO;
join-&gt;SetLength(distance);
</code></pre>

<p>非常的直观，制定连接的位置和距离，就创建完毕了。下面是一个demo，每当触摸屏幕的时候给自行车一个向右的冲量。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/03">demo代码</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTg1MjU2MTQ4" frameborder=0 allowfullscreen></iframe>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Box2D 02 刚体]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/19/box2d-02/"/>
    <updated>2013-07-19T15:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/19/box2d-02</id>
    <content type="html"><![CDATA[<p>刚体的属性有3种。</p>

<ul>
<li>staticBody</li>
<li>kinematicBody</li>
<li><p>dynamicBody</p>

<p>  staticzero mass, zero velocity, may be manually moved</p>

<p>  kinematic: zero mass, non-zero velocity set by user, moved by solver</p>

<p>  dynamic: positive mass, non-zero velocity determined by forces, moved by solver</p></li>
</ul>


<p>简单说就是static 的刚体没有质量，没有速度。
kinematic 的刚体没有质量，但是可以设置速度。
dynamic 的刚体就是之前我们写的小球。有质量有速度。</p>

<p>static 的常常用于游戏中的墙，这种不会移动的，而且不会受到力的作用改变他的位置，速度等。
kinematic 的常常用于游戏中的跳板这些，他们会移动，但是同样不会受到力的作用改变原来的运动轨迹。
dynamic 通常是我们的玩家，敌人。他们会移动，而且会受到力的作用，旋转，碰撞，加速等。</p>

<p>刚写好了几个demo，用来做这几种类型的区分，</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/02">demo代码</a></p>

<div class="video-container">
<iframe height=498 width=510 src="http://player.youku.com/embed/XNTg0OTM0OTg4" frameborder=0 allowfullscreen></iframe>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Box2D 01 基本概念]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/18/box2d-01/"/>
    <updated>2013-07-18T16:05:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/18/box2d-01</id>
    <content type="html"><![CDATA[<p>首先几个概念需要了解一下。</p>

<p><strong>world</strong>
就是engin需要模拟的世界，他有一个大家都很熟悉的重力</p>

<p><strong>body(刚体)</strong>
刚体的定义大家在物理中都熟悉了，在box2D世界中，刚体定义了物体一些重要的属性，比如质点位置，旋转角度，角速度，线性阻尼，等</p>

<p><strong>shape(形状)</strong>这里定义我们的物体的形状是圆的，方的还是多边形等</p>

<p><strong>fixture(材质？这个好难翻译中文)</strong>光是上面的东西，我们不能够完成物理世界的碰撞，fixture定义了几个重要的属性，包括摩擦系数，恢复系数，密度</p>

<p>回想当初学习的物理知识也就这么多了，当然后面还会介绍其他新的东西。有个形状，和密度我们可以计算质量，有了位置，速度，角速度，足够我们计算高中学到的简单碰撞了，在有恢复系数和线性阻尼，我们也能更好的模拟更真实的物理情景，而这也是大学物理的部分了。</p>

<p>好多的背景知识，让我们再看看如何在程序里面做一个真实的世界出来。</p>

<pre><code>b2Vec2 gravity;
gravity.Set(0.0f, -10.0f);
world = new b2World(gravity);
</code></pre>

<p>box2D的坐标是和笛卡尔坐标系一样的，向量 (0, -10) 表示我们真实世界的重力，大约为10米每秒</p>

<p>创建我们的第一个物体，一个圆球。
这里Box2D采用了工厂模式来创建一个我们需要的物体。我们首先描述一个需求，然后通过一个工厂来生产我们需要的产品。</p>

<pre><code>b2BodyDef bodyDef;//
bodyDef.type = b2_dynamicBody; //这里定义为动态刚体
bodyDef.position.Set(pt.x/PTM_RATIO, pt.y/PTM_RATIO);
body = world-&gt;CreateBody(&amp;bodyDef);

b2CircleShape bodyShape;
bodyShape.m_radius = 26.0 / PTM_RATIO; //定义球的半径

b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;bodyShape;
fixtureDef.density = 0.1f;  //密度
fixtureDef.friction = 0.1f; //摩擦力
fixtureDef.restitution = 0.9f; //恢复系数
body-&gt;CreateFixture(&amp;fixtureDef);
</code></pre>

<p>还急得之前的概念么？在定义好body，shape，创建好fixture之后。这些信息已经足够模拟真实运动了。因为是真实的世界，独立各个平台，box2D的单位是米，而不是程序图形图像的单位像素，PTM_RATIO这个宏用于转换单位。</p>

<p>当然，这些物理数据还不能让我们在程序中看到，为了美观，增加一点小东西，希望大家了解cocos2d。这里创建一个CCPhysicsSprite</p>

<pre><code>CCPhysicsSprite *sprite = [CCPhysicsSprite spriteWithFile:@"ball.png"];
[self addChild:sprite];

[sprite setPTMRatio:PTM_RATIO];
[sprite setB2Body:body];

//CCPhysicsSprite 的操作一定要在设置PTMRatio 和 body之后
[sprite setPosition: ccp(pt.x, pt.y)];
</code></pre>

<p>这时我们就可以看到一个小球自由落体，然后淡出世界，不过似乎有一种淡淡的忧伤，太无趣了这个世界。</p>

<p>让我们为这个世界创建一个边界，让小球不要运动超过屏幕。</p>

<pre><code>// Define the ground body.
b2BodyDef groundBodyDef;
groundBodyDef.position.Set(0, 0); // bottom-left corner

// Call the body factory which allocates memory for the ground body
// from a pool and creates the ground box shape (also from a pool).
// The body is also added to the world.
b2Body* groundBody = world-&gt;CreateBody(&amp;groundBodyDef);

// Define the ground box shape.
b2EdgeShape groundBox;      

// bottom

groundBox.Set(b2Vec2(0,0), b2Vec2(s.width/PTM_RATIO,0));
groundBody-&gt;CreateFixture(&amp;groundBox,0);

// top
groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO));
groundBody-&gt;CreateFixture(&amp;groundBox,0);

// left
groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(0,0));
groundBody-&gt;CreateFixture(&amp;groundBox,0);

// right
groundBox.Set(b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,0));
groundBody-&gt;CreateFixture(&amp;groundBox,0);
</code></pre>

<p>这里没有指定其他属性，默认创建的刚体是静态的，不会移动的。而这正是我们想要的。</p>

<p>这时小球会自由落体然后反弹，这时可以调整restitution，如果对这些不是很熟悉的话。但是总体感觉还是有一点无聊，让我们再来一点新东西。</p>

<pre><code>b2Vec2 force = b2Vec2(-30, 30);
body-&gt;ApplyLinearImpulse(force, body-&gt;GetPosition());
</code></pre>

<p>body是我们其中的一个小球。ApplyLinearImpulse的意思就是对body施加一个冲量。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/01">demo地址</a></p>

<div class="video-container">
<iframe height=498 width=510 src="http://player.youku.com/embed/XNTg0NTU4NzQ0" frameborder=0 allowfullscreen></iframe>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运动小结]]></title>
    <link href="http://studentdeng.github.com/blog/2013/07/09/exercise/"/>
    <updated>2013-07-09T08:02:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/07/09/exercise</id>
    <content type="html"><![CDATA[<p>有很多人觉得我能用1年的时间减肥30斤，并保持下来很牛，也许是有一点点的不容易吧。我这里纪录一下自己的心得。</p>

<h2>动力</h2>

<p>改变很难，减肥的确是一件非常难的事情，需要极大的意志力和时间的投入。我最开始的动力，可能说出来挺丢人，是因为自己喜欢的一个女孩，表白失败。然后顿时觉得浑身充满负能量没有地方发泄。再加上那会工作压力不大。然后便开始减肥。办了1年的会员，我告诉所有人，我要把肚子上的赘肉练下去，把胳膊上的肌肉练出来。几乎所有人都告诉我，这是不可能的，可能我脾气倔吧，我就越要把这件事情做好。</p>

<h2>第一个月减了20斤</h2>

<p>开始的第一个月是大家最容易坚持下来的，那会浑身都是负能量，我每天游泳1.5到2km，周末会游的远一点。运动了整整一个月，减了20斤。这个对于当时170斤的我来说，这个运动量已经是身体负荷的极限了，要知道铁人三项其中的游泳项目也就是1.5km。这会计算都有一点害怕，那会我一周累计起来要游泳1W米。。。</p>

<p>另外时间上的成本也很高，那会体力不好，基本上要游泳1个半小时多，加上洗澡的时间和收拾东西的时间，即便游泳池就在楼下这么近的位置，每天都需要花费至少2个小时。所以，可见我当时是有多么的闲。: (</p>

<h2>接下来的10个月</h2>

<p>我的经验是当运动到1个月的时候，是身体最疲劳的时候，懒惰情绪抬头，同时身体的疲劳积累越来越多，1个月就是这样的一个拐点。</p>

<p>1个月后，我不得不调整我的计划，我没有办法再坚持每天游泳的运动量了，我减少了1半，一个星期保证至少去3次，一般4次，每次1.5km，1个小时。体重没有变化，一直在保持，这里有一点很重要，中间因为一些假期休息导致反弹了至少3次，每次至少5斤。</p>

<p>有一些有趣的事情，比如情人节那天，大家都出去约妹子了，孤单的我一个人去游了3km，回来整个人就瘦了7斤。当时自己觉得那些运动节目弱爆了，一个星期减个7斤还要好意思觉得效果不错。当然，副作用非常明显，第二天我就起不了床，连续2天都没有去游泳。: D</p>

<p>在我运动了大概6-7个月的时候，我开始做腹部的训练。之前也曾经做过很多，但都没有能够坚持下来，而这次我准备来真的。一开始我只能做30个，用了一个月的时间到每天180个。和我之前说的一样，1个月是一个门槛，</p>

<p>然后又发生了一件事情，可以说是我人生的又一个拐点吧，和一个女孩分手，大量的负能量转换为了健身的动力，又坚持了4个月，而且加大游泳的运动量，于是我又减了5斤。</p>

<h2>最近5个月</h2>

<p>慢慢快1年了，我减了25斤，并保持了下来。这让我的精神状态得到了超级大的改观，我开始意识到运动给我带来的好处不仅仅是排解负能量。由于投入了大量的时间并形成习惯之后，我觉得我需要做一点变化，来提高我的健身效率。然后我找了健身教练来帮助我制定运动计划。</p>

<p>这个可以说是一个魔鬼计划吧，我先锻炼的是腹部，从一些比较入门的动作，当然这些动作已经比我之前做的动作要难好多了，而且数量也增加，每次做的动作都在200个以上，一周至少3次。一般4次。一个月后，达到了520个。然后随着每次运动量增加，我减少到了每周3次，其中1周2次私教课，我自己练一次，间隔游泳1.5km。也就是每天至少花1个小时健身。</p>

<p>1个月后果然是最难熬的腹部下去了一大块，腰围小了1寸，其实好多时候我都想把运动量减少到一周2次腹肌，其他时间游泳，因为练腹肌实在是太苦逼了，撕裂的疼。</p>

<p>我其实挺不好意思的，因为在我快要坚持不下去的时候，又遇到一个妹子，可能是我还没有从之前的那个人走出来，对妹子挺冷淡的，当我准备进入状态的时候，妹子觉得不合适走了。然后我就又获得了不少负能量，然后又坚持了一个月，每周3-4次，一次520个腹部动作。</p>

<p>然后还是吃素，尽量不吃肉，我需要改善我的体质，否则我坚持不下来这么大的运动量。
这2个月，我又减了5斤。非常不容易的5斤。非常开心，这时候所有人见到我都不得不相信我做到了1年前我说的，我要把肚子上的肉移动到胳膊上面。而且我的确是瘦了好多。</p>

<p>然后我开始纪录我的健身时间和计划。到现在正好3个月。上个月我开始更科学的健身，腹部训练我降到了一周2次，每次300个动作（我更换了新的动作，这300个比之前的520个难多了）。增加了胳膊，肩膀，腿部，背部，肩膀的训练。每天基本上身体挨个部位轮流练，坚持不下去了就去游个1.5km。最近开始做yoga。</p>

<p>这3个月，每个月都锻炼25天以上，每次不少于45分钟，</p>

<p>健身的误区有很多，比如很多妹子都不敢练器械，因为害怕练出肌肉，作为一个坚持做腹肌5个月的家伙来看，练出肌肉绝对没有想象的那么容易，抛开休息，饮食不说，只说运动量，我之前500多个的时候只是热身，如果想要有6块，运动量至少得增加1倍每天差不多1000个，当然，最好换动作，要不太浪费时间。</p>

<p>回头看，我能坚持下来，“妹子”的原因虽然上不了台面，但是的确是真真正正的导火索，感谢她们，让我养成了这样一个好习惯。</p>

<p>写到这里，我又看了一边我的运动时间表。很有意思的，有一周，我几乎从早上忙到晚上12点，每天大概15个小时工作，而我那周，居然健身375分钟.所以忙，只是借口而已。</p>

<p>希望我可以再坚持1年。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[唯一有益的怀旧是想像未来的自己怀旧现在]]></title>
    <link href="http://studentdeng.github.com/blog/2013/06/24/remember/"/>
    <updated>2013-06-24T13:34:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/06/24/remember</id>
    <content type="html"><![CDATA[<p>豆瓣的CEO阿北说过，唯一有益的怀旧是想像未来的自己怀旧现在。很奇葩的，就在几天前，这个事情真真切切的发生在了我的身上。这是我几天前写的，当时以为自己已经工作3年了。我从07年毕业开始计算工作正好2年，从创业的时间开始计算，也就是2年7个月。也就是说，我在半年后的“未来”，回头看了一下自己，瞬间觉得浑身充满正能量，我还有半年的时间去改变。</p>

<p>3年的工作是一个门槛，我这里也算是总结自己3年的经历，也可以说是分享吧。</p>

<p>毕业那会我也许有步入外企的机会，但是最后被cube这个家伙忽悠来了北京，我和cube认识很长时间，我在学校的时候，就和他一起工作了。后来他去了微软，等我大四了，他给我描述了一下他的idea，介绍了一起创业的团队，然后我就被他“骗”来了北京。cube是一个对工作有洁癖的人，他对自己的要求非常高，对parter的要求也非常高，事实上，这个最后被证明对团队是非常错误的。但是，对于一个即将毕业的我来说，则是一段非常好的经历。他为了激发我的热情，总是把有挑战的东西交给我来做，而他则负责扫尾。我们2个算是“结对编程”的经典例子————这是一种在IT领域非常高效的合作方式。而且我的团队给予了我充分的自由空间，真的没有任何要求和约束，完全靠着激情在工作。当然，最后这个也被证明是错误的。</p>

<p>时间飞快的就过了1年，cube当时有一句话，我记得非常清楚，也是我很认同的事情“我要在1年里积累别人3年的经验”。cube对工作非常认真，而且非常喜欢总结和分享。我受他影响很大，也非常喜欢写blog和分享，所以我们在创业的小圈圈里面还算有一点小名气，中间还有出版社找过我问我是否出书，后来也极大的方便我们招人。这是好的事情。</p>

<p>坏的事情就是，这1年过的也算是苦了。没有假期，没有周末，每天工作超过15个小时。但这1年也是我过的最快乐的1年。我的职业规划，完全在我的设想之中。从技能的提高角度来看，几乎不可能比这个做得更好。但是也为我们后来的失败埋下了伏笔，我们的team从来没有一个正式的公司架构，没有想过挣钱，只是觉得，几个哥们一起干，然后拿投资、融资，坐着一夜暴富的白日梦。</p>

<p>我们team算是中国第一批移动互联网创业的小公司了，我们的产品是要做一个类似wechart，米聊的东西。呵呵，现在想起来都觉得疯狂。当然，很现实，我们失败了，我们不得不转去做另一个东西，而且我们还遇到了一个更严重的问题，没钱了，因为激情不能当饭吃，有哥们开始离开了，因为各种各样的原因。而我也慢慢在团队中扮演更重要的角色，我才意识到，我那过去的1年是多么的幸运，我是team中唯一一个在做自己喜欢做的事情，而且只有一件事情。</p>

<p>创业第二个年头了，功夫不负有心人，在熬了不知道多少个通宵之后，在我们钱彻底完全花完之前，我们的东西还算得到了认可，拿到了200W的天使投资，我只能说，我的老大的“忽悠”能力的确很厉害，而且运气好得不得了。因为当时的资本市场已经很冷了，拿到投资之后，我们team还在创业的小圈圈里面风光了一把。太大的压力，导致我们休息了大概2个月的时间，我们挑新的办公室，布置新的生活工作环境，招人。我当时老开心了，我面试比我年纪大的人。呵呵。看到这里，一般人可能会觉得，终于雨过天晴了。没钱的日子终于结束了。但实际上却是一个新的深渊。在拿到投资之后，我们9个月，没有发布新产品，没有做软件更新。年底，老大和投资人谈崩，问我怎么想，我说本来就是追求自由的，没有自由，和他就别干了。在差，还能差过之前的日子。哈哈，可见我当时是多么幼稚，更坑的日子果然还在后面。。。。</p>

<p>俗话说得好，由俭入奢易，由奢入俭难。在放弃好的办公环境，不得已的情况下裁员，而且我们显然也没有什么好的计划，接不到项目，产品也没有打算。迷茫等消极情绪又开始蔓延。更糟的是cube要走了，也是因为女朋友的问题，要结婚了。之前有一个大哥对我很好很好的，我在北京第一年的房租都是他替我偷偷垫付的。也因为女朋友的问题离开了。然后team就这么半死不活的干熬。我的状态还没有很糟，我从EF那里得到了不少正能量，从游泳中发泄了不少负能量，但是team还是处在没有希望的状态。一切问题在我失恋之后彻底爆发了，所有的负面情绪完全淹没了我。我第一次和老大谈，我不干了。我想出国玩玩，或是回家睡觉。总之不想在北京待了。这让我老大疯了，说他认识的都是一群什么人啊，都是因为女人散伙？呵呵，当然，我们都很清楚，这个只是给自己一个听上去不错的借口而已。</p>

<p>在京城，对于像我们这种team的很多很多，大家都过的很苦，每天奋斗着只是为了能够在北京活下去，听上去很残酷，但现实的确是这样，好多好多次，都没钱活下去了，但是事情又有了转机，整个生活就是不断的从一个坑里面爬出来，再掉另一个坑里。come on, 当初怀着改变世界想法来到北京，显然被现实残酷的践踏掉了。因为创业，我和老大的关系很特别，我甚至知道他银行账户有多少钱，我也知道他发工资就是靠信用卡拆借，无抵押贷款这种非常危险的行为过着。更让我害怕的是，从他的身上我看到了我的未来，我在他手下做，到他的年纪，不会比他做得更好，看不到未来，那我为什么还要继续呢？</p>

<p>创业第三个年头，一天我和老大谈了很长很长时间，我质问他你30了，你觉得咱们继续这样下去，还有意义么？而且我也很冷静的表达出我的意愿，我觉得是该中止我们的创业了，老大表示他也累了。我们都希望大家能有一个好的结局吧，毕竟一起这么长时间了，然后我们team又开始很努力的做事情，很累，在1个月搞定了4个项目，然后我们挣到了后半年的生活费，但谁也没再提散伙了。</p>

<p>从我工作3年的结果来看，我除了第一年的进步很大以外，后2年几乎就是在原地踏步。听上去好像经历了不少事情，但是其实也没有什么价值，没有能够量化的价值，只是知道了什么是错误的而已，还是不知道以后该怎么办，未来在那里。</p>

<p>我曾经觉得我很清楚自己要做什么，不需要其他人的任何意见，只是聆听自己内心的声音就好，但是我却发现我居然浑浑噩噩的过了9个月。</p>

<p>我曾经觉得我一个非常有毅力的人，我想做的没有什么是执行不下去的，但是我却几乎要放弃我最喜欢的事情，而且还不只一次。</p>
]]></content>
  </entry>
  
</feed>
