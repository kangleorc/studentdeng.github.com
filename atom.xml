<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[studentdeng Blog]]></title>
  <link href="http://studentdeng.github.com/atom.xml" rel="self"/>
  <link href="http://studentdeng.github.com/"/>
  <updated>2013-05-08T11:56:59+08:00</updated>
  <id>http://studentdeng.github.com/</id>
  <author>
    <name><![CDATA[studentdeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[code snippets]]></title>
    <link href="http://studentdeng.github.com/blog/2013/05/08/code-snippets/"/>
    <updated>2013-05-08T11:30:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/05/08/code-snippets</id>
    <content type="html"><![CDATA[<p>Recently I found a fascinated feature of Xcode is the Code Snippets feature. It allows you to just type few characters instead of requiring you retype them over and over.</p>

<p>In my opinion, this is feature is not very obvious. The snippets library is fairly well hidden. Luckily, I&#8217;ve found it. There&#8217;s no sort of + button or something on the bottom of IDE. Apple just add a gesture to it. The only way you add a new snippet is to write a chunk of code and drag it into the Code Snippet Library window, and then it creates a default snippet and you can modify it, do whatever you want.</p>

<p>add dynamic fields</p>

<pre><code>&lt;#something...#&gt;
</code></pre>

<p>Finally I also found the same feature of Netbeans. It&#8217;s called Code Templates. and this feature is much easier to use than xcode.</p>

<p>add dynamic fields</p>

<pre><code>${something...}
</code></pre>

<p>It&#8217;s really fascinated feature and avoid retype the same piece of code again and again.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apple Script 可执行的伪代码]]></title>
    <link href="http://studentdeng.github.com/blog/2013/04/24/apple-script-1/"/>
    <updated>2013-04-24T19:21:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/04/24/apple-script-1</id>
    <content type="html"><![CDATA[<p>apple script 这种脚本语言就是精炼, 可执行的伪代码</p>

<pre><code>tell application "Finder"

display dialog "选择源文件目录"
set sourcepath to quoted form of POSIX path of (choose folder)

display dialog "选择输出目录"
set destinationpath to quoted form of POSIX path of (choose folder)

end tell

do shell script "/usr/bin/php /Users/ygcurer/apigen/apigen.php --source " &amp; sourcepath &amp; " --destination " &amp; destinationpath &amp; " --title curer --charset UTF-8 --access-levels public,protected --internal no --php yes --tree yes --deprecated no --todo no --download no --source-code yes --colors yes --progressbar no --update-check no"
</code></pre>

<p>这里把php document generate 的shell command 包装进了application中</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[numb]]></title>
    <link href="http://studentdeng.github.com/blog/2013/03/31/numb/"/>
    <updated>2013-03-31T16:31:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/03/31/numb</id>
    <content type="html"><![CDATA[<p>前几天运气很好和一大堆朋友吃饭和一个老外boss吃饭, 他很牛, 20岁从MIT毕业, 第一份工作是参与波音777的设计制作, 做了当时波音第一个用电脑辅助设计飞机的软件. 在控制项目的时候, 他们当时犯了相当大的错误, 18个月30W行的C代码, 被重新推倒重来, 再用18个月一个team从头学习然后最后项目上线, 他说777是当时最安全的飞机. 因为在这个之前,的飞机一直是手写设计稿做的, 不是通过计算机. 然后我问他为什么要离开波音呢? 他说因为他觉得没有意思, 他在波音继续待下去,也就是一个非常出色的工程师, 这个不是他想要的, 他想去做一点更新的,更cool的东西, 但是这个似乎很矛盾的, 因为我知道他现在是做传统行业石油的, 每天都是谈论石头, 这个和做飞机根本不是一个概念啊.我问他这个似乎很矛盾啊, 他说恩,是的. 他离开波音之后, 花了6,7年. 知道了什么事情是不对的.2000年那会, 他做自己第一个公司, 是做电商, 当时风投给他们了$1500W, 最后还是没做下去, 没想到最后居然被NSA看中了, 因为这里面他们实现了一个根据兴趣爱好推荐内容的算法, 而这个算法,正好适合间谍交易的使用场景. =. =!</p>

<p>最后bob说了一句非常感动我的话, 想得到自己想要的东西, 非常难, 即便自己很努力的去做, 最后得到的和之前想象的完全不一样. 是的, 如果让我来总结我这2年来的收获,用一句话来说就是 &#8220;很多东西觉得真心过不去这个坎了, 但是这个事情却做到了, 而有些东西觉得挺简单的,但最后却一直没有做到&#8221;.而有意思的是,我再写这篇blogs之前的2个小时之前, 还在愁一个项目无法交付,但是,有时候运气就这样子砸下来了.</p>

<p>2年来, 就是不断地在从一个坑里爬出来,然后跌进去,再爬出来,再跌进去. 昨天晚上和老大聊到晚上3点.呵呵, 真得, 我们只是知道了什么事情是不对的.</p>

<p>2年前,我觉得我虽然是一个很diaosi的家伙,但是我有一点是觉得很少人能够做到我这点的, 就是我知道我想要做什么, 我喜欢做什么,我适合做什么, 能够在22岁的时候想明白这个事情,让我非常开心,而且也一直向这个目标前进, 而为了这个,当然, 我放弃了非常多的东西, 其实我现在也不知道,因为一个东西,你付出了大量的时间,即便是没啥天赋, 也会做得不错, 这个世界上有太多的东西,我没有做过, 甚至都没有听到, 我凭什么说我适合做这个呢?</p>

<p>唯一能确定的就是,&#8221;天道酬勤&#8221;,&#8221;机会只会留给有准备的人&#8221;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql 源代码 第二天 ]]></title>
    <link href="http://studentdeng.github.com/blog/2013/03/21/mysql-source-code-2/"/>
    <updated>2013-03-21T23:48:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/03/21/mysql-source-code-2</id>
    <content type="html"><![CDATA[<p>昨天搭建好环境, 今天怀着无比兴奋的心情看一下, 一条简单的sql 背后有那些有趣的事情发生, 当然, 我们先从最简单的sql 开始.</p>

<pre><code>select * from example
</code></pre>

<p>当然, 对于这么庞大的项目, 我只能小小的大略一下代码结构了.</p>

<h2>SQL Interface</h2>

<p>首先启动mysqld, mysql的 server 部分</p>

<p>mysqld.cc</p>

<pre><code>int main(int argc, char **argv) 
</code></pre>

<p>传说中一切世界的源头. 在处理一些参数或是配置什么的, whatever, 先不关心这个,跳转到</p>

<pre><code>int win_main(int argc, char **argv)
</code></pre>

<p>还是一些配置, 读取my.ini, 日志, socket, 什么的. 然后创建一大堆的thread, 这里面大部分暂时没用
在很多的thread callback 函数中, 有一个必须要了解一下了它是</p>

<pre><code>handle_one_connection // sql_connect.cc
</code></pre>

<p>它是client 请求server callback的开始 然后依次调用</p>

<pre><code>my_real_read -&gt; do_command -&gt; my_net_read 
</code></pre>

<p>这里等待socket</p>

<p>client 部分</p>

<p>通过mysql 我们连接到 mysqld, 这里我们先跳过其他命令过程. 直接步入今天的主题, 我事先已经创建好一个简单的数据库, 里面2个字段, 3条数据.</p>

<pre><code>select * from example
</code></pre>

<p>回到之前的server</p>

<p>这时, mysqld 收到的socket, 在检查一些错误之后, 我们来到</p>

<pre><code>dispatch_command -&gt; mysql_parse
</code></pre>

<h2>mysql Query Parser</h2>

<p>这里我们进入了mysql Query Parser 部分, mysql 首先需要词法分析,语法分析 SQL 语句, 把我们的SQL 转变成一个个token 语法树什么的 要做一些编译器类似的前端部分, whatever, 对这部分不感兴趣, 我现在可没有扩展SQL 语句的想法.我们这条语句是select 所以, 我们最后跳到了 handle_select部分</p>

<pre><code>mysql_parse -&gt; mysql_execute_command -&gt; execute_sqlcom_select -&gt; handle_select -&gt; mysql_select
</code></pre>

<h2>Query Optimizer</h2>

<p>这里我们来到了mysql Query Optimizer 部分, 3个主要的事情</p>

<pre><code> prepare
 optimize
 exec
</code></pre>

<p>这个将是之后重点要学的, 现在先跳过啦</p>

<h2>Query Execution</h2>

<pre><code>do_select -&gt; sub_select -&gt; sub_select ....
</code></pre>

<p>这里我们看到了很多类似的函数, 从名字上来看, 基本上是处理递归的, 而且,事实上也的确是这样子的&#8230;.(真是废话), mysql 这里不断地读取一行行数据,
判断是否嵌套查询等等.最后 一系列的clear unlock. free, release</p>

<pre><code>net_end_statement
</code></pre>

<p>这里将数据返回client, server 继续</p>

<pre><code>do_command -&gt; my_net_read ... 
</code></pre>

<p>最后结构图
<img src="http://studentdeng.github.com/images/mysql_1_1.gif" alt="alt text" />
<img src="http://studentdeng.github.com/images/mysql_1_2.gif" alt="alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试 mysql源代码 环境搭建]]></title>
    <link href="http://studentdeng.github.com/blog/2013/03/20/mysql-source-code-setup/"/>
    <updated>2013-03-20T22:06:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/03/20/mysql-source-code-setup</id>
    <content type="html"><![CDATA[<p>下载源代码 <a href="http://dev.mysql.com/downloads/mysql/">mysql</a></p>

<p>下载CMAKE <a href="http://www.cmake.org/">download</a></p>

<p>代码根目录 执行下面代码, 确定生成configure.data 文件</p>

<pre><code>wscript win\configure.js WITH_INNOBASE_STORAGE_ENGINE WITH_PARTITION_STORAGE_ENGINE MYSQL_SERVER_SUFFIX=-pro
</code></pre>

<p>找到 win 目录下的 XXX.bat 文件复制到源代码根目录下, 我这里使用vs2008 ,所以复制 build-vs9.bat 到源代码根目录
在系统根目录 C:/windows 下 增加一个 my.ini 用于 mysql 配置, 我的mysql 源代码目录在 C:/mysql_code/mysql-5-1.1.68</p>

<pre><code>[mysqld]
# set basedir to your installation path
basedir=C:/mysql_code/mysql-5-1.1.68
# set datadir to the location of your data directory
datadir=C:/mysql_code/mysql-5-1.1.68/win/data
</code></pre>

<p>将sql目录下的share文件夹复制到源代码根目录下</p>

<p>修改sql_locale.cc 文件, 把文件编码改成 UTF8 with BOM, windows 你懂的</p>

<p>然后可以调试了, 不过这里我遇到一个问题, 在 sql_locale.cc 函数 test_lc_time_sz 函数, 这里DEBUG_ASSERT(0)了一下, 目前先暂时注释掉它 : (
现在可以跑</p>

<pre><code>mysqld
</code></pre>

<p>然后在</p>

<pre><code>mysql -u root -p 
</code></pre>

<p>over!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[情商太低, 伤不起]]></title>
    <link href="http://studentdeng.github.com/blog/2013/03/05/emotion-unknown/"/>
    <updated>2013-03-05T00:25:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/03/05/emotion-unknown</id>
    <content type="html"><![CDATA[<p>这是我写过的最难的一篇, 是目前为止最困难的一篇, 我的思路非常的混乱, 只是想通过这个方式来帮助我理清自己, 找出可以收获的地方. 其实我很早就想写了, 但是有很多东西反反复复,相互牵引的, 我的思维也在不断的变化, 有太多的地方我不明白, 这让我现在非常难受, 而在这个时候写一篇这样子的东西,实在是一件非常痛苦的事情, anyway, 就当这一篇是我对抗自己完美主义的一部分啦.</p>

<h2>先喷下自己吧, 展现一下负能量</h2>

<p>我是一个天生的悲观主义者, 有的人天生就比其他人容易快乐, 幸福, 而有的人天生就容易比其他人焦虑, 抑郁.很不幸, 我是那种容易焦虑的, 我非常害怕失败,特别是自己在意的事情, 我经常自己YY出一大堆各种失败的场景和缘由, 有的甚至是非常低概率事情,一旦遇到失败又或是最后结果达不到我的期望,我还会深深的陷入自卑中. 不管是什么原因, 最后会被自己大量的消极情绪淹没.</p>

<p>所以,我非常想改变, 我不想被那些大量的消极情绪,影响到我的效率. 因为这个要消耗掉我相当多的精力来应付这些我认为是累赘,但我又甩不掉的习惯 &#8212;- 就是不去思考那些产生烦心事的缘由, 不要去想或是分析自己的消极情绪的原因. 我一直希望我能够改掉, 直到我听到这个实验</p>

<p>首先参与实验的家伙们需要回答一个问题, 他们是否希望能够摆脱自己性格方面的某些缺点, 比如古板, 或者容易亲信别人. 第二部分, 则是让这些家伙们去评估这些正面的性格, 言行一致是否对你很重要, 值得信赖是否很重要, 被认为是一个严肃认真的人, 是否很重要.</p>

<p>而实验的结果也很有趣, 那些给这些正面性格打高分的人, 认为这些性格很重要的人, 反而比较不容易去改变自己的负面性格. 不如 容易相信别人 和 值得信赖.</p>

<p>就拿我自己来说吧, 我觉得最大的优点就是喜欢思考, 思考问为什么, 如果说得难听一点, 就是喜欢钻牛角尖, 而且我一直赞同一个观点, 一个人的专注一件事情的时间越长, 那么越容易做好. 事实上, 如果我喜欢一件事情, 我可以每天超过15个小时在一件事情上面,并坚持至少半年,  我很开心, 我有比别人更多的精力去专注的做事情, 而且我自己的进步有很大的原因在于这里, 但是这个也带给了我一个非常大的缺点.就是钻牛角尖, 对自己在乎的事情, 太过于在意细节, 导致和人不好相处. 我带过一个刚毕业的小弟, 我能够从工作时间到下班回家地铁的路上, 不断的展现我的负能量, &#8220;这段代码不能这么写? 你知道这样有什么后果么?&#8221;, 而且这个时间相当的长,大概有半年多吧, 每天都要喷.</p>

<p>我想该掉这些坏毛病, 但是我的潜意识告诉我, 细节是必须要扣的. 对于工作来说, 钻牛角尖能够让我学到更多, 而且对于Geek们来说, 面对枯燥的code都能看出花来, 或多或少都是些钻牛角尖的家伙,但是这些在人际交往中就是一个非常大的问题. 哎, 更别说,我还有完美主义问题,</p>

<p>完美主义:一种充斥在我们生活中的对失败的失能性恐惧, 尤其是在我们最在意的方面. 失能性恐惧 指的是在面对失败时, 有这裹足不前的畏惧. 我的完美主义并不是在生活中的每一个方面, 每一个细节. 而是发生在我们在意的地方.</p>

<p>从本质来看, 我的schema就是一个逐利者, 虽然很难听, 但这的确是事实. 我对自已在意的事情, 只是追求结果, 几乎不在乎过程.</p>

<ul>
<li><p>我看不到那个小弟的进步, 我一直以一个很高的要求(对他来说), 在他达到这个要求之前都是一文不值的.</p></li>
<li><p>我看中一门考试, 那么如果这门考试我不是满分, 我就觉得非常难受, 因为我觉得我没有做到, 那么别人也不能做出来.</p></li>
<li><p>在公司中,我的目标就是做问题的终结者, 如果这个问题我解决不了, 那么没人可以解决.</p></li>
</ul>


<p>这就是我的schema, 在达到这些标准之前, 所有的努力都没有价值. 因为我眼中, 只有一条路是正确的,</p>

<p>典型的完美主义者, 完美主义者的确非常的痛苦, 因为很简单, 现实总是非常的残酷. 因为害怕心理上的失落而变得患得患失, 特别害怕失败.</p>

<p>说到根底, 还是自己分不清出很多事情, 把太多的事情看成一件事情, all or nothing.</p>

<h2>What should I do</h2>

<p>答案很简单, 就是在遇到问题的时候, 选择面对, 不是逃避.去做, 去承担风险,承担责任.去尝试, 这里面有几个原因.</p>

<p>首先, 我们是如何评价自己的,这个标准有些时候和评价其他人的方式是一样的.</p>

<p>一个简单的例子, 比如,我们看到一个家伙, 敢于主动站出来, 表达自己的想法, 积极发言, 或是不断的失败,但依然不放弃,一直在努力坚持, 我们会认为这个家伙很有勇气, 有毅力.这个家伙心理一定很强大.勇于面对困难的家伙和普通人一样会有起起落落, 但是整体的幸福基线却在上升.我们很多时候通过行为来判断一个人的能力, 同样也适用于自己.</p>

<p>那些勇于向喜欢的女孩表白的男孩, 虽然会有更多失败的经历, 但却越来越明白自己适合找那种类型的女孩, 那些能够在工作中敢于请教别人, 在上课时勇于回答老师问题, 向老师提出问题的家伙们, 也更容易学到并记住知识.很多时候, 我们害怕失败,以及失败以后带来的各种消极想法. 但当事情过去之后, 即使是失败了, 经历的痛苦情绪也并没有想象中的那么大. 就像我之前第一次喜欢一个女孩, 然后最后居然发现这个女孩已经结婚了?觉得这个心坎真的实在是迈不过去.但现在也迈过去了.等等, 越来越多的尝试, 成功固然好, 而且即使失败了,最后也会过去. 但如果没有尝试, 那么会一直认为这个事情会一直持续下去, 但事实上这是不可能的.而当我们意识到真正的失败的痛苦要比我们想象的失败的痛苦少时, 我们会变得更自信.</p>

<p>如果说第一段感情我最大的收获是什么, 就是不管是多么美好的事情, 都会成为浮云, 不管是多么烂, 多么糟糕的事情, 也都会过去.</p>

<p>以前和女孩说话都会脸红, 现在和美女聊天也不觉得有什么尴尬了, 所以每周的锻炼还是很有必要的.</p>

<p>很多人都佩服我能够坚持半年健身, 保持体重, 但又有多少人知道我第一个月就减少了20斤, 后5个月加起来才少了5斤, 又有多少人知道我曾经减肥2次, 每次都不少于20斤, 但是反弹却超过了30斤. 我能做到今天的样子, 因为我经历了别人想象不到多的失败.</p>

<p>所以, just do it.</p>

<p>改变很难, 改变也不是灵丹妙药, 能够一下子解决问题. 我追求的只是不后悔, 做自己认为对的事情.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC 1]]></title>
    <link href="http://studentdeng.github.com/blog/2013/03/03/arc/"/>
    <updated>2013-03-03T13:43:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/03/03/arc</id>
    <content type="html"><![CDATA[<p>内容主要来自http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-1/ 里面加入了一点点自己的吐槽和理解</p>

<p>已经有很久很久没有写一些 under the hood 的东西了, 好久没有学习新的技术了, 不说废话了.
ARC 是编译器的技术, 不知道为什么, 我对编译器增加额外代码有着非常大的恐惧, 是因为和C++ 相关么? 不知道, anyway ARC 的确帮我这样的码农减少了工作量, 对于一向懒惰的我来说, 我还是更倾向于省事.</p>

<p>在之前写block 的时候, 有些好奇的家伙们问我,是怎么发现编译器增加代码的. 这个其实很简单, 就是看一些文档了,但是总是有些人比较好奇编译器到底做了什么,不想理所当然的接受.</p>

<p>先瞅瞅我们的测试函数 test_arc.m</p>

<pre><code>    @interface ClassA : NSObject
    @interface ClassA : NSObject
    {
            NSNumber *_foo;
    }
    @property (nonatomic, retain) NSNumber *foo;
    @end

    @implementation ClassA

    @synthesize foo = _foo;

    - (void)changeFooDirect:(NSNumber*)inFoo {
        _foo = inFoo;
    }

    - (void)changeFooSetter:(NSNumber*)inFoo {
        self.foo = inFoo;
    }

    - (NSNumber*)newNumber {
        return [[NSNumber alloc] initWithInt:10];
    }

    - (NSNumber*)getNumber {
        return [[NSNumber alloc] initWithInt:10];
    }

    @end
</code></pre>

<p>Mac 环境比较让人dt, 安装Xcode 后 安装Command Line Tools 否则, 会遇到各种各样的问题. 首先关闭ARC</p>

<pre><code>clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/ -arch armv7 -fno-objc-arc -O3 -S -o test_arc.s test_arc.m
</code></pre>

<p>这个是开启ARC的命令</p>

<pre><code>clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/ -arch armv7 -fobjc-arc -O3 -S -o test_arc_on.s test_arc.m
</code></pre>

<p>让我们先看一下 changeFooDirect 在没有开启arc时的样子, 当然, 如果有人和我一起工作,敢写出这样的代码, 肯定会让我喷的体无完肤的: )</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA changeFooDirect:]"
.thumb_func "-[ClassA changeFooDirect:]"
"-[ClassA changeFooDirect:]":
@ BB#0:
    movw    r1, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))
    movt    r1, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))
LPC0_0:
    add r1, pc
    ldr r1, [r1]
    str r2, [r0, r1]
    bx  lr
</code></pre>

<p>这里可以看出, 只是简单的覆盖变量, 没有retain release, 非常容易产生内存问题.
再看一下 changeFooDirect 开启ARC后的样子</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA changeFooDirect:]"
.thumb_func "-[ClassA changeFooDirect:]"
"-[ClassA changeFooDirect:]":
@ BB#0:
    push    {r4, r7, lr}
    mov r4, r0                          
    mov r0, r2
    add r7, sp, #4
    blx _objc_retain
    movw    r1, :lower16:(_OBJC_IVAR_$_ClassA._foo-(LPC0_0+4))
    movt    r1, :upper16:(_OBJC_IVAR_$_ClassA._foo-(LPC0_0+4))
LPC0_0:
    add r1, pc                          
    ldr r2, [r1]            //r2 = 变量foo在类实例中的偏移量
    ldr r1, [r4, r2]            //r4 = self 这句的意思就是 r1 = foo;
    str r0, [r4, r2]            //r0 表示参数inFoo, 这里相当于_foo = inFoo;
    mov r0, r1              
    pop.w   {r4, r7, lr}            
    b.w _objc_release           //release ro的变量 也就是 _foo
</code></pre>

<p>这里我们可以看出, ARC retain 新变量, 然后release 旧的变量, 而这个正是我们想要的结果.这段坑爹的代码在ARC下是可以正确运行的</p>

<p><strong>这里我再次声明一下, 类似changeFooDirect 这样的代码 只是用于研究, 访问类实例成员变量时都应该使用property方法而不是直接访问或是修改</strong></p>

<p>changeFooSetter 这里我们看到无论是否开启ARC 生成的代码都是一样的.调用自动生成的setter 方法</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA changeFooSetter:]"
.thumb_func "-[ClassA changeFooSetter:]"
"-[ClassA changeFooSetter:]":
@ BB#0:
    movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
    movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
LPC1_0:
    add r1, pc
    ldr r1, [r1]
    b.w _objc_msgSend
</code></pre>

<p>然后我们再看看getNumber 函数 开启ARC后的代码</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA getNumber]"
.thumb_func "-[ClassA getNumber]"
"-[ClassA getNumber]":
@ BB#0:
push    {r7, lr}
movw    r0, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+4))
mov r7, sp
movt    r0, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+4))
movw    r2, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+4))
movt    r2, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+4))
LPC3_0:
add r0, pc
LPC3_1:
add r2, pc
ldr r1, [r0]
ldr r0, [r2]
blx _objc_msgSend
movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+4))
movs    r2, #10
movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+4))
LPC3_2:
add r1, pc
ldr r1, [r1]
blx _objc_msgSend
pop.w   {r7, lr}
b.w _objc_autoreleaseReturnValue               //如果没有开启ARC 则没有 _objc_autoreleaseReturnValue
</code></pre>

<p>关于_objc_autoreleaseReturnValue 也有很多有趣的事情, 如果把这个家伙简单的理解成autorelease就大错特错了, 编译器会对这些做优化, 减少一些无谓的retain release 来提高代码效率</p>

<p>newNumber 和我们想的也一样, 在开启ARC的时候, 并没有增加 类似autorelease 的函数, 而是将retain count 保持为1.</p>

<p>如果是普通的临时变量又是什么样子呢?</p>

<pre><code>- (void)test
{
        NSNumber *test = [[NSNumber alloc] initWithInt:1];

        NSLog(@"%@", test);
}
</code></pre>

<p>开启ARC 后的代码</p>

<pre><code>.align  2
.code   16                      @ @"\01-[ClassA test]"
.thumb_func "-[ClassA test]"
"-[ClassA test]":
@ BB#0:
push    {r4, r7, lr}
movw    r0, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC4_0+4))
add r7, sp, #4
movt    r0, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC4_0+4))
movw    r2, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC4_1+4))
movt    r2, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC4_1+4))
LPC4_0:
add r0, pc
LPC4_1:
add r2, pc
ldr r1, [r0]
ldr r0, [r2]
blx _objc_msgSend
movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC4_2+4))
movs    r2, #1
movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC4_2+4))
LPC4_2:
add r1, pc
ldr r1, [r1]
blx _objc_msgSend
mov r4, r0
movw    r0, :lower16:(L__unnamed_cfstring_-(LPC4_3+4))
movt    r0, :upper16:(L__unnamed_cfstring_-(LPC4_3+4))
mov r1, r4
LPC4_3:
add r0, pc
blx _NSLog
mov r0, r4
pop.w   {r4, r7, lr}
b.w _objc_release           // 这里我们看出release 掉了 test 变量 也和我们想想的一样.ARC 这里对带类成员变量和普通的临时变量是不同的
</code></pre>

<p>寄存器变量在第一个例子中已经列举了一点, 这个就不赘述啦.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tips]]></title>
    <link href="http://studentdeng.github.com/blog/2013/01/26/tips/"/>
    <updated>2013-01-26T18:05:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/01/26/tips</id>
    <content type="html"><![CDATA[<ol>
<li><a href="#A1">ARC 编译时遇到的相关问题</a></li>
<li><a href="#A2">install cocoapods 问题</a></li>
<li><a href="#A3">Adding Unit Tests to an existing iOS project with Xcode 4</a></li>
<li><a href="#A4">NSDateFormatter 问题</a></li>
<li><a href="#A5">写博客命令</a></li>
<li><a href="#A6">php apigen command demo</a></li>
</ol>




<div name = "A1" id = "A1"></div>


<h1>ARC 编译时遇到的相关问题</h1>

<ol>
<li>自己的项目没有使用ARC, 其他代码使用ARC</li>
<li>自己项目使用ARC, 其他代码没有使用ARC</li>
</ol>


<p>在Xcode Build Phases 里面的 Compile Source 需要特殊处理的文件 增加 COmpiler Flags
1. 第一种情况 添加 -fobjc-arc
2. 第二种情况 添加 -fno-objc-arc</p>

<div name = "A2" id = "A2"></div>


<h1>install cocoapods 问题</h1>

<p>In Preview of OS X Mountain Lion, Xcode has been distributed as X.app. And Commandline Tools are not installed by default. Commandline Tools contains cc/gcc that you must need to build environment.</p>

<p>Open Xcode and cmd +, to open Preferences panel where you can install Commandline Tools:</p>

<p><img src="http://studentdeng.github.com/images/commandline.jpg" alt="alt text" /></p>

<p>then</p>

<pre><code>gem install hpricot
gem install cocoapods
</code></pre>

<div name = "A3" id = "A3"></div>


<h1>Adding Unit Tests to an existing iOS project with Xcode 4</h1>

<p>When you build a new iPhone or iPad app from scratch, you can generate a new project with tests using Xcode’s project templates, and the test dependency is set up correctly.</p>

<p>However, if you add a unit test target to an existing iOS project, there are some manual steps required to set up the target correctly. Following these steps will get you up and running quickly:</p>

<p>Project MyExistingApp -> + Add Target -> iOS -> Other -> Cocoa Unit Testing Bundle
Name the new target something like “Unit Tests” or “MyAppTests”
Select your new “Unit Tests” target and click the Build Phases tab, expand Target Dependencies and add MyExistingApp as as a Target Dependency
Click the Build Settings tab and set the Bundle Loader setting to</p>

<pre><code>$(BUILT_PRODUCTS_DIR)/MyExistingApp.app/MyExistingApp
</code></pre>

<p>Set the Test Host build setting to</p>

<pre><code>$(BUNDLE_LOADER)
</code></pre>

<p>Go back to your app target (not the test target), set the Symbols Hidden by Default build setting to NO</p>

<p>That should take care of it, and you can now start adding tests for your app. With this configuration, you continue to add application classes only to your app target, and add test classes only to your test target. Since the tests run in the app running in the simulator, the code under test can safely instantiate views and fonts, which would otherwise cause OCunit to crash when running without the Test Host setting.</p>

<div name = "A4" id = "A4"></div>


<h1>NSDateFormatter 问题</h1>

<p>最近在使用新版本xcode4.6 或是 因为新版本的sdk6.1 日期转换出现了一个问题. 而且是在模拟器可以, 真机不行的问题.
问题是 时间格式中的 &#8220;Thu Jan&#8221; 无法被识别出来. 这个挺奇怪的, 可能新版本修改了默认行为. 下面是解决方法</p>

<pre><code>//time format: @"Thu Jan 17 13:59:11 +0000 2013"
s_format = [[NSDateFormatter alloc] init];
[s_format setDateFormat:@"eee MMM dd HH:mm:ss ZZZZ yyyy"];
[s_format setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]]; //之前少了设定Locale
</code></pre>

<div name = "A5" id = "A5"></div>


<h1>写博客命令</h1>

<pre><code>rake new_post['filename'];
rake generate 
rake preview
</code></pre>

<div name = "A6" id = "A6"></div>


<h1>apigen command demo</h1>

<pre><code>/usr/bin/php /Users/ygcurer/apigen/apigen.php --source /Applications/XAMPP/xamppfiles/htdocs/curer/application/controllers/api --destination /Applications/XAMPP/xamppfiles/htdocs/curer/doc_test --title curer --charset UTF-8 --access-levels public,protected --internal no --php yes --tree yes --deprecated no --todo no --download no --source-code yes --colors yes --progressbar no --update-check no
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哈佛幸福课 杂感一]]></title>
    <link href="http://studentdeng.github.com/blog/2013/01/15/happiness/"/>
    <updated>2013-01-15T18:10:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/01/15/happiness</id>
    <content type="html"><![CDATA[<p>好长时间不写博客了, 可以说将近一年的时间里面,并没有多少技术上的积累, 甚至有点倒退的痕迹, 不管是从心气还是态度, 还是毅力上面.我曾经是<em><a href="http://mindhacks.cn/">刘未鹏</a></em>的粉丝,哈,当然现在也一样. 我一直好奇为什么会他会那么的专心在思维这部分.其实在1年前,我也无法想象我会放下我心爱的计算机的书籍而拿起这些曾经我看不上的东西.有些东西的确只有经历过,才会明白.好消息是,一切还来得及.文本和技术类文章毫无瓜葛, 只是我觉得对于Geek们来说,有些其他东西还是很重要的.</p>

<p><em><a href="http://v.163.com/special/positivepsychology/">幸福课</a></em>来自豆瓣小组的推荐, 一开始觉得这个只是一个练习英文听力的一个好的途径, 因为相对电影来说,我觉得对时间的利用率更高, 但事实上, 却是我听过的最好的公开课, 没有之一</p>

<h2>为什么要看这门课</h2>

<p>Tal 也就是这门课的老师, 第一句话就深深的吸引了我, &#8220;我来这里讲这门课, 因为我在本科的时候非常希望能学习这样的一门课程&#8221;.Tal本科在哈佛大学读计算机, 学习成绩优秀 社交优秀, 运动优秀, 但还是有一种说不出来的压抑, 不幸福的感觉,然后他寻找问题的根源, 最后居然转向了哲学和心理学. 看到这里, 我就有一种特别的冲动, 想继续看下去, 想去了解Tal的动机. 我特别好奇的在于, 如何将一个理科思维转向哲学和心理学呢? 当然, 这是我当时的想法,科学本来就是理性,严谨的, 只是我当时对心理学,哲学这些有很多的偏见. 后面我才知道了这门课程讲的是积极心理学.</p>

<p>积极心理学啊, 可能是涉及到一些积极的心理暗示的某些东西, 这是我当时的想法, 不过相比占卜啊,星座啊, 这些扯淡的东西,我还是比较有好感的, 因为我当初在高考前, 学校组织过一次考试时的减压方法的交流会,有一个专家说过, 在做题没有思路的时候, 深呼吸3次, 然后心理默念&#8221;我能行&#8221;, 3次, 然后再读题, 效果会很不错. 然后我当年在考理综的时候, 最后一道物理题,纠结了我挺长时间, 最后就是通过这个心理暗示搞定的.从那之后,从不信到半信半疑.</p>

<p>为什么想学心理学, 主要原因还是,当自己的外部空间拓展收到阻碍, 这个包括 工作, 学习, 人际交往,各种都不顺利, 到达瓶颈, 突然觉得可以向自己内部空间探索.而这些正好和Tal第一节课讲的内容吻合, 我觉得这就是缘分, 一种在正确的时间学正确的东西的缘分.而且Tal是一个内向的心理学老师, 他自己也承认, 而且Tal很风趣幽默.他里面讲了很多自己的故事, 包括很多让自己很尴尬的事情, 感觉很真实, 而不是我看到的其他的那种特别热情, 有力量, 感觉就像江湖卖艺的那种老师.</p>

<h2>什么是幸福</h2>

<p>大家都知道现在社会充斥着浮躁的概念, 不仅在中国, 美国, 全世界都是, 各种各样的秘籍, 捷径, 只要就类似的语句, 还有那句经典的&#8221;移动互联网唯快不破&#8221;, 等等. 尽是些夸大其词, 效果甚微的言论.而这些言论却成了媒体追逐的主要理念, 追求快节奏, 什么都要快.一个个就像兴奋剂一样, 给我们短暂的快感, 但对长远收获来说, 都是弊大于利的.而这些也就是我们不断的感到焦虑,压抑的原因,那么应该如何看待这些信息呢.</p>

<p>Tal 讲得最多的一句话,就是chip away 我们身上的限制, 消除掉我们心理的枷锁.很多人都没有做到permission to be human. 很多时候不能面对自己, 面对自己的情绪, 更别说控制情绪.疏导情绪. 不能合理的理解情绪, 则极大的影响到自己的个人成长, 不论是生活, 工作, 学习, 还是人际交往, 而且我也确确实实的遇到了这方面的困难.</p>

<p>生活包括了起起落落, 这是一件说起来容易, 做起来难的事情, 大家都知道生活包括了失败, 振作, 成功, 迎接新的挑战. 但是人们往往给自己的预期则是和这个道理背驰的. 甚至很多家长自己的心理不成熟而导致孩子心理也不成熟, 比如一个经典的例子, 考上一个好的初中, 高中, 大学, 找到好的工作, 成家就怎怎怎么了, 这个好像一个充分必要条件似的强加在孩子心理上. 幸福没有那么容易获得,也不是一个等式可以解决的.</p>

<p>说到幸福,呵呵,这门课的名字可是讲happiness的, 这里我想到了一个特别搞笑的段子, &#8220;你幸福么?&#8221; 我不在这里重复了, 我在这里其实一直很困惑这个问题. Tal 讲到, 幸福不是一个简单的比较, 0 或1 .要么幸福, 要不不幸福.幸福存在于一个连续的状态,这个很像物理中能量的概念, 我们更关注与能量的转化, 多了还是少了, 而不是在乎我到底具有多少能量.更准确的描述应该是,我们如何才能变得更幸福.</p>

<p>Tal 讲述了一个这样子的观点. 是这样子的一个调查, 调查那些参加终身职位的教授们的心理, 这些教授们只能申请一次一所大学, 要么得到,也么没有. 调查的内容就是, &#8220;如果得到了终身职位,那么会有多开心?&#8221;, 教授们的绝大多数都是回答&#8221;会非常非常高兴, 这实现了很多很多很多年努力的目标, 梦想成真的一刻, 我余生都会非常快乐, 一切都会变得简单, 停止不成功变成仁的竞争, 他将改变我的人生云云&#8221;, 另一个调查是,&#8221;如果得不到终身职位会怎么样?&#8221;, 教授们绝大多数回答&#8221;我们会非常非常难过, 这是很多很多年奋斗的目标, 因为如果在一所学校无法获得终身职位, 就没有可能在更高的学府获得, 只能在低一等的学校获得,所以会难过很长很长时间&#8221;</p>

<p>而在一段时间时候,再次调查教授们的感受, 其中有人得到了, 有人没有得到.&#8221;得到的说非常开心,余生都会非常开心&#8221;, 而那些没有得到的, 则是&#8221;我们很确认我们会难过很长时间&#8221;. 三个月后, 六个月后不管是得到职位的,还是没有得到职位的都恢复到之前的幸福水平.</p>

<p>也就是说, 在得到职位 对他们的幸福感觉, 没有任何帮助, 在长久的角度来看.这既是一个好消息也是一个坏消息.坏消息是似乎无论我们怎么做,都无关紧要, 好消息是,无论这是一个多么糟糕的经历, 最后都会过去.</p>

<p>但这就带来一个问题,为什么我们还要不断地设立目标,努力实现呢?</p>

<p>很多时候我们通过降低我们的心理预期,降低自己的压力,去享受生活, 比如考试只是考了B, 然后我们不去想为什么不是A, A+, 而是想,恩,可以了,及格了,我不在乎成绩;我们的工作不好, 我不在乎我工作什么, 我只想快乐.有些时候,的确降低期望水平,会感到快乐一点.但长远来看却不行.</p>

<p>真正的问题不是在于降低期望, 而是在于区分正确的和错误的期望.一个错误的期望例子,就是我之前提到的,&#8221;考上好大学, 找到好工作, 升职, 找到理想的伴侣,就能让自己更快乐&#8221;. 而让我们更快乐,是通过改变我们对问题,事物的看法,内在的认知,心境来做到的,而不是这些外部条件.(当然,外部条件肯定重要,如果每天都吃不饱, 没有住的地方, 外部条件的改善当然能提升幸福, 这里不考虑这种极端情况).</p>

<p>一个自己的例子吧, 之前很很用心的喜欢过一个女孩子, 但是知道的, 对于我这样的低情商Geek们来说, 结局大多都是悲剧的,觉得自己真的迈不过这个坎, 没法在面对以后的生活了, 没法在北京待下去了, 要逃避. 但现在看来, 当时自己的想法就是哈哈一笑带过了. 现在不是好好的么, 还有一个例子, 当时做IOS开发, AppStore排名是相当的低, 一度AppStore都无法找到了, 当时过年的时候,就定下一个目标, 丫的一定能冲到第一, 而且, 最后的确到第一了, 但也没有觉得特别开心, 觉得自己很厉害什么的.</p>

<h2>Give ourselves the permission to be human</h2>

<p>学积极心理学,主要就是想让自己能够变得阳光, 积极, 不消极. 那么就吧思路聚焦在那些痛苦的,不愉快的经历上面.</p>

<p>很多情绪是与生俱来的, 但是我却在内心里不断得在抵触, 在抗拒那种情绪.有一个简单的例子,就是 &#8220;现在开始,我们脑子里面不要想一个粉色的大象, 恩, 不要想一个粉色的大象, 一定不要想一个粉色的大象&#8221;.</p>

<p>我自己的感受吧, 对于一个低情商男孩来说和一个女孩交往往往会有各种各样神奇的情绪产生, 而且我自己也却觉得不可思议, 不管是嫉妒,羡慕, 负罪感, 等等的情绪. 或是对于一个初步进入社会的男孩, 在工作中也会遇到各种各样的困难,不管是大目标,还是小目标,总是会各种各样的问题, 特别是对我这种有这强大的信心,自我,自恋, 把自己看得很重, 但实际上,别人根本不这么想, 没有那么在意自己.而有时候,发现自己能力的确不够,无力改变一些事情,而陷入一种挣扎.</p>

<p>而且事实上,在现在的社会, 不管是西方还是东方的, 男人们往往不能想女人们一样去向别人倾诉自己的内心真实想法.而随着压力越来越大,而变得焦躁.</p>

<p>Tal 讲述了一个自己的例子, 是当他和她的妻子有第一个孩子的情景. Tal在一个月的时候, 突然发现自己有一种嫉妒的情绪,他很嫉妒她的妻子和医生之间的关系, 因为在他的角度来看, 突然有个另一个人在Tal的妻子心中比Tal获得更多的关注,不管Tal怎么哭…..Tal感到非常的嫉妒.</p>

<p>在看到这个例子的时候, 给我非常大的震惊, 因为看到很多表面现象, 很多人都是永远的宠辱不惊, 在大的压力也面不改色, 遇到再困难的事情都不会害怕,以至于我认为那些家伙们没有这些消极情绪, 而作为情商极高的Tal来说, 肯定不会有这种消极情绪存在,不会这么敏感.</p>

<p>但事实上, 的确有, 那后来的故事是这样子的. Tal说, 在5分钟后,他就想通了这件事情,&#8221;这个医生真的好棒,让我体会到这种以前从来没有过的情绪&#8221; 额, 听到这个, 真的觉得好假. 这也太假了, 我反正是不信, 几分钟钱还充满嫉妒, 几分钟后就感谢他么,太扯了.但是Tal说, 完全正确, 各种各样的情绪就是作为一个human的一部分. 有人的确比另一部分人敏感, 几分钟就能够产生很多各种各样的情绪.Tal说, 我完全接受了我对医生的嫉妒这个情绪, 然后give myself the permission to be human, 然后自然而然的对医生产生了积极的情绪.</p>

<p>这里边会有一种自相矛盾的感觉, 是一个反语的自然现象,就像我之前说过的粉色大象, 我相信大多数人脑子里面都会有一个粉色大象出来.因为当我们企图压抑一种自然现象时, 只会加强它.就像失恋后, 想忘记那个人, 然后不停得对自己说,忘掉,忘掉,但却越来越清晰是一个道理.</p>

<p>在控制自己消极情绪出现的时候, 首先做的,不是压抑他, 而是学会接受他.<em><a href="http://book.douban.com/subject/4194978/">完整的成长</a></em>这本书里面也提到了类似的经历, 让情绪自然而然的流动.</p>

<p>这是一件说起来容易, 做起来非常难的一件事情. 因为我们很多人对心理学有着很大的偏见, 总觉得我们可以控制自己很棒, 因为我们总认为自己很了解自己,但事实上, 我们对自己的理解, 对大脑是如何思维, 决断, 我们的潜意识,我们的基因等等的了解, 相对而来不会比宇宙多多少.</p>

<p>我们不会有一天起来说, OK, 我拒绝万有引力,我不想每天爬楼梯, 我想直接飞过去.这样多简单, 多容易.相对其他科学,比如物理, 我们总是能够很容易的承认物理的基本定理并欣然接受, 而且还能接受他的不足, 比如在量子物理等等很多领域.</p>

<p>但在心理学这里,却有了双重标准. <em><a href="http://book.douban.com/subject/1221479/">与“众”不同的心理学</a></em>这里面也提到了这个基本的道理.</p>

<p>一个简单的例子,就是很多媒体鼓吹的东西,什么占星, 星座, 一些通过特别简单的一些tips, 就可以把一个人了解彻底.多容易,多么简单的捷径, 不需要花费很多时间就可以了解一个人的性格.心理学家似乎就可以通过一眼就可以把这个人了解明白.网上我记得看过一个笑话, 是一个学心理的男孩,在吐槽她的女朋友, 她女朋友有天突然问他, 你知道我现在在想什么, 他说不知道,然后她女朋友说, 你真没用,学心理的居然不知道我想什么.然后他就瞎了.</p>

<p>拒绝自己内心的情绪, 就像不遵守物理中的万有引力定律一样, 会让自己到处碰壁, 而事实上, 我们可以利用万有引力做出很多好玩的游戏, 刺激精彩的运动.但在面对自己的情绪时, 我们却很难做到,甚至面对都很难, 而这里,我真的好佩服Tal的情商了.因为当我有这样的消极情绪,我会觉得一定是那里出了问题, 那里做的不对,然后陷入一大段无意义的思考中, 最后因疲倦而逃避,而不是面对它, 接受它, 甚至是改变它.时间一长,则变的更加焦虑, 抑郁.</p>

<p>而学到这里, 我又有了新的疑惑, 那么就是,如何接受, 被动的接受么?就没有什么可以主动做的么.而事实上,Tal说出了一个非常重要的观点, 就是, 在改变自己, 改造自己之前, 我们需要先知道, 我们可以改变什么, 不可以改变什么.</p>

<p>这里Tal 提出了一个很犀利的观点.心理学的A B C</p>

<p>A: affect           情绪</p>

<p>B: behavior       行为</p>

<p>C: cognition      思想,认知</p>

<p>permission to be human 主要是和情绪相关的. 比如,我们有愤怒的情绪,接受它但并不是意味着, 我们也要接受那些因为愤怒而做出伤害他人的行为.Tal嫉妒医生, 并不代表Tal是一个坏人, 这个没有好坏之分.很多时候,我们应该采用什么样的行为去表达情感, 这个才是问题的关键. 就像之前发生的一名男子失恋后, 在地铁里面划女孩脸. 我们承认失恋的确很难过, 但是通过这种行为表达自己的难过, 就是不能接受的.</p>

<p>对于认知这部分同样. 我们可以有消极的情绪,但并不意味着我们必须屈从于消极情绪带来的消极的想法.而且事实上沉思,下功夫琢磨对消极情绪这里,并没有多大帮助, 通常会越来越糟. 比如一直在想,哦,我被女朋友甩了,这有多么的惨.</p>

<p>举一个我的例子吧, 我很喜欢沉思,但是在对待消极情绪这里就遇到了极大的困难,恩, 算了, 我还是在改变里面讲这个吧.</p>

<p>一个情商高, 内心强大的家伙, 不是没有那些消极的情绪, 就像一个强壮的身体, 不可能永远不得病, 而是因为更有抵抗能力, 在面对病症时,也可以更快的恢复.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Orange‘s 一个操作系统的实现 配置问题]]></title>
    <link href="http://studentdeng.github.com/blog/2012/02/16/selfos/"/>
    <updated>2012-02-16T23:57:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/02/16/selfos</id>
    <content type="html"><![CDATA[<p>最近在瞅《Orange‘s 一个操作系统的实现》，个人认为相当好的OS入门实践书籍，配合之前看过的大部分的理论书，容易理解那些抽象的概念（无代码无真相），</p>

<p>和《Linux内核完全注释》都是相当不错的入门书籍。</p>

<p>这里记录一下可能遇到的问题，主要是配置问题，实现逻辑书里面很详细，代码注释也很详细，仔细多想应该没啥问题。</p>

<p>我这里环境是ubuntu 10 64bit， 而书中代码是32bit的。这里在编译链接的时候出了一点小问题。这里记录下。</p>

<p>错误：</p>

<pre><code>ld: i386 architecture of input file `kernel/kernel.o' is incompatible with i386:x86-64 output
</code></pre>

<p>需要修改makefile</p>

<pre><code>CFLAGS          = -I include/ -c -fno-builtin -m32
LDFLAGS         = -m elf_i386 -s -Ttext $(ENTRYPOINT)
</code></pre>

<p>错误：</p>

<pre><code>klib.c:(.text+0xe5): undefined reference to `__stack_chk_fail'
</code></pre>

<p> 这里应该是少了c的标准库，还是需要修改makefile文件</p>

<pre><code>LDFLAGS         = -m elf_i386 -s -Ttext $(ENTRYPOINT) -lc
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bochs-configure]]></title>
    <link href="http://studentdeng.github.com/blog/2012/02/14/bochs-configure/"/>
    <updated>2012-02-14T23:55:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/02/14/bochs-configure</id>
    <content type="html"><![CDATA[<h1>Bochs + freedos安装配置</h1>

<pre><code>sudo apt-get install build-essential

sudo apt-get install xorg-dev

sudo apt-get install libgtk2.0-dev
</code></pre>

<p>下载</p>

<pre><code>bochshttp://bochs.sourceforge.net/cgi-bin/topper.pl?name=See+All+Releases&amp;url=http://sourceforge.net/projects/bochs/files

$ tar vxaf bochs-2.5.1.tar.gz

$ cd bochs-2.5.1

$ ./configure –enable-debugger-enable-disasm

$ make

$ sudo make install
</code></pre>

<p>下载freedoshttp://bochs.sourceforge.net/diskimages.html 复制到工作目录下</p>

<h1>Bochs 配置 先通过dos引导，我们的软件复制在B盘下</h1>

<pre><code>############################################################### 
# Configuration file for Bochs 
###############################################################

# how much memory the emulated machine will have 
megs: 32

# filename of ROM images 
romimage: file=/usr/share/bochs/BIOS-bochs-latest 
vgaromimage: file=/usr/share/vgabios/vgabios.bin

# what disk images will be used 
floppya: 1_44=freedos.img, status=inserted 
floppyb: 1_44=pm.img, status=inserted

# choose the boot disk. 
boot: a

# where do we send log messages? 
# log: bochsout.txt

# disable the mouse 
mouse: enabled=0

# enable key mapping, using US layout as default. 
keyboard_mapping: enabled=1, map=/usr/share/bochs/keymaps/x11-pc-us.map

#enabled debug using xchg bx, bx

magic_break:enabled=1

可以通过下面方式来部署程序，当然，写成makefile最省事

$ sudo mount –o loop pm.img /mnt/floppy

$ sudo cp test.com /mnt/floppy

$ sudo umount /mnt/floppy
</code></pre>

<h1>bochs 调试</h1>

<p>调试方法很多，这里介绍最简单的方式之一。bochs 配置中增加 magic_break:enabled=1</p>

<p>代码中增加xchg bx, bx，bochs会停在代码出。当然，前提是bochs需要支持debug</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C block]]></title>
    <link href="http://studentdeng.github.com/blog/2012/02/03/objblock/"/>
    <updated>2012-02-03T23:47:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/02/03/objblock</id>
    <content type="html"><![CDATA[<p>block 有什么意义，特点等等，这些东西，实在是太复杂了，这里只是简单的总结一下block的内存管理。而且也仅仅限于objective-C的部分</p>

<h1>Block memory</h1>

<p>block 的内存管理，应该是最头疼的地方,就用这个来自WWDC的例子来解释一下吧。</p>

<p><img src="http://studentdeng.github.com/images/objblock-1.png" alt="alt text" /></p>

<p>当程序运行到这里时，stack 空间中有 shared 变量和 captured 变量。</p>

<p>这里可以看出，__block 变量开始是处于stack上的。</p>

<p><img src="http://studentdeng.github.com/images/objblock-2.png" alt="alt text" /></p>

<p>当程序运行到这里时，stack 空间中有 shared 变量，captured 变量和block1。</p>

<p>这里可以看出，block 类型的变量开始时也是处在stack上的。</p>

<p><img src="http://studentdeng.github.com/images/objblock-3.png" alt="alt text" /></p>

<p>当程序运行到这里时，stack 空间中有 shared 变量，captured 变量和block1。</p>

<p>这里值得注意的就是当我们直接修改stack 上的captured变量时，block1中的captured变量仍然是原来的数值10。事实上，从const 我们就可以看出，block1中的captured变量是不能被修改的而且是从stack原有变量的一个const 拷贝。在block1中访问的captured变量是const拷贝的，也就是说block1中captured = 10，而不是原有的stack上的值 20。当然，在block1中，我们也不能修改captured变量。</p>

<h1>Copy block</h1>

<p>block在一开始是处在stack上的，这是为了考虑到效率的原因，但是，有时候是需要block的生命周期长于一开始的stack，这时，我们就通过copy block 来将block复制到heap。</p>

<p><img src="http://studentdeng.github.com/images/objblock-4.png" alt="alt text" /></p>

<p>当程序执行完 block2 = [block1 copy];时，__block 类型变量shared，被复制到了heap中，很显然，shared变量需要被block和block2共享(当然还有stack也要共享)，而block2被移动到heap中，很可能生命周期会长于stack，所以，shared也被复制到了heap中。而block2中的captured 也被复制到了heap中。</p>

<p><img src="http://studentdeng.github.com/images/objblock-5.png" alt="alt text" /></p>

<p>当程序执行完 block3 = [block2 copy];时, 我们看到的是，block2 和block3 其实指向的是同一片内存空间。事实上，block的数据结构中，保存了引用计数，而对于copy到heap中的block 再copy时，行为同普通对象retain一样，会使引用计数+1。那么如果我们对[block retain]会如何呢？ 实际上什么都没有发生，至少在现在的runtime版本下。因为retain中，不仅有引用计数+1在，而且retain的返回值，必须同返回调用对象的地址一样，而block的地址是可能变化的（stack or heap），所以，这里retain的行为几乎是被忽略掉的。</p>

<p>当heap中的block变量先于stack被销毁时，如调用 [block2 release]; [block3 release];，heap中的block2，block3 由于引用计数为0 而被销毁，而 __block 变量shared则还在heap中，因为stack还要使用，block1 也要使用。</p>

<p><img src="http://studentdeng.github.com/images/objblock-6.png" alt="alt text" /></p>

<p>当heap中的block变量晚于stack时，显然，stack 被清除，function中也啥都没了。</p>

<p><img src="http://studentdeng.github.com/images/objblock-7.png" alt="alt text" /></p>

<p>最后，当block2 和block3 都被release之后。则恢复到最初状态</p>

<p><img src="http://studentdeng.github.com/images/objblock-8.png" alt="alt text" /></p>

<h1>block details</h1>

<p>当我们写出一个Block literal expression</p>

<pre><code>^ { printf("hello world\n"); }
</code></pre>

<p>事实上，编译器为我们生成了如下结构</p>

<pre><code>struct __block_literal_1 {
    void *isa;
    int flags;
    int reserved; 
    void (*invoke)(struct __block_literal_1 *);
    struct __block_descriptor_1 *descriptor;
};void __block_invoke_1(struct __block_literal_1 *_block) {
    printf("hello world\n");
}static struct __block_descriptor_1 {
    unsigned long int reserved;
    unsigned long int Block_size;
} __block_descriptor_1 = { 0, sizeof(struct __block_literal_1)}; 当Block literal expression 使用时 __block_literal_1 则会被初始化为：struct __block_literal_1 _block_literal = {
    &amp;_NSConcreteStackBlock,
    (1&lt;&lt;29), &lt;uninitialized&gt;,
    __block_invoke_1,
    &amp;__block_descriptor_1
   };
</code></pre>

<p>下一个例子</p>

<pre><code>int x = 10;
void (^vv)(void) = ^{printf("x is %d\n", x);};
x = 11;
vv();
编译器会生成如下结构
struct __block_literal_2{
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(struct __block_literal_2 *);
    struct __block_descriptor_2 *descriptor;
    const int x;
};
void __block_invoke_2(struct __block_literal_2 *_block){
    printf("x is %d\n", _block-&gt;x);
}
void struct __block_descriptor_2{
    unsigned long int reserved;
    unsigned long int block_size;
}__block_descriptor_2 = {0, sizeof(struct __block_literal_2)};
struct __block_literal_2 __block_literal_2 = {
    &amp;NSConcreteStackBlock,
    (1&lt;&lt;29),
    __block_invoke_2,
    &amp;__block_descriptor_2,
    x
};
</code></pre>

<p>block中使用的普通变量（int， char *）导入是const copy。普通对象则会retain。__block 类型变量则什么不做，只是保存一个指针，全局变量也只是保存一个简单的指针。</p>

<p>当然，block 可能也会嵌套block，那么又会是什么样子？其实不复杂，复杂的只是增加了复制函数，和释放函数，这一点很像C++的拷贝构造函数，在必要时生成。</p>

<pre><code>void (^existingBlock)(void) = …;
void (^vv)(void) = ^{existingBlock();};
vv();
struct __block_literal_3{
    ...;//esisting block
};
struct __block_literal_4{
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(struct __block_literal_4 *);
    struct __block_literal_3 *const existingBlock;
};
void __block_invoke_4(struct __block_literal_3 *__block) {
   __block-&gt;existingBlock-&gt;invoke(__block-&gt;existingBlock);
}
void __block_copy_4(struct __block_literal_4 *dst, struct __block_literal_4 *src) {
     //_Block_copy_assign(&amp;dst-&gt;existingBlock, src-&gt;existingBlock, 0);
     _Block_object_assign(&amp;dst-&gt;existingBlock, src-&gt;existingBlock, BLOCK_FIELD_IS_BLOCK);
}
void __block_dispose_4(struct __block_literal_4 *src) {
     // was _Block_destroy
     _Block_object_dispose(src-&gt;existingBlock, BLOCK_FIELD_IS_BLOCK);
}
static struct __block_descriptor_4 {
    unsigned long int reserved;
    unsigned long int Block_size;
    void (*copy_helper)(struct __block_literal_4 *dst, struct __block_literal_4 *src);
    void (*dispose_helper)(struct __block_literal_4 *);
} __block_descriptor_4 = {
    0,
    sizeof(struct __block_literal_4),
    __block_copy_4,
    __block_dispose_4,
};
</code></pre>

<p>初始化</p>

<pre><code>  struct __block_literal_4 _block_literal = {
    &amp;_NSConcreteStackBlock,
    (1&lt;&lt;25)|(1&lt;&lt;29), &lt;uninitialized&gt;
    __block_invoke_4,
    &amp; __block_descriptor_4
        existingBlock,
   };


__block storage variables

__block  变量是一种很特殊的数据类型，有自己的特有的数据结构

struct _block_byref_xxxx {
    void *isa;
    struct _block_byref_xxxx *forwarding;
    int flags;   //refcount;
    int size;
    // helper functions called via Block_copy() and Block_release()
    void (*byref_keep)(void  *dst, void *src); //需要时被生成
    void (*byref_dispose)(void *);//需要时被生成
    typeof(marked_variable) marked_variable;
};
</code></pre>

<p>看看__block 类型变量的使用</p>

<pre><code>int __block i = 10;
i = 11;
struct _block_byref_i {
    void *isa;
    struct _block_byref_i *forwarding;
    int flags;   //refcount;
    int size;
    int captured_i;
} i = { NULL, &amp;i, 0, sizeof(struct _block_byref_i), 10 };
i.forwarding-&gt;captured_i = 11;
</code></pre>

<p>显然，当block中增加了<strong>block 类型变量之后，嵌套block 的拷贝函数也会增加对</strong>block 变量的复制。</p>

<pre><code>__block void (voidBlock)(void) = blockA;
voidBlock = blockB;
struct _block_byref_voidBlock {
    void *isa;
    struct _block_byref_voidBlock *forwarding;
    int flags;   //refcount;
    int size;
    void (*byref_keep)(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src);
    void (*byref_dispose)(struct _block_byref_voidBlock *);
    void (^captured_voidBlock)(void);
};
void _block_byref_keep_helper(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src) {
    //_Block_copy_assign(&amp;dst-&gt;captured_voidBlock, src-&gt;captured_voidBlock, 0);
    _Block_object_assign(&amp;dst-&gt;captured_voidBlock, src-&gt;captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);
}
void _block_byref_dispose_helper(struct _block_byref_voidBlock *param) {
    //_Block_destroy(param-&gt;captured_voidBlock, 0);
    _Block_object_dispose(param-&gt;captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER)}
struct _block_byref_voidBlock voidBlock = {( .forwarding=&amp;voidBlock, .flags=(1&lt;&lt;25), .size=sizeof(struct _block_byref_voidBlock *),
      .byref_keep=_block_byref_keep_helper, .byref_dispose=_block_byref_dispose_helper,
      .captured_voidBlock=blockA )};
voidBlock.forwarding-&gt;captured_voidBlock = blockB;
</code></pre>

<p>block中，引入了__block 会是什么情况</p>

<pre><code>int __block i = 2;
functioncall(^{ i = 10; });
struct _block_byref_i {
    void *isa;  // set to NULL
    struct _block_byref_voidBlock *forwarding;
    int flags;   //refcount;
    int size;
    void (*byref_keep)(struct _block_byref_i *dst, struct _block_byref_i *src);
    void (*byref_dispose)(struct _block_byref_i *);
    int captured_i;
};
struct __block_literal_5 {
    void *isa;
    int flags;
    int reserved; 
    void (*invoke)(struct __block_literal_5 *);
    struct __block_descriptor_5 *descriptor;
    struct _block_byref_i *i_holder;
};
void __block_invoke_5(struct __block_literal_5 *_block) {
   _block-&gt;i_holder-&gt;forwarding-&gt;captured_i = 10;
}
void __block_copy_5(struct __block_literal_5 *dst, struct __block_literal_5 *src) {
     _Block_object_assign(&amp;dst-&gt;i_holder, src-&gt;i_holder, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);
}
void __block_dispose_5(struct __block_literal_5 *src) {
     _Block_object_dispose(src-&gt;i_holder, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);
}
static struct __block_descriptor_5 {
    unsigned long int reserved;
    unsigned long int Block_size;
    void (*copy_helper)(struct __block_literal_5 *dst, struct __block_literal_5 *src);
    void (*dispose_helper)(struct __block_literal_5 *);
} __block_descriptor_5 = { 0, sizeof(struct __block_literal_5) __block_copy_5, __block_dispose_5 };
struct _block_byref_i i = {( .forwarding=&amp;i, .flags=0, .size=sizeof(struct _block_byref_i) )};
struct __block_literal_5 _block_literal = {
    &amp;_NSConcreteStackBlock,
    (1&lt;&lt;25)|(1&lt;&lt;29), &lt;uninitialized&gt;,
    __block_invoke_5,
    &amp;__block_descriptor_5,
        2,
   };
</code></pre>

<p>block 中的太多细节这里不做赘述，有兴趣的可以参考Block—ABI-Apple，也可以直接<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/runtime.c">这里</a>去看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[plan]]></title>
    <link href="http://studentdeng.github.com/blog/2012/01/13/plan/"/>
    <updated>2012-01-13T23:46:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/01/13/plan</id>
    <content type="html"><![CDATA[<p>不知不觉又是一年，又大了一岁，呵呵，说的很假，因为自己并没有真正的意识到自己又大了一岁，甚至自己现在的年龄都不能一口说出来，过去的一年，甚至之前，我都不能准确的说出我自己到底做了什么，混沌，浑浑噩噩的一生，没有目标，一切都是随心，一切都是随心而发，没有目的，达成不达成，似乎都不重要。那么自己心里到底有什么在乎的了？不知道，那么还有什么感兴趣的呢？</p>

<p>庄子是我最佩服的人，千年前的古人，都可以去猜测天道，追逐天地之本，而做为现代人的我，从小都希望自己能够成为其中的一员，哪怕只是能够感知到一点，为此沉沦数学，物理。</p>

<p>什么是天道，天道不以人类意志左右，甚至和普通人意志相反。而这也就造就了普通人永远无法理解天道。所以，我从来没有觉得自己是普通人，甚至乐于反着做。而今天，我觉得，我错了，因为我现在自己都不了解，原来追求的东西，随着时间的打磨，已经逐渐淡去。现在做的，只是随心而动，追求自己内心的想法——每件事情，比别人多做一点，多深入一点，至于是什么事情，别人的看法，已经不重要了，我发现，我这个理科生，居然是一个彻头彻尾的唯心主义者。</p>

<p>人的一生是要不断学习的。这里面的动力很简单：因为我们在有些方面还“无知”， 无知是做事情的一个障碍。我们如果想做好事情，就要求知，要改变这种无知的状况。而对于创业这件事情，也是我这20多年来，做的最大的一件事情，1年前，对于创业，我还是处在，拿着无知当无畏的状态，而且，现在也没有好多少，但是，我很感谢我们这个Team，包容了我很多缺点，替我遮挡了许多细枝末节，使得我还有时间有精力追求自己内心的想法，而且我相信，我最终一定能够成功，但是这里面的代价实在是太大了，我甚至不能确定，而且害怕，这个时间太长，而那些身边默默支持我的人已经离去，甚至永远看不到了。</p>

<p>我最讨厌的人，就是浪费时间的人，因为，我自己已经浪费了自己20多年的青春。所以，当我在大三的时候，我就已经意识到，自己需要改变这一点——痛恨那些走在我前面档我走路的人，浪费我时间的人。</p>

<p>而现在，我发现，挡在我前面的那个人，不是别人，就是自己。自己的惰性，侥幸心里，成功考验的不仅是智力，更是意志。就像处在激发态的原子，时间会不断地侵蚀他的能量，而如果想要挣脱枷锁，只能是不断地更快地吸取更多的能量。就像鲲鹏，如果沉迷于大海，永远不可能越出水面，飞翔在空中。</p>

<p>呼呼，扯了好多，看看我这一年做了什么，1年前是离毕业还有半年时。</p>

<p>我很庆幸，因为，在很多人不知道自己以后应该做什么时，我知道了我该做什么，计算机就是为我而生的科学，我也很庆幸，我在离开大学的最后半年里，我能够把大学中学到的和没有学到的东西，捏合到了一起，明白了大学这些课程讲述的意义，汇编程序设计，计算机体系结构，编译原理等等耳熟能详的课程捏到一起，虽然不能融会贯通，但是计算机知识体系已经能够较为清晰的展现在脑海里，而这，也就是为什么我放弃考研的原因之一，不需要再学太多的理论来夯实基础，因为我不是要成为科学家，这些理论知识对现在的我来说已经足够，贪多嚼不烂。而更为重要的是，移动互联网，这一波已经滚滚而来，已经不可能在等我3年，就像我大二时，第一次用到智能手机时（Symbian不算）的感触，传统的PC应用已经不可能吸引我，除了mobile。</p>

<p>大学最后的半年，是在创业公司渡过的，第一次自己独立做项目（自己的毕设），而且是一个会正式发布的产品，对于我这样的一个二流大学毕业生来说已经不易。而后的毕业答辩，更是验证了我对学校的不屑，只能挑挑排版错误的导师，充满各种潜规则的评分，对我来说已经没有任何意义，90分和60分，同样没有区别。我唯一在意的是，最后半年，C++的基础打的更扎实了一点，windows消息机制的了解也更深入了一点。也不枉我在这里学习了将近1年的时间。</p>

<p>后半年，风雨突变，windows mobile 已经死在了IOS 和android 的车轮之下，顺应天意，转战IOS。</p>

<p>从0开始学习一个新的语言，新的平台，到产品上线，呵呵，虽然在Appstore 很惨淡，但是，我们并没有放弃，不说了，来年新产品上线再说，不信这个邪了。</p>

<p>总结之后，就要规划，虽然我实在是不想做这个规划，因为实在是不靠谱。1年的时间，说长不长，说短不短。不求别的，只求不浪费时间，全力学习，深入IOS 一点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转 从无知到有知]]></title>
    <link href="http://studentdeng.github.com/blog/2012/01/13/knownless/"/>
    <updated>2012-01-13T23:45:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/01/13/knownless</id>
    <content type="html"><![CDATA[<p>人的一生是要不断学习的。这里面的动力很简单：因为我们在有些方面还“无知”， 无知是做事情的一个障碍。我们如果想做好事情，就要求知，要改变这种无知的状况。</p>

<p>可是大多数人不知道的是，“无知” (ignorance) 其实不是一个状态，而是两个截然不同的状态，一种叫做不知道型无知 (uninformed ignorance)，另一种叫做知道型无知 (informed ignorance)。 相信很多人都有这个体会：某天看到一本书，一篇文章，觉得这里面的学问知识，是自己从来没有想过或者接触过的，是一个崭新的领域，这就代表了你突然发现了自己的无知，而且知道自己的这种无知，也就是，从 uninformed ignorance 跨入了 informed ignorance. 这两种无知的另一个不同在于，第一种无知可以让人无知无畏，因为自己不会认识到这种无知。第二种反而让人小心翼翼，知道自己不懂这方面的知识，或者咨询专业人士，或者恶补相关的知识。我们人生下来，所有的知识都在脑袋的外部，所以，我们最初处于一个纯粹的 uninformed ignorance 状态, 所以，从无知到有知，必然要经过两个过程，第一个过程是从第一种无知变到第二种无知；第二种是消灭部分的第二类无知，达到部分有知。 这两个过程其实截然不同，但是实际上我们常常把他们混淆。</p>

<p>第一个过程其实是非常轻松愉快的过程，甚至不需要花太多的力气。有句话叫见多识广，就是说游山玩水也能增广见识。 在互联网发达的今天，随便点几个链接，随便查几个维基百科，都能够让人获得“增长见闻”的感觉。 这是一个好事，因为我们更加容易的发现自己的无知。 同时，在这个过程里也很容易有认知满足感。 所以，很多人不知不觉的觉得每天只要“增广见闻”就行了，轻松愉快又每天都有新的见闻输入，是多么美好的事情呀。不幸的是，这个过程至多只能让人 informed, 而不能让人 knowledgeable。 想要 knowledge, 绕不过去的是持久的，深入的，有系统的学习。更加不幸的是，这个过程是不那么轻松愉快的。</p>

<p>我上高中的时候非常喜欢数学，正好图书馆里面有大学数学书，我就不管看得懂看不懂都借来看，看着那些如“微分方程”，“复变函数”之类的名词觉得很欣喜，虽然是不断的发现自己以前的无知，却也觉得学到了新东西，新名词，新概念。可是总所周知，“看”是不需要花费任何脑力的，尤其是从不知道到知道自己不知道这个状态，简直就是所谓的顿悟（由此我也怀疑所谓的顿悟其实可能也是突然间觉得自己是个笨蛋，也就悟了）。 就这样，我一度以为自己在数学上是非常的 knowledgeable 了。 然后我大学上了数学系，我突然发现，高中看的那些书，虽然也看了，也仅仅是知道名词 ( informed ) 而已，真正的数学训练，还是等到我用书中知识做后面习题的时候才开始的，而这个过程才不是轻松愉快呢。 我不知道是不是普遍的情况，就我见到的同学，有很多高中原来很喜欢某个专业的，等到真的选了这个专业，突然就不喜欢了，这也是 be informed 和 be knowledgeable 两种认知过程不一样造成的。 这种两种认知过程，是不管怎么都没法互相替代的。换句话说，如果只想捡便宜果子吃，只做第一步，或者用第一步里面的那些轻松愉快来代替第二步，就想变成有知识的人，是不可能的。</p>

<p>缺少持久，系统和深入的学习，知识结构就会处于半调子的状态。 李笑来老师在学英语的若干文章中都提到精读和查字典的重要性。比如说，如果在学英语中满足于 informed ignorance， 遇到不认识的单词仅仅是猜一个意思，也不记下这个单词的用法的话，这个单词还是不能成为自己的词汇。然后，如果仅仅是记下用法，而不在以后有意识的练习使用（或者多次再见到）这个词的话，或许很快也就忘掉了。我们对学语言要系统的精耕细作很同意，但是未必能体会到所有其他学科都需要如此，尤其是在那些我们认为“简单”或者“零碎”的领域，我们往往像蜜蜂一样，成了不知疲倦的收集者，不断的 be informed, 而忘了 be knowledgeable 的背后，不是收集，而是学习。知道自己无知是一件非常好的事情，不过不要容忍处于 knowledge 和  be informed之间的尴尬处境，要不代理给专业人士，要不，抓紧时间学习，赶快从无知，到有知。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C 一些很基础的总结]]></title>
    <link href="http://studentdeng.github.com/blog/2012/01/12/objcbase/"/>
    <updated>2012-01-12T23:39:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/01/12/objcbase</id>
    <content type="html"><![CDATA[<p>学习 Objective-C大概4个月了，居然给一个还没毕业的家伙吹了吹，呼，希望不要误人子弟。这里总结一下，毕竟这是第一次完整的讲一个东西。</p>

<p>附上PPT<a href="http://files.cnblogs.com/studentdeng/Objective-CPrimary.pptx">Objective-C Primary</a> 。资源99%来自WWDC 2010 session 113。</p>

<p>Common Concepts</p>

<p>Objective-C 相对其他更了解的C++语言来说，还是有些不同的。如下表</p>

<p><img src="http://studentdeng.github.com/images/objbase-1.png" alt="alt text" /></p>

<p>这里面有几点比较重要</p>

<p>Objective-C 中所有的类，其实是另一种“类”的对象，所以Objective-C 中的类方法，其实是另一种类的实例方法。 Objective-C Message
Objective-C 中没有静态变量，都是用全局变量实现的。
Category
如何给一个类增加一个函数方法，在C++中是不可能的（或是很难）但是在Objective-C中确实很简单的事情，category 做的就是这件事情。</p>

<p>当第一次看到category 时，我几乎肯定这是一个非常坑爹的设计，因为这个可以完美的覆盖原有类的方法，如果使用不当，绝对是灾难性的错误。但是，随着使用时间变长category 的好处也慢慢体会出来。</p>

<p>给系统原有的类或是第三方的类增加函数，而不用使用一个新的类，这样使用会更加方便，特别是使用IB时，不需要将系统的类换成自己定义的类，这样减少了非常多的移植问题和同步工作。
当然，如果使用不当，也会遇到问题</p>

<p>函数覆盖问题，之前提到过
增加大量的category 会降低系统性能，特别是如果大量的加到一些基础类上，如NSObject 等，因为，几乎整个系统都在使用这些类，而过多的category，不仅降低自己代码的效率，也会降低framework代码的效率，这里的效率，应该主要在类初始化上，和消息发送上面。
SEL</p>

<p>相关的内容在Objective C SEL
Memory Management
语言是离不开平台的，而内存管理，则是了解平台中最基础的部分。而cocoa touch 的内存设计也就是基于引用计数的设计，是针对很早以前的设备设计，显然不适合现在的硬件设备。但是，现在我们似乎没有其他的选择，在一开始学习时。</p>

<p>基于引用计数的内存管理，设计的本质其实就是一个Directed Acyclic Graph（有向无回图）</p>

<p><img src="http://studentdeng.github.com/images/objbase-2.png" alt="alt text" /></p>

<p>对于引用计数的内存管理，这一点实在是不陌生，不管是什么语言，都会遇到一个问题，循环引用</p>

<p><img src="http://studentdeng.github.com/images/objbase-3.png" alt="alt text" /></p>

<p>当形成回路时，循环引用发生，导致内存泄露。而对应的方法，不管是什么语言，都需要把引用分为强引用和弱引用</p>

<p><img src="http://studentdeng.github.com/images/objbase-4.png" alt="alt text" /></p>

<p>解决引用循环的方法很多，但是实质上，都是通过抽象成父子关系来做，一个强引用，一个弱引用，图形下方的节点通过弱引用连接上面的节点，图形上方的节点，通过强引用连接下方节点。实例就是delegate，属性被声明为assign</p>

<p>Autorelease Pools
autorelease 应该是初学者最容易糊涂的地方，一开始我也非常害怕使用Autorelease 变量，因为，这些变量不仅会增大内存开销，而且使用不当，crash的位置就是main函数，调试器几乎没有任何帮助，但是仍然有非常多的framework是基于autorelease 变量的，所以还是需要屡屡。</p>

<p>cocoa touch 是事件驱动的，我们通过接受一个个的event来跑我们的程序，那么简单的讲，就是一个while的死循环，不断地获取一个event，处理一个event。</p>

<p><img src="http://studentdeng.github.com/images/objbase-5.png" alt="alt text" /></p>

<p>处理event的时候，framework 帮我们建立了一个autorelease pool。</p>

<p><img src="http://studentdeng.github.com/images/objbase-6.png" alt="alt text" /></p>

<p>当我们处理或是叫响应一个event时，比如调用了[NSDate date] 函数，这个函数，返回了一个autorelease 变量d</p>

<p>而这个变量，事实上是被autorelease pool 所引用。</p>

<p><img src="http://studentdeng.github.com/images/objbase-7.png" alt="alt text" /></p>

<p>当一层层stack pop 之后，我们可以看到 autorelease 变量的生命周期</p>

<p><img src="http://studentdeng.github.com/images/objbase-8.png" alt="alt text" /></p>

<p><img src="http://studentdeng.github.com/images/objbase-9.png" alt="alt text" /></p>

<p>当调用[pool drain]后，autorelease pool 随之消失，伴随着还有那个var d，回到原点，在下一个event cycle</p>

<p><img src="http://studentdeng.github.com/images/objbase-10.png" alt="alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective C SEL]]></title>
    <link href="http://studentdeng.github.com/blog/2011/10/16/objcsel/"/>
    <updated>2011-10-16T23:37:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2011/10/16/objcsel</id>
    <content type="html"><![CDATA[<p>上一篇http://www.cnblogs.com/studentdeng/archive/2011/10/06/2199873.html，总结了一点关于Objective C message send 的有意思的东西，中间穿插了一点关于SEL有趣的东西，之前，我们知道Objective-C runtime 在处理selector时，是做一个unique hash set， 那么今天，我们看看这个set 是如何产生的。这篇文章参考了<a href="http://www.sealiesoftware.com/blog/archive/2009/09/01/objc_explain_Selector_uniquing_in_the_dyld_shared_cache.html">link</a></p>

<p>unique set的好处是，字符串的比较可以非常迅速，但是也带来一个棘手的问题，创建一个这样的集合，真的不容易。虽然我们能够在compiler和 link的时候保证我们程序中唯一，但是这还远远不够，因为我们并不是生活在真空中，我们的程序需要和各种各样的其他程序协同工作，那么如何能够在这种繁杂的各种情况下，保证唯一呢？</p>

<p>简单说，就是在程序A中，有一个@selector（customInit），但在程序A中引入了程序B，而B中也有一个@selector（customInit），那么，显然，我们需要修正这2个selector，使他们指向同一个内存地址，这样才能保证消息发送正确。</p>

<p>好吧，我们程序员又要惊呼了，这是一个非常非常大的开销，因为</p>

<p>1、我们只能在运行时做这些工作。</p>

<p>2、这些工作是不可能不绕过strcmp（创建hash表时，如果发生了冲突，我们为了保证绝对正确，只能strcmp）。</p>

<p>3、当我们修正之后，也意味着，我们浪费了空间，而实际上就是我们创建了一个更大的hashtable（元素越多，发生碰撞的概率越大，空间的开销越大），</p>

<p>4、代码段在被映射到内存地址空间时，都在可读地址空间上，那么修正，意味着我们又多做了copy-on-write，同样意味着更多的空间开销</p>

<p>5、事实上，这样的函数还非常多，那些界面库函数等等，几乎被所有app引用 e.g. init，initWithFrame:。</p>

<p>更多的空间，更多的比较，导致了性能下降，特别是在程序载入时。事实上，runtime 和os 为我们的selector unique 做了下面的优化，大体可以理解成2个部分</p>

<h2>1、减少需要修正的selector 集合</h2>

<p>之前，我们看到的只有一个hash set，在runtime 载入时创建，但是，现在我们有了2个set（这个set是在Snow Leopard被加入的）。</p>

<p>一个是之前我们知道的，另一个也是一个hash set 当然，特别的是，这是一个perfect hash set。</p>

<p>从之前的5条件中，我们知道了，这些常用的如系统库函数，cocoa.framework中的selector 几乎被所有app引用，而且，我们非常开心的看到了，这些函数，都是可以确定的固定集合。事实上，dyld（dynamic loader and linker），给我们build了一个dyld shared cache，而且是一个perfect hash。而这个被映射到了各种app内存地址空间，并被共享。当我们创建unique selector set 时，我们可以先查找这个perfect hash set，来判断，我们是不是需要动态扩展我们的程序自己的selector hash set。而且，由于是perfect hash，使我们能够拥有在最坏情况下常数时间的开销。</p>

<h2>2、延迟加载</h2>

<p>对于这个，我们已经不陌生了，不管是windows dll 中的延时加载，还是各种在linux中的动态模块的延时载入，原理都是一样的。这些工作，只有在认为是必要条件时，才被真正的加载并初始化。</p>

<p>说的实在是太空了，让我们来看代码吧。</p>

<p>当类被调用或是说在被发送消息之前，类，需要被初始化一下，做的工作就是一些，运行时必要的空间分配，初始化，修正selector，methodlist， propertylist，categorylist等等的工作，我们这里，只是关注selector部分。</p>

<p>prepareForMethodLookup->realizeClass –> methodizeClass->attachMethodLists->fixupMethodList.</p>

<p>经过一系列的东东，修正我们的methodlist时，我们需要将methodlist中的SEL 修正，而这个过程就是我们关注的select unique。</p>

<p>不知道，大家还记得不记得，上一篇讲的 method结构</p>

<pre><code>typedef struct method_list_t {

uint32_t entsize_NEVER_USE;  // low 2 bits used for fixup markers

uint32_t count;

struct method_t first;

} method_list_t;

typedef struct method_t {

SEL name;

const char *types;

IMP imp;

} method_t




static void 
fixupMethodList(method_list_t *mlist, BOOL bundleCopy) 
{ 
    assert(!isMethodListFixedUp(mlist));

    // fixme lock less in attachMethodLists ? 
    sel_lock();

    uint32_t m; 
    for (m = 0; m &lt; mlist-&gt;count; m++) {

        //studentdeng note：fixup selector and make sure selector unique 
        method_t *meth = method_list_nth(mlist, m); 
        SEL sel = sel_registerNameNoLock((const char *)meth-&gt;name, bundleCopy); 
        meth-&gt;name = sel;

        if (sel == (SEL)kIgnore) { 
            meth-&gt;imp = (IMP)&amp;_objc_ignored_method; 
        } 
    }

    sel_unlock();

    setMethodListFixedUp(mlist); 
}






sel_registerNameNoLock-&gt;__sel_registerName


static SEL __sel_registerName(const char *name, int lock, int copy) 
{ 
    SEL result = 0;

    if (lock) rwlock_assert_unlocked(&amp;selLock); 
    else rwlock_assert_writing(&amp;selLock);

    if (!name) return (SEL)0; 
    result = _objc_search_builtins(name); //studentdeng note:这里就是查找perfect hash set build by dyld cache 
    if (result) return result; 

    if (lock) rwlock_read(&amp;selLock); 
    if (_objc_selectors) { 
        result = __objc_sel_set_get(_objc_selectors, (SEL)name); //studentdeng note: 这里就是查找我们程序自己的hash set 
    } 
    if (lock) rwlock_unlock_read(&amp;selLock); 
    if (result) return result;

    // No match. Insert.

    if (lock) rwlock_write(&amp;selLock);

    if (!_objc_selectors) { 
        _objc_selectors = __objc_sel_set_create(NUM_NONBUILTIN_SELS); 
    } 
    if (lock) { 
        // Rescan in case it was added while we dropped the lock 
        result = __objc_sel_set_get(_objc_selectors, (SEL)name); 
    } 
    if (!result) { 
        result = (SEL)(copy ? _strdup_internal(name) : name); 
        __objc_sel_set_add(_objc_selectors, result); 
#if defined(DUMP_UNKNOWN_SELECTORS) 
        printf("\t\"%s\",\n", name); 
#endif 
    }

    if (lock) rwlock_unlock_write(&amp;selLock); 
    return result; 
}
</code></pre>

<p>牛b的代码，从来都是自解释的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Message]]></title>
    <link href="http://studentdeng.github.com/blog/2011/10/06/objcmessage/"/>
    <updated>2011-10-06T23:35:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2011/10/06/objcmessage</id>
    <content type="html"><![CDATA[<p>object c 里面有一个非常有趣的设计，如果之前了解过c++的家伙们，对object c 中的把传统的调用函数变成了向这个类发送消息，这个过程总是令人琢磨不透，在实际过程中遇到的crash也很难调试清楚。这篇就要详细的解释消息这个家伙。当然，消息这个涉及的东西实在是太多了。这篇先简单介绍一下。</p>

<p>上一篇，我们了解了什么是类http://www.cnblogs.com/studentdeng/archive/2011/10/01/2197194.html。同理这一篇，我们首先需要了解什么是message。</p>

<p>message（消息）：message的具体定义很难说，因为并没有真正的代码描述，简单的讲message 是一种抽象，包括了函数名+参数列表，他并没有实际的实体存在。</p>

<p>method（方法）：method是真正的存在的代码。如：- (int)meaning { return 42; }</p>

<p>selector: selector 通过SEL类型存在，描述一个特定的method or message。在实际编程中，可以通过selector来检索函数等操作。</p>

<p>我不知道上面这种描述有多少人可以明白，因为我觉得这3个每个人都可以有自己的看法，在了解object c message 的整个过程之后。</p>

<p>让我们从一个简单的例子开始。当我们写好如下的代码时</p>

<pre><code>- (int)foo:(NSString *)str { ...}
</code></pre>

<p>　　</p>

<p>编译器事实上转成了下面的样子</p>

<pre><code>int XXXX_XXXX_foo_(SomeClass *self, SEL _cmd, NSString *str) { ...}
</code></pre>

<p>　　</p>

<p>当我们写下发送消息的代码如</p>

<pre><code>int result = [obj foo:@"hello"];
</code></pre>

<p>　　</p>

<p>实际上变成了</p>

<pre><code>int result = ((int (*)(id, SEL, NSString *))objc_msgSend)(obj, @selector(foo:), @"hello");
</code></pre>

<p>　　</p>

<p>而 objc_msgSend 是一个我们非常熟悉的C函数定义 id objc_msgSend(id self, SEL    _cmd,&#8230;);
那么，object c 发送消息就变成了一个表面上看似容易理解的C函数调用了，这里有必要解释一下几个名词</p>

<pre><code>id：很多地方说id是一个void *的指针。事实上，id 其实是这样子的
typedef struct objc_object {
    Class isa;
} *id;
</code></pre>

<p>　　</p>

<p>也就是说。id其实是一个可以指向任何一个object指针（只要结构体中包含isa 指针） 。</p>

<pre><code>SEL：SEL 如果很粗鲁（我不知道改用什么其他词汇更容易描述）的讲，就是一个char * 的指针。因为你可以这样简单粗暴的测试

SEL selector = @selector(message); //@selector不是函数调用，只是给这个坑爹的编译器的一个提示
NSLog (@"%s", (char *)selector);  //print message 
</code></pre>

<p>　　</p>

<p>注：这里之所以说粗鲁，是因为，这个的定义和object runtime 的具体实现息息相关，未来很可能改变，而这些定义也是没有文档化的，后面还会详细介绍SEL的具体实现。因为这里有不少为了提高效率而做的优化。</p>

<p>不知道有没有人惊呼这个问题。特别是如果之前从事C++的家伙们。传统的C++ 编译器在处理函数上，为了支持函数重载。使用了一种函数别名的方式如</p>

<pre><code>int foo（int a）；
</code></pre>

<p>　　</p>

<p>变成了 XXX_1_foo_int （具体的形式没有意义，核心在于，编译器生成的函数签名包括函数名，参数类型，参数个数）。</p>

<p>但我们的SEL 仅仅是函数名而已。</p>

<p>有了这些知识做铺垫，原谅我在把这个东东再搬出来</p>

<pre><code>int result = ((int (*)(id, SEL, NSString *))objc_msgSend)(obj, @selector(foo:), @"hello");
</code></pre>

<p>　　</p>

<p>那么，作为程序员，我们就为这个而疯狂了，因为编译器无法根据id 和SEL 获得完整的函数签名，编译器对参数个数和类型，完全不知道。那么他如何能过做到识别这些并找到正确的代码呢？</p>

<p>事实上这个头痛的问题，编译器做了一个非常坑爹的事情，就是“ it cheats” ，他假装能够通过函数名，就能确定正确的代码。通过扫描之前的函数声明来做，如果没有找到，编译器就认为这是一个运行时（runtime）的函数而直接略过。而这也就导致了object c 在处理有相同函数名和参数个数但类型不同的函数时，非常的弱。如</p>

<pre><code>-(void)setWidth:(int)width；

-(void)setWidth:(double)width；
</code></pre>

<p>　　</p>

<p>这样的函数则被认为是一种编译错误，而这最终导致了一个非常非常奇怪的object c 特色的函数命名</p>

<pre><code>-(void)setWidthIntValue:(int)width；

-(void)setWidthDoubleValue:(double)width；
</code></pre>

<p>　　</p>

<p>注：这样的函数命名的好坏，只能说是因人而异的，站在我的角度来讲。object c 的这种命名实在是太臃肿了，这种冗长的名字让人感到作呕而没有任何美感。当然，这样的命名的确可以避免很多的错误，比如因C++ 函数重载而引起的人为上的小失误，而且减少了理解函数的负担。总有利弊，需要平衡：P，不过，我还是不喜欢object c 编译器，因为他彻底阻挡了你的想法，至于为什么这样设计，我的理解是为了runtime，在这里为了性能而做了妥协，具体原因，后面再讲。</p>

<pre><code>popup our brain stack
</code></pre>

<p>objc_msgSend 这里传入了 class 指针 self  函数名SEL 已经后面通过C的不定参数传入的参数。通过这些条件。就像之前的C++函数那样，需要查表，并找到相应函数的位置，然后call xxxxx。那么。object c 是如何找到这些函数的真实地址呢？ 之前有篇简单描述C++类函数布局的，有兴趣的可以对比的看。</p>

<p>为了解释这些这个过程，我们有需要介入一些名词了。</p>

<pre><code>object c 2 的

typedef struct method_list_t {
    uint32_t entsize_NEVER_USE;  // low 2 bits used for fixup markers
    uint32_t count;
    struct method_t first;
} method_list_t;

typedef struct method_t {
    SEL name;
    const char *types;
    IMP imp;
} method_t;
</code></pre>

<p>　　</p>

<p>method就是这么简单， 一个函数名SEL 一个包括的参数类型和返回类型的type 最后加一个IMP 而IMP 就是一个函数指针，指向我们真正的代码位置</p>

<pre><code>typedef id             (*IMP)(id, SEL, ...); 
</code></pre>

<p>　　</p>

<p>那么objc_msgSend 做的事情，就是通过我们传入的self 指针，找到class 的method_list 然后根据SEL 做比较，没有的话，就在super class 找，如此往复。直到找到匹配的SEL，然后，call imp。</p>

<p>那么，我们就发现了。如果object c 这样设计，调用函数的成本实在是太高了，相对传统的C函数调用。那么编译器和runtime又做了那些优化呢？有意思的事情开始了。</p>

<p>1、字符串比较
我们发现了SEL 就是简单的一个char* 字符串。那么，光是比较这一串字符，就可以让object c 慢的让人作呕了。那么我们就需要再认识一下我们的SEL了。</p>

<p>runtime 在实现selector是，实现了一个很大的Set，简单的说就是一个经过了杠杠优化过的hash表。而Set的特点就是唯一，也就是SEL是唯一的。那么对于字符串的比较仅仅需要比较他们的地址就可以了。犀利，速度上无语伦比，但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少，那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。这样如</p>

<p>class A 有一个这样的method  -(void)setWidth:(int)width；</p>

<p>而 classB 有一个这样的method -(void)setWidth:(double)width；</p>

<p>那么的selector 将指向同一个地方，使用同一个selector，如果真的需要在类中定义类似重载时，只能使用不同的函数名了。</p>

<p>但是，这样的优化，依然不能让人满意，因为，根据二八原则，我们真正执行的只是少数代码。那么。就有</p>

<p>2、cache
cache的原则就是缓存那些可能要执行的函数地址，那么下次调用的时候，速度就可以快速很多。这个和CPU的各种缓存原理相通。好吧，说了这么多了，再来认识几个名词</p>

<pre><code>struct objc_cache {
    uintptr_t mask;            /* total = mask + 1 */
    uintptr_t occupied;        
    cache_entry *buckets[1];
};

typedef struct {
    SEL name;     // same layout as struct old_method
    void *unused;
    IMP imp;  // same layout as struct old_method
} cache_entry;
</code></pre>

<p>　　</p>

<p>看这个结构，有没有搞错又是hash table。</p>

<p>objc_msgSend 首先在cache list 中找SEL 没有找到就在class 找，super class 找（当然super class 也有cache list）。</p>

<p>而cache的机制则非常复杂了，由于object c 是动态语言。所以，这里面还有很多的多线程同步问题，而这些锁又是效率的大敌，相关的内容已经远远超过本文讨论的范围。</p>

<p>popup our brain stack</p>

<p>有了上面的粗略的介绍，是时候让我们看看objc_msgSend 的真面目了，当然，对于这个家伙是和性能息息相关的东西，没有任何缘由的是用汇编来写的。这里面贴出x86的，原谅我已经把arm汇编忘记了（主要原因是arm汇编是老师教得，x86是自学的，没有听学校老师的 ：P）。</p>

<pre><code>/********************************************************************
 *
 * id objc_msgSend(id self, SEL    _cmd,...);
 *
 ********************************************************************/

    ENTRY    _objc_msgSend
    CALL_MCOUNTER    LP0

    movl    self(%esp), %eax

// check whether receiver is nil 
    testl    %eax, %eax
    je    LMsgSendNilSelf

// receiver is non-nil: search the cache
    CacheLookup WORD_RETURN, MSG_SEND, LMsgSendCacheMiss
    movl    $kFwdMsgSend, %edx    // flag word-return for _objc_msgForward
    jmp    *%eax            // goto *imp

// cache miss: go search the method lists
LMsgSendCacheMiss:
    MethodTableLookup WORD_RETURN, MSG_SEND
    movl    $kFwdMsgSend, %edx    // flag word-return for _objc_msgForward
    jmp    *%eax            // goto *imp

// message sent to nil object: call optional handler and return nil
LMsgSendNilSelf:
    EXTERN_TO_REG(__objc_msgNil,%eax)
    movl    0(%eax), %eax        // load nil message handler
    testl    %eax, %eax
    je    LMsgSendDone        // if NULL just return and don't do anything
    call    *%eax            // call __objc_msgNil
    xorl    %eax, %eax        // Rezero $eax just in case
LMsgSendDone:
    ret

LMsgSendExit:
    END_ENTRY    _objc_msgSend
</code></pre>

<p>　　</p>

<p>注释非常的详细+代码本身自解释，不做赘述，汇编的可读性都比我写的强，牛到不需要解释的代码。</p>

<p>MethodTableLookup 跳到__class_lookupMethodAndLoadCache</p>

<pre><code>/***********************************************************************
* lookUpMethod.
* The standard method lookup. 
* initialize==NO tries to avoid +initialize (but sometimes fails)
* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
* Most callers should use initialize==YES and cache==YES.
* May return _objc_msgForward_internal. IMPs destined for external use 
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
**********************************************************************/
__private_extern__ IMP lookUpMethod(Class cls, SEL sel, 
                                    BOOL initialize, BOOL cache)
{
    Class curClass;
    IMP methodPC = NULL;
    Method meth;
    BOOL triedResolver = NO;

    // Optimistic cache lookup
    if (cache) {
        methodPC = _cache_getImp(cls, sel);
        if (methodPC) return methodPC;    
    }

    // realize, +initialize, and any special early exit
    methodPC = prepareForMethodLookup(cls, sel, initialize);
    if (methodPC) return methodPC;


    // The lock is held to make method-lookup + cache-fill atomic 
    // with respect to method addition. Otherwise, a category could 
    // be added but ignored indefinitely because the cache was re-filled 
    // with the old value after the cache flush on behalf of the category.
 retry:
    lockForMethodLookup();

    // Try this class's cache.

    //// self note 这里再次查找cache 是因为有可能cache真的又有了，因为锁的原因
    methodPC = _cache_getImp(cls, sel);
    if (methodPC) goto done;

    // Try this class's method lists.

     //self note 这个就是简单的在method 一个线性查找，因为我们仅仅是一个地址比较
    meth = _class_getMethodNoSuper_nolock(cls, sel); 
    if (meth) {
        //我们找到了函数地址，那么添加到cachelist中
        log_and_fill_cache(cls, cls, meth, sel);
        methodPC = method_getImplementation(meth);
        goto done;
    }

    // Try superclass caches and method lists.

    curClass = cls;
    while ((curClass = _class_getSuperclass(curClass))) {
        // Superclass cache.
        meth = _cache_getMethod(curClass, sel, &amp;_objc_msgForward_internal);
        if (meth) {
            if (meth != (Method)1) {
                // Found the method in a superclass. Cache it in this class.
                log_and_fill_cache(cls, curClass, meth, sel);
                methodPC = method_getImplementation(meth);
                goto done;
            }
            else {
                // Found a forward:: entry in a superclass.
                // Stop searching, but don't cache yet; call method 
                // resolver for this class first.
                break;
            }
        }

        // Superclass method list.
        meth = _class_getMethodNoSuper_nolock(curClass, sel);
        if (meth) {
            log_and_fill_cache(cls, curClass, meth, sel);
            methodPC = method_getImplementation(meth);
            goto done;
        }
    }

    // No implementation found. Try method resolver once.

    if (!triedResolver) {
        unlockForMethodLookup();
        _class_resolveMethod(cls, sel);
        // Don't cache the result; we don't hold the lock so it may have 
        // changed already. Re-do the search from scratch instead.
        triedResolver = YES;
        goto retry;
    }

    // No implementation found, and method resolver didn't help. 
    // Use forwarding.

    _cache_addForwardEntry(cls, sel);
    methodPC = &amp;_objc_msgForward_internal;

 done:
    unlockForMethodLookup();

    // paranoia: look for ignored selectors with non-ignored implementations
    assert(!(sel == (SEL)kIgnore  &amp;&amp;  methodPC != (IMP)&amp;_objc_ignored_method));

    return methodPC;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[objcclass]]></title>
    <link href="http://studentdeng.github.com/blog/2011/10/05/objcclass/"/>
    <updated>2011-10-05T23:31:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2011/10/05/objcclass</id>
    <content type="html"><![CDATA[<p>之前一直做C++开发，最近2个多月转 Objective-C， 入门的时候，遇到了很多的困惑。现在过节，正是解决他们的好时机。</p>

<p>主要参考来自http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</p>

<p> Objective-C 也是面向对象的语言，那么，首先需要知道的就是什么是class。</p>

<p>C++ 的class相对 Objective-C 中的class，就简单明了很多了。C++ 中class简单的说，就是一个大的struct， 绝大部分的class可以在编译时决定好class的布局（通过虚继承来的class成员变量只能动态确定）。当然，最关键的是，你不可能在运行时创建一个class，因为所有的class在运行之前已经确定下来，并保存在二进制文件中。</p>

<p>但是， Objective-C 确不同， Objective-C 可以在运行中创建class，修改class等等。那么，改如何定义 Objective-C 中的class呢。</p>

<p>在这之前，我们先看一个简单的，class的实例对象。</p>

<pre><code>@interface Object 
{

    //typedef struct objc_class *Class; 
    Class isa;    /* A pointer to the instance's class structure */ 
}
</code></pre>

<p>对象包含一个指向class的指针，而这也就意味着，任何包含class 的指针都可以被看做是对象（object）。</p>

<pre><code>struct objc_class {            
    struct objc_class *isa;    //这里也有isa指针 
    struct objc_class *super_class;    //这里还有一个指向基类的指针 
    const char *name;        
    long version; 
    long info; 
    long instance_size; 
    struct objc_ivar_list *ivars;

    struct objc_method_list **methodLists;

    struct objc_cache *cache; 
     struct objc_protocol_list *protocols; 
};

//新的定义
typedef struct class_t {

    struct class_t *isa;

    struct class_t *superclass;

    Cache cache;

    IMP *vtable;

    class_rw_t *data;

} class_t;
</code></pre>

<p>显然，在 Objective-C 眼中，一切都是对象，甚至包括我们的class。而对象就是class的实例，那么，class是什么的实例呢，metaclass。</p>

<p>事实上，我们并没有解决问题。metaclass 事实上又是root metaclass 的实例，而root metaclass 自己又是 root metaclass 的实例，一图胜千言，不做赘述。</p>

<p><img src="http://studentdeng.github.com/images/objc.png" alt="alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hash]]></title>
    <link href="http://studentdeng.github.com/blog/2011/08/26/hash/"/>
    <updated>2011-08-26T23:28:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2011/08/26/hash</id>
    <content type="html"><![CDATA[<p>在应用程序中，常常需要将一个集合U（键值集合）和另一个集合T（数据集合）建立关系构造dictionary结构，来达到增删查改的需求。如果键值集合很小，那么可以直接采用Direct-address tables的方式实现。</p>

<p>假如我们的集合 U = {0, 1, &#8230;, m - 1}, 而且m并不大。如果我们的键和值对应唯一，那么我们可以通过构造一个大的数组来保存集合U，如下结构。</p>

<p><img src="http://studentdeng.github.com/images/hash-1.png" alt="alt text" /></p>

<p>显然，当集合U增大，那么直接存储集合U变的不那么明智起来，而且，如果使用键的集合K变小是，我们浪费的空间也越来越大。当集合K比集合U小很多的时候，就是hash粉墨登场的时候了。hash将保存空间压缩到集合K的大小，并且控制查找元素的时间仍在O(1) 在平均情况下。</p>

<p>hash 通过hash函数h，将集合U 映射到hash表T[0,…, m-1]中， 即 h : U → {0, 1, &#8230;, m - 1}。显然，由于集合大小的限制，很可能造成有相同的key 指向了hash表中的同一项，如图。</p>

<p><img src="http://studentdeng.github.com/images/hash-2.png" alt="alt text" /></p>

<p>我们将这一情况称为碰撞（Collision），解决碰撞的方法很多，最容易想到的是通过链表来保存碰撞的key。</p>

<p><img src="http://studentdeng.github.com/images/hash-3.png" alt="alt text" /></p>

<p>一个简单的例子，linux2.4 在处理进程中，需要一个通过pid找到进程的要求，而具体实现则是利用了hash。在处理冲突时，采用的是链表的方法。不过由于是操作系统的代码，所以这里并不是通常意义的双向链表，pidhash_next 指向后一个进程，但是pidhash_pprev指向的是前一个进程的pidhash_next的地址。虽然不长，但是理解这段还是需要稍微动下脑筋，系统之所以这么实现，似乎是能够提高增加和删除时链表的效率。</p>

<pre><code>/* PID hashing. (shouldnt this be dynamic?) */ 
#define PIDHASH_SZ (4096 &gt;&gt; 2) 
extern struct task_struct *pidhash[PIDHASH_SZ]; 
#define pid_hashfn(x) ((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1)) 

static inline void hash_pid(struct task_struct *p) 
{ 
    struct task_struct **htable = &amp;pidhash[pid_hashfn(p-&gt;pid)]; 
    if((p-&gt;pidhash_next = *htable) != NULL)//如果发生的冲突 
        (*htable)-&gt;pidhash_pprev = &amp;p-&gt;pidhash_next;//这里可以看出，pprev是上一个进程的next指针的地址 
    *htable = p; 
    p-&gt;pidhash_pprev = htable;//新的进程的pprev是指向了hash表项中的自己的地址 
} 
static inline void unhash_pid(struct task_struct *p) 
{ 
    if(p-&gt;pidhash_next)//如果有冲突 
        p-&gt;pidhash_next-&gt;pidhash_pprev = p-&gt;pidhash_pprev; 
    *p-&gt;pidhash_pprev = p-&gt;pidhash_next;//当没有冲突时，就会置NULL 
} 
static inline struct task_struct *find_task_by_pid(int pid) 
{ 
    struct task_struct *p, **htable = &amp;pidhash[pid_hashfn(pid)]; 
    for(p = *htable; p &amp;&amp; p-&gt;pid != pid; p = p-&gt;pidhash_next); 
    return p; 
}
</code></pre>

<p>SGI STL的例子 hash</p>

<p>SGI STL中的hashtable 同样采用的是开链法设计，这里就是hashtable中节点的样子</p>

<pre><code>template &lt;class _Val&gt; 
struct _Hashtable_node 
{ 
    _Hashtable_node* _M_next; 
    _Val _M_val; 
};
</code></pre>

<p>这里可以看出，hashtable并没有利用现有的list等容器，而是自己简单的创建一个单向链表并维护。由于hashtable中的每一项元素都是一连串的数据（处理冲突而在一个链表中），所以将hashtable中的元素成为bucket，表示这个元素其实可能有“一桶子”东西，最后hashtable通过vector管理bucket，实现动态增长。</p>

<p>同之前一样，首先从iterator开始了解。下面是hashtable的iterator实现。</p>

<pre><code>template &lt;class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc&gt;
struct _Hashtable_iterator {
  typedef hashtable&lt;_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc&gt;
          _Hashtable;
  typedef _Hashtable_iterator&lt;_Val, _Key, _HashFcn, 
                              _ExtractKey, _EqualKey, _Alloc&gt;
          iterator;
  typedef _Hashtable_const_iterator&lt;_Val, _Key, _HashFcn, 
                                    _ExtractKey, _EqualKey, _Alloc&gt;
          const_iterator;
  typedef _Hashtable_node&lt;_Val&gt; _Node;
  typedef forward_iterator_tag iterator_category; 
  typedef _Val value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef _Val&amp; reference;
  typedef _Val* pointer;
  _Node* _M_cur;         //指向当前的节点
  _Hashtable* _M_ht;     //指向hashtable容器
  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) 
    : _M_cur(__n), _M_ht(__tab) {}
  _Hashtable_iterator() {}
  reference operator*() const { return _M_cur-&gt;_M_val; }
#ifndef __SGI_STL_NO_ARROW_OPERATOR
  pointer operator-&gt;() const { return &amp;(operator*()); }
#endif /* __SGI_STL_NO_ARROW_OPERATOR */
  iterator&amp; operator++();
  iterator operator++(int);
  bool operator==(const iterator&amp; __it) const
    { return _M_cur == __it._M_cur; }
  bool operator!=(const iterator&amp; __it) const
    { return _M_cur != __it._M_cur; }
};
</code></pre>

<p>可以看出，这里的迭代器设计成只能向后移动，在operator ++ 中，我们可以看到迭代器的移动。</p>

<pre><code>template &lt;class _Val, class _Key, class _HF, class _ExK, class _EqK, 
class _All&gt;
_Hashtable_iterator&lt;_Val,_Key,_HF,_ExK,_EqK,_All&gt;&amp;
_Hashtable_iterator&lt;_Val,_Key,_HF,_ExK,_EqK,_All&gt;::operator++()
{
    const _Node* __old = _M_cur;
    _M_cur = _M_cur-&gt;_M_next;
    if (!_M_cur) {
        size_type __bucket = _M_ht-&gt;_M_bkt_num(__old-&gt;_M_val);
        while (!_M_cur &amp;&amp; ++__bucket &lt; _M_ht-&gt;_M_buckets.size())
           _M_cur = _M_ht-&gt;_M_buckets[__bucket];
     }
     return *this;
}
</code></pre>

<p>首先在链表（一个bucket）中寻找下一个节点，如果是链表中的最后一个节点，那么寻找下一个链表（bucket）中的节点。了解迭代器之后，开始了解容器本身。</p>

<p>之前可以看出，SGI STL 虽然采用的是开链法，但是在分配空间大小时，依然采用的是质数，这一点和.net framework 中的dictionary一样。大小差不多是2倍</p>

<pre><code>static const int __stl_num_primes = 28;
static const unsigned long __stl_prime_list[__stl_num_primes] =
{
  53ul,         97ul,         193ul,       389ul,       769ul,
  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, 
  1610612741ul, 3221225473ul, 4294967291ul
};
//找到下一个大于n的质数，lower_bound是一个二分法查找。
inline unsigned long __stl_next_prime(unsigned long __n)
{
  const unsigned long* __first = __stl_prime_list;
  const unsigned long* __last = __stl_prime_list + __stl_num_primes;
  const unsigned long* pos = lower_bound(__first, __last, __n);
  return pos == __last ? *(__last - 1) : *pos;
}
</code></pre>

<p>  hashTable 中最重要的部分是扩容。那么，我们看看，SGI STL是怎么做的</p>

<pre><code>pair&lt;iterator, bool&gt; insert_unique(const value_type&amp; __obj) 
{ 
  resize(_M_num_elements + 1); 
  return insert_unique_noresize(__obj); 
}

template &lt;class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All&gt;
void hashtable&lt;_Val,_Key,_HF,_Ex,_Eq,_All&gt;
  ::resize(size_type __num_elements_hint)
{
  const size_type __old_n = _M_buckets.size();
  if (__num_elements_hint &gt; __old_n) {
    //如果需要扩容，我们找到下一个质数
    const size_type __n = _M_next_size(__num_elements_hint);
    if (__n &gt; __old_n) {
      //搞一个新的buckets
      vector&lt;_Node*, _All&gt; __tmp(__n, (_Node*)(0),
                                 _M_buckets.get_allocator());
      __STL_TRY {
        for (size_type __bucket = 0; __bucket &lt; __old_n; ++__bucket) {
          //遍历之旧的buckets
          _Node* __first = _M_buckets[__bucket];
          while (__first) {
            //遍历旧的bucket，这里，我们根据新的大小找到了新的位置
            size_type __new_bucket = _M_bkt_num(__first-&gt;_M_val, __n);
            //将旧的bucket数据改为 我们正在处理的item的下一个 
            _M_buckets[__bucket] = __first-&gt;_M_next;
            //把我们现在处理的item 插入到新的buckets中。
            __first-&gt;_M_next = __tmp[__new_bucket];
            __tmp[__new_bucket] = __first;
            //将我们当前处理的item，修改为旧数据的下一个
            __first = _M_buckets[__bucket];          
          }
        }
        //都搞定了，我们将buckets更换。
        _M_buckets.swap(__tmp);
      }
#ifdef __STL_USE_EXCEPTIONS
      catch(...) {
        for (size_type __bucket = 0; __bucket &lt; __tmp.size(); ++__bucket) {
          while (__tmp[__bucket]) {
            _Node* __next = __tmp[__bucket]-&gt;_M_next;
            _M_delete_node(__tmp[__bucket]);
            __tmp[__bucket] = __next;
          }
        }
        throw;
      }
#endif /* __STL_USE_EXCEPTIONS */
    }
  }
}
</code></pre>

<p>当然，这个只是insert_unique ，insert_equal 类似，这里不做描述。</p>

<p>除了resize，hashtable中还有一个吸引我们的就是hash func。但是，一般我们并不会指定hash func， 那么，我们看看SGI STL 是如何选择hash 函数的。</p>

<pre><code>#ifndef __SGI_STL_HASH_FUN_H
#define __SGI_STL_HASH_FUN_H
#include &lt;stddef.h&gt;
__STL_BEGIN_NAMESPACE
template &lt;class _Key&gt; struct hash { };
//字符串这里看来稍微有了一些操作
inline size_t __stl_hash_string(const char* __s)
{
  unsigned long __h = 0; 
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}
//这些东西，通过c++ 模板偏特化实现，我们看到，这些东西，啥都没做，只是返回而已。所以，如果
//希望获得最佳的性能，实现仿函数。是非常必要的。
__STL_TEMPLATE_NULL struct hash&lt;char*&gt;
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};
__STL_TEMPLATE_NULL struct hash&lt;const char*&gt;
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};
__STL_TEMPLATE_NULL struct hash&lt;char&gt; {
  size_t operator()(char __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned char&gt; {
  size_t operator()(unsigned char __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;signed char&gt; {
  size_t operator()(unsigned char __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;short&gt; {
  size_t operator()(short __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned short&gt; {
  size_t operator()(unsigned short __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;int&gt; {
  size_t operator()(int __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned int&gt; {
  size_t operator()(unsigned int __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;long&gt; {
  size_t operator()(long __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned long&gt; {
  size_t operator()(unsigned long __x) const { return __x; }
};
</code></pre>

<p>SQLite 的hash表。</p>

<p>SQLite是在移动设备上普遍的一个家伙， 他用到了2种HASH， 一种和上面的SGI STL 类似，在PC端，在做增加的时候，判断了数据量大小（一般10个），如果小于，则采用双向链表的方式，不是则采用hash存储。只是，在移动分支中我没有找到，PC端的确有这样的设计，也许在mobile上做了精简。这种hash，用于SQLite底层的内存管理，缓存部分，SQLite采用的是LRU的方式缓存。</p>

<p>另一种Hash是叫做perfect hash。这是一种在最坏情况下，依然能够达到O(1) 的能力，听上去似乎挺吓人的，但是大多数是指固定的表，当然，似乎有些能够做到动态保证，不过，不管他了，我可不是科学家。</p>

<p>SQLite 的前端是需要做词法语法分析的。这部分就涉及到了关键字的保存，这里SQLite 通过perfect hash来达到快速查找。具体的策略了解编译原理的都比较明白，但是，这个的确比较有意思。</p>

<p>构造关键字是通过一个起始位置和长度来获取的。如 “REINDEX 、 INDEXED 、 INDEX 、 DESC”；将保存成“REINDEXEDESC”。那么 REINDEX = （0， 7）。而剩下的工作可以交给一些程序，他们会帮助我们生成perfect hash。</p>

<p>大数据量下，hash信息指纹的应用。可以参考 google黑板报  http://www.google.com.hk/ggblog/googlechinablog/2006/08/blog-post_8115.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么没有SendThreadMessage呢？]]></title>
    <link href="http://studentdeng.github.com/blog/2011/03/31/sendthreadmessage/"/>
    <updated>2011-03-31T23:24:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2011/03/31/sendthreadmessage</id>
    <content type="html"><![CDATA[<p>最近忙公司的项目（或是毕设吧），发现很长时间没有总结了。是该换换脑子了。</p>

<p>“为什么没有SendThreadMessage呢？”这个问题，就来自自己平时实现的一些程序逻辑中。在一些具体的场景中，对像我这样的初学者来说，往往喜欢通过windwos的消息机制来完成UI线程和worker线程之间的同步，而不是去通过信号量或其他的去做。所以，这个问题一直困惑了自己很久。而现在，就来搞明白这个、</p>

<p>google一下，这个问题，在一个大牛（Raymond Chen）http://blogs.msdn.com/b/oldnewthing/archive/2008/12/23/9248851.aspx）的博客中提到了，而且也引发了很多讨论。我这里简单的”翻译”一下Raymond Chen自己的看法。</p>

<p>”想象中的SendThreadMessage是如何工作的呢？调用SendMessage 把消息直接分发给窗口过程？但是我们没有看到消息泵，想象中的SendThreadMessage将会把消息分发给谁呢？因为我们没有‘thread window procedure’这样的东东去处理我们的消息。</p>

<p>是的，我们可以自己在我们的线程中做一个消息泵，但是，想象中的SendThreadMessage，需要等待这个消息处理完毕。但是，我们怎么能够知道这个消息处理完毕了？因为我们不可能等待DispatchMessage返回，而DispatchMessage失败则是因为我们并不知道应该往哪一个窗口分发消息。window manager给线程发送一个消息，仅此而已。</p>

<p>你可能会认为，我们可以等待知道下一个GetMessage or PeekMessage，这样我们可以确定这个消息解决了。但是，我们却不能保证下一个消息检索函数(GetMessage PeekMessage)，是来自我们之前的消息泵。比如，我们这个线程消息，启动了一个模态窗口，是的。当我们的消息检索函数告诉我们这个消息已经处理完毕了。但是，事实上那个模态窗口还在，因为他自己又创建了一个消息泵。“</p>

<p>这段虽然不长，但是却另我头大无比。GetMessage ，  DispatchMessage。这2个基本的函数，天天用，但是却对他们的行为知之甚少，算上第一次写HelloWorld 到现在，至少也有1年了，依然朦胧，感到十分惭愧。而这也就是这篇总结要做的。而这的确是一个庞大的工程，因为要了解这2个函数，需要把握windows的消息机制。而windwos 并没有给我们源代码参考，这里参考ReactOS的实现，虽然不是windows正统，但是，应该差不远，至少是和win2003的相似。开始步入正题。</p>

<p>我们首先需要了解的是，UI线程 和我们的普通的Worker线程之间的区别是什么。</p>

<p>msdn http://msdn.microsoft.com/en-us/library/ms644927提到：</p>

<p>”To avoid the overhead of creating a message queue for non–GUI threads, all threads are created initially without a message queue. The system creates a thread-specific message queue only when the thread makes its first call to one of the specific user functions; no GUI function calls result in the creation of a message queue.“</p>

<p>既然，系统创建每一个线程时都是普通的non–GUI thread，直到GDI， User函数调用，才为线程创建消息队列，那么我们就从这些函数调用开始。</p>

<p>windwos在开始时，和linux一样 图形这部分是在用户空间中的进程负责，后面为了减少进程之间的环境切换，而放入了内核中。那么在系统调用这层，我们就看到了有2种情况。一种调用是原来的”内核”的调用，而另一种是新加进来的原来在用户空间的调用，这部分被称为扩充系统调用，这部分代码被放在了可以动态安装的模块win32k.sys。与之对应，系统的调用表就有了2个，一个是只包括之前的”来自内核的系统调用“，另一个则在之前的基础上，增加了图形图像的系统调用。当我们的系统调用被发现是扩充系统调用时，也就是，原来的的表不能满足我们的要求。windwos会将会扩充系统调用表。并装载win32k.sys模块。那么，我们的普普通通的线程就开始变为GUI线程了。</p>

<p>激动人心的旅程就从这里开始了。</p>

<p>开源代码就是好，随意都能够贴出来。</p>

<pre><code>NTSTATUS
NTAPI
PsConvertToGuiThread(VOID)
{
    ULONG_PTR NewStack;
    PVOID OldStack;
    PETHREAD Thread = PsGetCurrentThread();
    PEPROCESS Process = PsGetCurrentProcess();
    NTSTATUS Status;
    PAGED_CODE();

    /* Validate the previous mode */
    if (KeGetPreviousMode() == KernelMode) return STATUS_INVALID_PARAMETER;

    /* If no win32k, crashes later */
    ASSERT(PspW32ProcessCallout != NULL);

    /* Make sure win32k is here */
    if (!PspW32ProcessCallout) return STATUS_ACCESS_DENIED;

    /* Make sure it's not already win32 */
    if (Thread-&gt;Tcb.ServiceTable != KeServiceDescriptorTable)
    {
        /* We're already a win32 thread */
        return STATUS_ALREADY_WIN32;
    }

    /* Check if we don't already have a kernel-mode stack */
    if (!Thread-&gt;Tcb.LargeStack)
    {
        /* We don't create one */
        NewStack = (ULONG_PTR)MmCreateKernelStack(TRUE, 0);
        if (!NewStack)
        {
            /* Panic in user-mode */
            NtCurrentTeb()-&gt;LastErrorValue = ERROR_NOT_ENOUGH_MEMORY;
            return STATUS_NO_MEMORY;
        }

        /* We're about to switch stacks. Enter a guarded region */
        KeEnterGuardedRegion();

        /* Switch stacks */
        OldStack = KeSwitchKernelStack((PVOID)NewStack,
                                       (PVOID)(NewStack - KERNEL_STACK_SIZE));

        /* Leave the guarded region */
        KeLeaveGuardedRegion();

        /* Delete the old stack */
        MmDeleteKernelStack(OldStack, FALSE);
    }

    /* This check is bizare. Check out win32k later */
    if (!Process-&gt;Win32Process)
    {
        /* Now tell win32k about us */
        Status = PspW32ProcessCallout(Process, TRUE);
        if (!NT_SUCCESS(Status)) return Status;
    }

    /* Set the new service table */
    Thread-&gt;Tcb.ServiceTable = KeServiceDescriptorTableShadow;
    ASSERT(Thread-&gt;Tcb.Win32Thread == 0);

    /* Tell Win32k about our thread */
    Status = PspW32ThreadCallout(Thread, PsW32ThreadCalloutInitialize);
    if (!NT_SUCCESS(Status))
    {
        /* Revert our table */
        Thread-&gt;Tcb.ServiceTable = KeServiceDescriptorTable;
    }

    /* Return status */
    return Status;
}
</code></pre>

<p>之前没有提到的是，这里判断了一下线程system stack的大小，因为GUI线程要比普通的线程增加了更多的嵌套调用，从而需要更多的system stack。MmCreateKernelStack就是分配空间的函数。这里只是分配了64K的大小，普通的thread system stack大小为12K。当然，按照惯例，这里64K的堆栈，只是提交了其中12K的大小。并设置好guard page。超过12K则产生异常然后再分配空间。一个进程，如果有一个线程是GUI线程，那么这个进程就是GUI 进程，那么，如果不是GUI进程，我们当然先得把进程转过来。PspW32ProcessCallout是一个函数指针，指向Win32kProcessCallback。这里就是干这个了，会初始化一系列的结构体，键盘格式，GDI 句柄表等等。我们这里略过这些细节。</p>

<p>我们看到，系统的ServiceTable换成了大的表。而PspW32ThreadCallout指向Win32kThreadCallback，这里就完成了把普通线程转换成GUI线程的过程。对于操作系统这么复杂的东东来说，要初始化的结构体真是茫茫的多。我们这里关注一点，在Win32kThreadCallback中，我们找到了创建消息队列的入口。Win32Thread->MessageQueue = MsqCreateMessageQueue(Thread);</p>

<p>系统有了消息队列，但是，并不能构成真正的win32应用程序。我们开发者，还需要在自己的窗口程序中构造一个简单的Message Dump，让我们看看这个GetMessage，到底做了什么。</p>

<p>GetMessage，最后会调用NtUserGetMessage。</p>

<pre><code>BOOL APIENTRY
NtUserGetMessage(PMSG pMsg,
                  HWND hWnd,
                  UINT MsgFilterMin,
                  UINT MsgFilterMax )
{
    MSG Msg;
    BOOL Ret;

    if ( (MsgFilterMin|MsgFilterMax) &amp; ~WM_MAXIMUM )
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    UserEnterExclusive();

    RtlZeroMemory(&amp;Msg, sizeof(MSG));

    Ret = co_IntGetPeekMessage(&amp;Msg, hWnd, MsgFilterMin, MsgFilterMax, PM_REMOVE, TRUE);

    UserLeave();

    if (Ret)
    {
        _SEH2_TRY
        {
            ProbeForWrite(pMsg, sizeof(MSG), 1);
            RtlCopyMemory(pMsg, &amp;Msg, sizeof(MSG));
        }
        _SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastNtError(_SEH2_GetExceptionCode());
            Ret = FALSE;
        }
        _SEH2_END;
    }

    return Ret;
}
</code></pre>

<p>原谅我略过一些茫茫多的细节。</p>

<pre><code>BOOL FASTCALL
co_IntGetPeekMessage( PMSG pMsg,
                      HWND hWnd,
                      UINT MsgFilterMin,
                      UINT MsgFilterMax,
                      UINT RemoveMsg,
                      BOOL bGMSG )
{
    //.......
    do
    {
        Present = co_IntPeekMessage( pMsg,
                                     Window,
                                     MsgFilterMin,
                                     MsgFilterMax,
                                     RemoveMsg,
                                     bGMSG );
        if (Present)
        {
           /* GetMessage or PostMessage must never get messages that contain pointers */
           ASSERT(FindMsgMemory(pMsg-&gt;message) == NULL);

           if (pMsg-&gt;message != WM_PAINT &amp;&amp; pMsg-&gt;message != WM_QUIT)
           {
              pti-&gt;timeLast = pMsg-&gt;time;
              pti-&gt;ptLast   = pMsg-&gt;pt;
           }

           // The WH_GETMESSAGE hook enables an application to monitor messages about to
           // be returned by the GetMessage or PeekMessage function.

           co_HOOK_CallHooks( WH_GETMESSAGE, HC_ACTION, RemoveMsg &amp; PM_REMOVE, (LPARAM)pMsg);

           if ( bGMSG )
           {
              Present = (WM_QUIT != pMsg-&gt;message);
              break;
           }
        }

        if ( bGMSG )
        {
           if ( !co_IntWaitMessage(Window, MsgFilterMin, MsgFilterMax) )
           {
              Present = -1;
              break;
           }
        }
        else
        {
           if (!(RemoveMsg &amp; PM_NOYIELD))
           {
              IdlePing();
              // Yield this thread!
              UserLeave();
              ZwYieldExecution();
              UserEnterExclusive();
              // Fall through to exit.
              IdlePong();
           }
           break;
        }
    }
    while( bGMSG &amp;&amp; !Present );

    // Been spinning, time to swap vinyl...
    if (pti-&gt;pClientInfo-&gt;cSpins &gt;= 100)
    {
       // Clear the spin cycle to fix the mix.
       pti-&gt;pClientInfo-&gt;cSpins = 0;
       //if (!(pti-&gt;TIF_flags &amp; TIF_SPINNING)) FIXME need to swap vinyl..
    }
    return Present;
}
</code></pre>

<p>IntGetPeekMessage，就是一个循环，不断的调用co_IntPeekMessage 从消息队列中取出消息，如果没有消息，那么我们就调用co_IntWaitMessage等待消息，然后往复，除非我们遇到了WM_QUIT。</p>

<p>co_IntPeekMessage 看来是实现的关键,而他也是PeekMessage的关键部分。同样,略过那些繁琐的细节。当然，这并不是指那些不重要，而是实在是太多了。这个函数是整个消息机制的核心部分。需要慢慢来。</p>

<p>说了这么多，我们还不知道消息队列是啥模样了。</p>

<pre><code>typedef struct _USER_MESSAGE_QUEUE
{
  /* Reference counter, only access this variable with interlocked functions! */
  LONG References;

  /* Owner of the message queue */
  struct _ETHREAD *Thread;
  /* Queue of messages sent to the queue. */
  LIST_ENTRY SentMessagesListHead;                          //被“发送”的消息队列
  /* Queue of messages posted to the queue. */
  LIST_ENTRY PostedMessagesListHead;                        //被"Post"的消息队列
  /* Queue for hardware messages for the queue. */
  LIST_ENTRY HardwareMessagesListHead;                      //来自硬件的消息队列

  //.........

  /* messages that are currently dispatched by other threads */
  LIST_ENTRY DispatchingMessagesHead;                           //  已经发送而对方尚未处理的消息队列
  /* messages that are currently dispatched by this message queue, required for cleanup */
  LIST_ENTRY LocalDispatchingMessagesHead;                     // 本地正在分发的消息队列

  //........

} USER_MESSAGE_QUEUE, *PUSER_MESSAGE_QUEUE;
</code></pre>

<p>SentMessagesListHead 这个队列的东西是发送到我们这个消息队列的消息。 也就是，当其他地方调用SendMessage到我们这个消息队列时，那个消息会放在这个队列中。</p>

<p>PostedMessagesListHead 同理，是其他地方调用PostMessage，然后把他那个消息放在了这个队列中。</p>

<p>PostMessage这个函数比较容易实现，我们只需要挂在目标的PostedMessagesListHead队列中就可以了。但是SendMessage就要复杂很多了。</p>

<p>如果发送方和接收方是在一个线程中，那么SendMessage会直接调用本窗口的窗口过程函数来处理这个消息。</p>

<p>如果发送方和接收方不在一个线程中，那么发送方就必须要等待接收方的运行结果之后，才能继续执行。而这个，就形成了一个感觉上是同步的一个过程。感觉上这个似乎也不是很复杂。但也不是一个很简单的线程同步问题。</p>

<p>想一下这个问题，当GUI线程A向GUI线程B发送一个消息时，线程B处理A这个消息时，又需要向线程A发送一个消息。那么，这2个线程会死锁么？ 当然不会。要知道，windwos搞这一套为的就是构造一个完整的消息驱动机制，更抽象的讲，这个消息机制也算的上是一个线程通信机制。而这一套东东，最复杂的是在于，这些东东需要用户程序结合到一起，才能真正的运行起来。也就是说，我们的应用程序，必须符合windwos程序的规范，才能和windwos消息机制参与起来。而这个参与中最重要的东东就是我们之前提到的GetMessage，DispatchingMessagesHead 和 LocalDispatchingMessagesHead 则是实现这一套机制中非常重要的部分。</p>

<p>DispatchingMessagesHead  当我们自己SendMessage到其他地方时，我们的消息是需要等待对面的结果，那么这个需要等待的消息就被放置到这里。这里可能会对一些windwos菜鸟觉得困惑，困惑这个为什么能够形成一个队列呢？这里先把问题留下来。</p>

<p>让我们站在接受者的消息队列的角度来看，当有人给我们SendMessage了，我们需要在这里处理，也就是Message Dispatch，当我们搞出这个消息的返回值时，我们接受方，还必须等待对面的人把我们的这个消息的返回值拿走，这个消息才算是搞定了。这里由于可能是不同线程，甚至是不同进程之间数据传递。所以这些东西必须要考虑在内，而这些消息放在哪里呢？LocalDispatchingMessagesHead 就跳出来解决这个问题。</p>

<p>总的说一下，当我们SendMessage一个消息时，会挂在接收方的SentMessagesListHead队列中，并挂在发送方的DispatchingMessagesHead。</p>

<p>接受方先查看SentMessagesListHead 是否有消息，有的话，则从SendMessageListHead中删除掉，并添加到LocalDispatchingMessagesHead队列中，等我们把这个消息处理完毕，从LocalDispatchingMessagesHead将这个消息删除。</p>

<p>我们首先关注这4个队列。那个硬件的队列主要是鼠标和键盘的东东。</p>

<p>第一次看这个可能有点晕，不急。有一个笼统的概念之后，我们在来看细节。这部分还不是非常复杂。</p>

<pre><code>/*
 * Internal version of PeekMessage() doing all the work
 */
BOOL FASTCALL
co_IntPeekMessage( PMSG Msg,
                   PWND Window,
                   UINT MsgFilterMin,
                   UINT MsgFilterMax,
                   UINT RemoveMsg,
                   BOOL bGMSG )
{
    //...
    do
    {
        //..
        /* Dispatch sent messages here. */
        while ( co_MsqDispatchOneSentMessage(ThreadQueue) )
        {
           //...
        }

        //...

        /* Now check for normal messages. */
        if ((ProcessMask &amp; QS_POSTMESSAGE) &amp;&amp;
            MsqPeekMessage( ThreadQueue,
                            RemoveMessages,
                            Window,
                            MsgFilterMin,
                            MsgFilterMax,
                            ProcessMask,
                            Msg ))
        {
               return TRUE;
        }

        /* Now look for a quit message. */
        if (ThreadQueue-&gt;QuitPosted)
        {
            /* According to the PSDK, WM_QUIT messages are always returned, regardless
               of the filter specified */
            Msg-&gt;hwnd = NULL;
            Msg-&gt;message = WM_QUIT;
            Msg-&gt;wParam = ThreadQueue-&gt;QuitExitCode;
            Msg-&gt;lParam = 0;
            if (RemoveMessages)
            {
                ThreadQueue-&gt;QuitPosted = FALSE;
                ClearMsgBitsMask(ThreadQueue, QS_POSTMESSAGE);
                pti-&gt;pcti-&gt;fsWakeBits &amp;= ~QS_ALLPOSTMESSAGE;
                pti-&gt;pcti-&gt;fsChangeBits &amp;= ~QS_ALLPOSTMESSAGE;
            }
            return TRUE;
        }

        /* Check for hardware events. */
        if ((ProcessMask &amp; QS_MOUSE) &amp;&amp;
            co_MsqPeekMouseMove( ThreadQueue,
                                 RemoveMessages,
                                 Window,
                                 MsgFilterMin,
                                 MsgFilterMax,
                                 Msg ))
        {
            return TRUE;
        }

        if ((ProcessMask &amp; QS_INPUT) &amp;&amp;
            co_MsqPeekHardwareMessage( ThreadQueue,
                                       RemoveMessages,
                                       Window,
                                       MsgFilterMin,
                                       MsgFilterMax,
                                       ProcessMask,
                                       Msg))
        {
            return TRUE;
        }

        /* Check for sent messages again. */
        while ( co_MsqDispatchOneSentMessage(ThreadQueue) )
        {
           if (HIWORD(RemoveMsg) &amp;&amp; !bGMSG) Hit = TRUE;
        }
        if (Hit) return FALSE;

        /* Check for paint messages. */
        if ((ProcessMask &amp; QS_PAINT) &amp;&amp;
            pti-&gt;cPaintsReady &amp;&amp;
            IntGetPaintMessage( Window,
                                MsgFilterMin,
                                MsgFilterMax,
                                pti,
                                Msg,
                                RemoveMessages))
        {
            return TRUE;
        }

       /* This is correct, check for the current threads timers waiting to be
          posted to this threads message queue. If any we loop again.
        */
        if ((ProcessMask &amp; QS_TIMER) &amp;&amp;
            PostTimerMessages(Window))
        {
            continue;
        }

        return FALSE;
    }
    while (TRUE);

    return TRUE;
}
</code></pre>

<p>co_MsqDispatchOneSentMessage 这里做的就是从SendMessageListHead 中取出一个别人SendMessage到我们这里的一个消息。 当我们把这些别人SendMessage给我们的消息处理完，就跳出那个循环，MsqPeekMessage 则去搞定别人PostMessage给我们的消息，最后再次检查一次co_MsqDispatchOneSentMessage，有没有人给我们发送了SendMessage消息，因为这之间的间隔是有可能有新的SendMessage消息。然后是IntGetPaintMessage 和PostTimerMessages这个名字就很容易理解了。而且，这里我们也看出了消息的优先级，为了提高Paint的效率，Paint是统一处理的。而且我们也看到了Timer消息，事实上我们看出他的优先级低于Paint，这样，我们就可以在timer中绘制函数，因为，我们每一次处理timer之前，我们能够保证我们的Paint消息已经被处理了。而且，我们也看出timer的确不准，在他前面有太多的东西要做了。</p>

<p>我们还需要了解下，我们的消息结构。是的，这个Post消息是要挂在队列中的。</p>

<pre><code>typedef struct _USER_MESSAGE
{
  LIST_ENTRY ListEntry;
  MSG Msg;
  DWORD QS_Flags;
} USER_MESSAGE, *PUSER_MESSAGE;
</code></pre>

<p>Send的消息这里就要麻烦很多了。</p>

<pre><code>typedef struct _USER_SENT_MESSAGE
{
  LIST_ENTRY ListEntry;                            //接受方的队列
  MSG Msg;
  DWORD QS_Flags;  // Original QS bits used to create this message.
  PKEVENT CompletionEvent;                    //这个用来做线程的唤醒操作
  LRESULT* Result;
  LRESULT lResult;
  struct _USER_MESSAGE_QUEUE* SenderQueue;
  struct _USER_MESSAGE_QUEUE* CallBackSenderQueue;
  SENDASYNCPROC CompletionCallback;
  ULONG_PTR CompletionCallbackContext;
  /* entry in the dispatching list of the sender's message queue */
  LIST_ENTRY DispatchingListEntry;                //发送方的DispatchingMessageList
  INT HookMessage;
  BOOL HasPackedLParam;
} USER_SENT_MESSAGE, *PUSER_SENT_MESSAGE;
</code></pre>

<p>这个家伙，才是真正挂在发送队列中的数据结构，我们的MSG只是其中的一个数据成员。这里，就和我们之前提到的，这个消息，是在2个队列中存在，一边在发送方的DispatchingMessageList，表示这个消息正在分发，一边在接受方的SentMessagesListHead，表示这个消息被发送过来。等待处理。</p>

<p>让我们一看co_MsqDispatchOneSentMessage的究竟。</p>

<pre><code>BOOLEAN FASTCALL
co_MsqDispatchOneSentMessage(PUSER_MESSAGE_QUEUE MessageQueue)
{
   PUSER_SENT_MESSAGE SaveMsg, Message;
   PLIST_ENTRY Entry;
   LRESULT Result;
   PTHREADINFO pti;

   if (IsListEmpty(&amp;MessageQueue-&gt;SentMessagesListHead))
   {
      return(FALSE);
   }

   /* remove it from the list of pending messages */
   Entry = RemoveHeadList(&amp;MessageQueue-&gt;SentMessagesListHead);
   Message = CONTAINING_RECORD(Entry, USER_SENT_MESSAGE, ListEntry);

   pti = MessageQueue-&gt;Thread-&gt;Tcb.Win32Thread;

   SaveMsg = pti-&gt;pusmCurrent;
   pti-&gt;pusmCurrent = Message;

   // Processing a message sent to it from another thread.
   if ( ( Message-&gt;SenderQueue &amp;&amp; MessageQueue != Message-&gt;SenderQueue) ||
        ( Message-&gt;CallBackSenderQueue &amp;&amp; MessageQueue != Message-&gt;CallBackSenderQueue ))
   {  // most likely, but, to be sure.
      pti-&gt;pcti-&gt;CTI_flags |= CTI_INSENDMESSAGE; // Let the user know...
   }

   /* insert it to the list of messages that are currently dispatched by this
      message queue */
   InsertTailList(&amp;MessageQueue-&gt;LocalDispatchingMessagesHead,
                  &amp;Message-&gt;ListEntry);

   ClearMsgBitsMask(MessageQueue, Message-&gt;QS_Flags);

   if (Message-&gt;HookMessage == MSQ_ISHOOK)
   {  // Direct Hook Call processor
      Result = co_CallHook( Message-&gt;Msg.message,     // HookId
                           (INT)(INT_PTR)Message-&gt;Msg.hwnd, // Code
                            Message-&gt;Msg.wParam,
                            Message-&gt;Msg.lParam);
   }
   else if (Message-&gt;HookMessage == MSQ_ISEVENT)
   {  // Direct Event Call processor
      Result = co_EVENT_CallEvents( Message-&gt;Msg.message,
                                    Message-&gt;Msg.hwnd,
                                    Message-&gt;Msg.wParam,
                                    Message-&gt;Msg.lParam);
   }
   else
   {  /* Call the window procedure. */
      Result = co_IntSendMessage( Message-&gt;Msg.hwnd,
                                  Message-&gt;Msg.message,
                                  Message-&gt;Msg.wParam,
                                  Message-&gt;Msg.lParam);
   }

   /* remove the message from the local dispatching list, because it doesn't need
      to be cleaned up on thread termination anymore */
   RemoveEntryList(&amp;Message-&gt;ListEntry);

   /* remove the message from the dispatching list if needed, so lock the sender's message queue */
   if (!(Message-&gt;HookMessage &amp; MSQ_SENTNOWAIT))
   {
      if (Message-&gt;DispatchingListEntry.Flink != NULL)
      {
         /* only remove it from the dispatching list if not already removed by a timeout */
         RemoveEntryList(&amp;Message-&gt;DispatchingListEntry);
      }
   }
   /* still keep the sender's message queue locked, so the sender can't exit the
      MsqSendMessage() function (if timed out) */

   if (Message-&gt;QS_Flags &amp; QS_SMRESULT)
   {
      Result = Message-&gt;lResult;
   }

   /* Let the sender know the result. */
   if (Message-&gt;Result != NULL)
   {
      *Message-&gt;Result = Result;
   }

   if (Message-&gt;HasPackedLParam == TRUE)
   {
      if (Message-&gt;Msg.lParam)
         ExFreePool((PVOID)Message-&gt;Msg.lParam);
   }

   /* Notify the sender. */
   if (Message-&gt;CompletionEvent != NULL)
   {
      KeSetEvent(Message-&gt;CompletionEvent, IO_NO_INCREMENT, FALSE);
   }

   /* Call the callback if the message was sent with SendMessageCallback */
   if (Message-&gt;CompletionCallback != NULL)
   {
      co_IntCallSentMessageCallback(Message-&gt;CompletionCallback,
                                    Message-&gt;Msg.hwnd,
                                    Message-&gt;Msg.message,
                                    Message-&gt;CompletionCallbackContext,
                                    Result);
   }

   /* Only if it is not a no wait message */
   if (!(Message-&gt;HookMessage &amp; MSQ_SENTNOWAIT))
   {
      IntDereferenceMessageQueue(Message-&gt;SenderQueue);
      IntDereferenceMessageQueue(MessageQueue);
   }

   /* free the message */
   ExFreePoolWithTag(Message, TAG_USRMSG);

   /* do not hangup on the user if this is reentering */
   if (!SaveMsg) pti-&gt;pcti-&gt;CTI_flags &amp;= ~CTI_INSENDMESSAGE;
   pti-&gt;pusmCurrent = SaveMsg;

   return(TRUE);
}
</code></pre>

<p>我们首先从SentMessagesListHead把消息移动到LocalDispatchingMessagesHead，让我们略掉那些细节的标志位和hook的部分。co_IntSendMessage，则把这个消息发送出去，然后把结果给我们，然后我们把消息从接收方的LocalDispatchingMessagesHead，删掉。如果发送方还在等我们的消息，我们就把他从发送方的DispatchingMessagesHead中删掉这条消息，（因为有些消息，是有时间限制的，可能已经早就被从DispatchingMessagesHead删掉了）。然后把返回结果保存起来。当然，有些消息还是有附件的，一些资源需要释放。这里是那些消息就不在这里赘述了，而且我们也不关心这些。然后，我们通过Message->CompletionEvent来通知发送方，该醒过来了。最后，我们看到，如果这个消息有回调函数，这里并没有直接调用回调函数，而是又通过了消息机制发送了一个消息给自己（在自己的Post队列中）。有了这个，的确很容易去理解MSDN的相关意思了。有时候，真的。MS的文档为什么那么全，因为他不给我们看源代码，有源代码还需要那么多的详细文档么？而且，那些文档真的不能彻底说清楚。</p>

<p>转了这么远，问题又被迭代到co_IntSendMessage 上了。co_IntSendMessage 其实是co_IntSendMessageTimeout 的一个特殊调用。</p>

<pre><code>LRESULT FASTCALL
co_IntSendMessageTimeout( HWND hWnd,
                          UINT Msg,
                          WPARAM wParam,
                          LPARAM lParam,
                          UINT uFlags,
                          UINT uTimeout,
                          ULONG_PTR *uResult )
{
    PWND DesktopWindow;
    HWND *Children;
    HWND *Child;

    if (HWND_BROADCAST != hWnd)
    {
        return co_IntSendMessageTimeoutSingle(hWnd, Msg, wParam, lParam, uFlags, uTimeout, uResult);
    }

    DesktopWindow = UserGetWindowObject(IntGetDesktopWindow());
    if (NULL == DesktopWindow)
    {
        EngSetLastError(ERROR_INTERNAL_ERROR);
        return 0;
    }

    /* Send message to the desktop window too! */
    co_IntSendMessageTimeoutSingle(DesktopWindow-&gt;head.h, Msg, wParam, lParam, uFlags, uTimeout, uResult);

    Children = IntWinListChildren(DesktopWindow);
    if (NULL == Children)
    {
        return 0;
    }

    for (Child = Children; NULL != *Child; Child++)
    {
        co_IntSendMessageTimeoutSingle(*Child, Msg, wParam, lParam, uFlags, uTimeout, uResult);
    }

    ExFreePool(Children);

    return (LRESULT) TRUE;
}
</code></pre>

<p>我们不考虑广播的情况，看简单的给单个窗口发送消息的co_IntSendMessageTimeoutSingle</p>

<pre><code>static LRESULT FASTCALL
co_IntSendMessageTimeoutSingle( HWND hWnd,
                                UINT Msg,
                                WPARAM wParam,
                                LPARAM lParam,
                                UINT uFlags,
                                UINT uTimeout,
                                ULONG_PTR *uResult )
{
    NTSTATUS Status;
    PWND Window = NULL;
    PMSGMEMORY MsgMemoryEntry;
    INT lParamBufferSize;
    LPARAM lParamPacked;
    PTHREADINFO Win32Thread;
    ULONG_PTR Result = 0;
    DECLARE_RETURN(LRESULT);
    USER_REFERENCE_ENTRY Ref;

    if (!(Window = UserGetWindowObject(hWnd)))
    {
        RETURN( FALSE);
    }

    UserRefObjectCo(Window, &amp;Ref);

    Win32Thread = PsGetCurrentThreadWin32Thread();

    IntCallWndProc( Window, hWnd, Msg, wParam, lParam);

    if ( NULL != Win32Thread &amp;&amp;
         Window-&gt;head.pti-&gt;MessageQueue == Win32Thread-&gt;MessageQueue)
    {
        //本线程的消息，我们直接调用用户的窗口回调函数，终于要结束了。
        Result = (ULONG_PTR)co_IntCallWindowProc( Window-&gt;lpfnWndProc,
                                                  !Window-&gt;Unicode,
                                                  hWnd,
                                                  Msg,
                                                  wParam,
                                                  lParamPacked,
                                                  lParamBufferSize );
        if(uResult)
        {
            *uResult = Result;
        }

        ObDereferenceObject(Win32Thread-&gt;pEThread);

        IntCallWndProcRet( Window, hWnd, Msg, wParam, lParam, (LRESULT *)uResult);

        if (! NT_SUCCESS(UnpackParam(lParamPacked, Msg, wParam, lParam, FALSE)))
        {
            DPRINT1("Failed to unpack message parameters\n");
            RETURN( TRUE);
        }

        RETURN( TRUE);
    }

    //不是本线程，我们只能去转发这个消息了。

    do
    {
        Status = co_MsqSendMessage( Window-&gt;head.pti-&gt;MessageQueue,
                                    hWnd,
                                    Msg,
                                    wParam,
                                    lParam,
                                    uTimeout,
                                    (uFlags &amp; SMTO_BLOCK),
                                    MSQ_NORMAL,
                                    uResult );
    }
    while ((STATUS_TIMEOUT == Status) &amp;&amp;
           (uFlags &amp; SMTO_NOTIMEOUTIFNOTHUNG) &amp;&amp;
           !MsqIsHung(Window-&gt;head.pti-&gt;MessageQueue));

    IntCallWndProcRet( Window, hWnd, Msg, wParam, lParam, (LRESULT *)uResult);

    if (STATUS_TIMEOUT == Status)
    {
        /*
MSDN says:
    Microsoft Windows 2000: If GetLastError returns zero, then the function
    timed out.
    XP+ : If the function fails or times out, the return value is zero.
    To get extended error information, call GetLastError. If GetLastError
    returns ERROR_TIMEOUT, then the function timed out.
*/
        EngSetLastError(ERROR_TIMEOUT);
        RETURN( FALSE);
    }
    else if (! NT_SUCCESS(Status))
    {
        SetLastNtError(Status);
        RETURN( FALSE);
    }

    RETURN( TRUE);

CLEANUP:
    if (Window) UserDerefObjectCo(Window);
    END_CLEANUP;
}
</code></pre>

<p>这里我们终于看到结果了。当然，这里又给我们带出一个问题”系统是如何调用我们写的函数呢？是在什么时候调用？是通过什么方式？”这同样是，特别是第一次写windwos程序的菜鸟们遇到的第一个问题。这个问题说清楚还是挺麻烦的。这部分这里先留下。</p>

<p>让我们把大脑堆栈弹到开始。</p>

<p>还是这个问题”系统是如何调用我们写的函数呢？是在什么时候调用？是通过什么方式？”现在我们还不能回答所有问题，但是却可以回答”系统什么时候调用我们的窗口过程函数”。</p>

<p>我们调用系统的代码，或是说是调用系统服务，API等什么的，是通过中断机制完成的。并通过查找系统调用表来找到相对应的系统函数。也就是，我们可以随时随地利用中断机制去执行系统代码（当然是在限制下）。那么，系统可以随时随地的去执行我们用户空间的代码么？有点难，我们不去思考那么复杂的，因为还有一些其他的机制做这些类似的工作。我们只是去思考其中的一种，如何调用我们的窗口过程函数。</p>

<p>很容易想到，随时随地执行用户的代码很难。因为没有硬件的支持去让我们完成类似中断的机制。那系统只能在一些特定的地方才能有机会去执行我们的窗口过程函数。显然，GetMessage就是这个执行用户窗口过程函数的地方。而当用户程序在处理一个消息时，系统是没有办法有任何作为的。只能等待用户下一次调用GetMessage类似的函数，才能重新获得代码的控制。我们在co_IntPeekMessage中看出些端倪。如果消息队列中，没有任何消息，那么GetMessage并不会退出，也就是不将执行权给用户的代码，而是进入等待状态。如果这时来的一些SendMessage的消息，线程会唤醒并执行这些代码。除非有一个Post或是其他消息，才会从GetMessage返回给用户空间。</p>

<p>换句话就是，如果我们的Sendmessage是发给不同的线程，只能在GetMessage这个函数内部执行。如果那个接收方的线程阻塞了，那么我们的SendMessage就不会返回，因为他并没有执行GetMessage。</p>

<p>在去思考另一个问题，当我们Sendmessage到另一个线程，而另一个线程并没有执行我们的GetMessage，在执行他的代码，而我们的线程看起来显然是被挂起等待了，是么？并不是，因为他还是可以接受其他线程发送过来的消息。这显然是处理在处理我们之前讨论过的一种情况。的确很有意思。因为从windwos的角度看，需要实现这种强壮的消息机制。那么这是一个什么过程呢？清楚一点。其实就是需要一种机制，也就是在等待对方线程处理完毕之前，可以处理别人发给我们的消息。哈哈。WaitForMultipleObjects等待2个event一个是要等待处理完毕的消息，一个是要等待sendmessage过来的新消息。当醒来时判断是什么让我们清醒过来，如果对面的线程不给力，我们只能继续循环等待。而这个也就是sendmessage的过程。</p>

<pre><code>NTSTATUS FASTCALL
co_MsqSendMessage(PUSER_MESSAGE_QUEUE MessageQueue,
                  HWND Wnd, UINT Msg, WPARAM wParam, LPARAM lParam,
                  UINT uTimeout, BOOL Block, INT HookMessage,
                  ULONG_PTR *uResult)
{
   PTHREADINFO pti;
   PUSER_SENT_MESSAGE Message;
   KEVENT CompletionEvent;
   NTSTATUS WaitStatus;
   PUSER_MESSAGE_QUEUE ThreadQueue;
   LARGE_INTEGER Timeout;
   PLIST_ENTRY Entry;
   LRESULT Result = 0;   //// Result could be trashed. ////

   if(!(Message = ExAllocatePoolWithTag(PagedPool, sizeof(USER_SENT_MESSAGE), TAG_USRMSG)))
   {
      DPRINT1("MsqSendMessage(): Not enough memory to allocate a message");
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   KeInitializeEvent(&amp;CompletionEvent, NotificationEvent, FALSE);

   pti = PsGetCurrentThreadWin32Thread();
   ThreadQueue = pti-&gt;MessageQueue;
   ASSERT(ThreadQueue != MessageQueue);

   Timeout.QuadPart = (LONGLONG) uTimeout * (LONGLONG) -10000;

   /* FIXME - increase reference counter of sender's message queue here */

   Message-&gt;Msg.hwnd = Wnd;
   Message-&gt;Msg.message = Msg;
   Message-&gt;Msg.wParam = wParam;
   Message-&gt;Msg.lParam = lParam;
   Message-&gt;CompletionEvent = &amp;CompletionEvent;
   Message-&gt;Result = &amp;Result;
   Message-&gt;lResult = 0;
   Message-&gt;QS_Flags = 0;
   Message-&gt;SenderQueue = ThreadQueue;
   Message-&gt;CallBackSenderQueue = NULL;
   IntReferenceMessageQueue(ThreadQueue);
   Message-&gt;CompletionCallback = NULL;
   Message-&gt;CompletionCallbackContext = 0;
   Message-&gt;HookMessage = HookMessage;
   Message-&gt;HasPackedLParam = FALSE;

   IntReferenceMessageQueue(MessageQueue);

   /* add it to the list of pending messages */
   InsertTailList(&amp;ThreadQueue-&gt;DispatchingMessagesHead, &amp;Message-&gt;DispatchingListEntry);

   /* queue it in the destination's message queue */
   InsertTailList(&amp;MessageQueue-&gt;SentMessagesListHead, &amp;Message-&gt;ListEntry);

   Message-&gt;QS_Flags = QS_SENDMESSAGE;
   MsqWakeQueue(MessageQueue, QS_SENDMESSAGE, TRUE);

   /* we can't access the Message anymore since it could have already been deleted! */

   if(Block)
   {
      //我们绝大部分都是不阻塞的。
   }
   else
   {
      PVOID WaitObjects[2];

      WaitObjects[0] = &amp;CompletionEvent;
      WaitObjects[1] = ThreadQueue-&gt;NewMessages;
      do
      {
         UserLeaveCo();

         WaitStatus = KeWaitForMultipleObjects(2, WaitObjects, WaitAny, UserRequest,
                                               UserMode, FALSE, (uTimeout ? &amp;Timeout : NULL), NULL);

         UserEnterCo();

         if(WaitStatus == STATUS_TIMEOUT)
         {
            //...
         }
         while (co_MsqDispatchOneSentMessage(ThreadQueue))
            ;
      }
      while (NT_SUCCESS(WaitStatus) &amp;&amp; STATUS_WAIT_0 != WaitStatus);
   }

   if(WaitStatus != STATUS_TIMEOUT)
      *uResult = (STATUS_WAIT_0 == WaitStatus ? Result : -1);

   return WaitStatus;
}
</code></pre>

<p>GetMessage返回了，一般是跑2个函数。</p>

<p>TranslateMessage(&amp;msg);
DispatchMessage(&amp;msg);</p>

<p>这里我们不讨论TranslateMessage，这个主要是辅助一些硬件消息相关。</p>

<p>DispatchMessage的事情，就是做这个调用相对用的窗口过程部分。这部分主要是从系统调用我们的代码，目前对这个还没有什么兴趣。</p>

<p>类似的还有模态窗口，产生模态窗口的窗口，会阻塞一些消息，但是却不是阻塞所有的消息，别的线程依然可以给发SendMessage。为什么呢？他们之间会有联系么？</p>
]]></content>
  </entry>
  
</feed>
