<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[不会开机的男孩]]></title>
  <link href="http://studentdeng.github.com/atom.xml" rel="self"/>
  <link href="http://studentdeng.github.com/"/>
  <updated>2014-05-09T22:42:27+08:00</updated>
  <id>http://studentdeng.github.com/</id>
  <author>
    <name><![CDATA[studentdeng]]></name>
    <email><![CDATA[studentdeng@hotmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[facebook pop & tweaks demo]]></title>
    <link href="http://studentdeng.github.com/blog/2014/05/09/pop-tweaks/"/>
    <updated>2014-05-09T19:39:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/05/09/pop-tweaks</id>
    <content type="html"><![CDATA[<p>最近facebook开源了2个很有价值的project <a href="https://github.com/facebook/pop">pop</a>和<a href="https://github.com/facebook/Tweaks">Tweaks</a>。
facebook提供了一个非常赞的topic-<a href="http://www.youtube.com/playlist?list=PLb0IAmt7-GS2sh8saWW4z8x2vo7puwgnR">Building Paper</a>。</p>

<p>这篇文章来简单介绍一下<a href="https://github.com/facebook/pop">pop</a>的使用，最后使用<a href="https://github.com/facebook/Tweaks">Tweaks</a>来微小调整动画参数来达到我们最希望的效果。</p>

<p>这是我们最后的效果:</p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNzA5ODM1NTQ4" frameborder=0 allowfullscreen></iframe>
</div>


<h1>pop is powerful</h1>

<p>这个动画效果很简单，有很多方式都可以做到，但是pop来实现它，只需要下面几行代码。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">POPBasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">POPBasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">property</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">animationProperty</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">numberLabel</span> <span class="nl">pop_addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;numberLabelAnimation&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="n">POPMutableAnimatableProperty</span> <span class="o">*</span><span class="p">)</span><span class="n">animationProperty</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">POPMutableAnimatableProperty</span>
</span><span class='line'>      <span class="nl">propertyWithName:</span><span class="s">@&quot;com.curer.test&quot;</span>
</span><span class='line'>           <span class="nl">initializer:</span><span class="o">^</span><span class="p">(</span><span class="n">POPMutableAnimatableProperty</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>               <span class="n">prop</span><span class="p">.</span><span class="n">writeBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="n">CGFloat</span> <span class="n">values</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>                 <span class="n">UILabel</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="n">UILabel</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
</span><span class='line'>                 <span class="n">NSNumber</span> <span class="o">*</span><span class="n">number</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>                 <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="p">[</span><span class="n">number</span> <span class="n">intValue</span><span class="p">];</span>
</span><span class='line'>                 <span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="err">@</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="n">stringValue</span><span class="p">];</span>
</span><span class='line'>               <span class="p">};</span>
</span><span class='line'>           <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>哈哈，搞定了。pop太强大了。但是细心的同学会发现动画似乎不是我们想要的，我们希望做到那种一开始很快速很激动，最后却有一点慢慢的“欲求不能”的感觉。</p>

<p>很直观的，我们使用了万能的EaseOut动画</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">POPBasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">POPBasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">property</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">animationProperty</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//增加animation 时间函数控制</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionEaseOut</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>增加了一行代码，但是发现这个动画变化的时间还是不能让我们满意，一开始变化的还是慢，后面变化的又有点快。</p>

<h1>how can we better build animation</h1>

<p>动画的实现其实很简单，抛开性能，就是一个个不断变化的图片，对于我们这个简单的动画，就是一个从0到8000的变化，如果x轴为时间，y轴为大小。我们第一个动画其实是这个样子</p>

<p><span class='caption-wrapper'><img class='caption' src='http://studentdeng.github.com/images/pop-demo-3.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>easeout好一点是这样子</p>

<p><span class='caption-wrapper'><img class='caption' src='http://studentdeng.github.com/images/pop-demo-1.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>我们其实希望是这个样子</p>

<p><span class='caption-wrapper'><img class='caption' src='http://studentdeng.github.com/images/pop-demo-2.png' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>CAMediaTimingFunction 实际上还提供另一个方法，不是很常用，但是却非常适合我们现在的场景。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">functionWithControlPoints:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">c1x</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c1y</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c2x</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c2y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们描述的“时间函数”其实就是<a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve">贝塞尔曲线</a>。</p>

<p>这里推荐一个<a href="http://cubic-bezier.com/">网站</a>可以很直观的生成贝塞尔曲线。
这里我们得到了参数（.12,1,.11,.94）。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">POPBasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">POPBasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">property</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">animationProperty</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//修改animation 时间函数</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithControlPoints:</span><span class="mf">0.12</span> <span class="o">:</span><span class="mi">1</span><span class="o">:</span> <span class="mf">0.11</span><span class="o">:</span><span class="mf">0.94</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们已经得到我们想要的动画效果了。而且看上去相当不错。</p>

<h1>how can we better build animation</h1>

<p>如何才能有更好的效果呢？动画的速度，时间，等等参数都会影响到动画的效果是不是会完美。如何判断动画效果是否足够好。的确是个很难的问题。而解决这个问题的关键，不在于工程师自己折腾，应该找专业的人来做。而这时<a href="https://github.com/facebook/Tweaks">Tweaks</a>就闪亮登场了。</p>

<p>初始化的时候创建2个tweak用来动态调整时间和目标数值。并修改一下默认的UIWindow为<code>FBTweakShakeWindow</code></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="c1">//reset window</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">window</span> <span class="o">=</span> <span class="p">[[</span><span class="n">FBTweakShakeWindow</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">bounds</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">FBTweak</span> <span class="o">*</span><span class="n">animationDurationTweak</span> <span class="o">=</span>
</span><span class='line'>      <span class="n">FBTweakInline</span><span class="p">(</span><span class="s">@&quot;Content&quot;</span><span class="p">,</span> <span class="s">@&quot;Animation&quot;</span><span class="p">,</span> <span class="s">@&quot;Duration&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animationDurationTweak</span><span class="p">.</span><span class="n">stepValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">0.1f</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animationDurationTweak</span><span class="p">.</span><span class="n">precisionValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">3.0f</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">FBTweak</span> <span class="o">*</span><span class="n">animationToValueTweak</span> <span class="o">=</span>
</span><span class='line'>      <span class="n">FBTweakInline</span><span class="p">(</span><span class="s">@&quot;Content&quot;</span><span class="p">,</span> <span class="s">@&quot;Animation&quot;</span><span class="p">,</span> <span class="s">@&quot;ToValue&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animationToValueTweak</span><span class="p">.</span><span class="n">stepValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animationDurationTweak</span><span class="p">.</span><span class="n">precisionValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">1.0f</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>再把原来创建动画的代码稍微修正一下</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">POPBasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">POPBasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">property</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">animationProperty</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithControlPoints:</span><span class="mf">0.12</span> <span class="o">:</span><span class="mi">1</span><span class="o">:</span> <span class="mf">0.11</span><span class="o">:</span><span class="mf">0.94</span><span class="p">];</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">double</span> <span class="n">animationDuration</span> <span class="o">=</span>
</span><span class='line'>      <span class="n">FBTweakValue</span><span class="p">(</span><span class="s">@&quot;Content&quot;</span><span class="p">,</span> <span class="s">@&quot;Animation&quot;</span><span class="p">,</span> <span class="s">@&quot;Duration&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span>
</span><span class='line'>      <span class="err">@</span><span class="p">(</span><span class="n">FBTweakValue</span><span class="p">(</span><span class="s">@&quot;Content&quot;</span><span class="p">,</span> <span class="s">@&quot;Animation&quot;</span><span class="p">,</span> <span class="s">@&quot;ToValue&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">));</span>
</span><span class='line'>  <span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">animationDuration</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">numberLabel</span> <span class="nl">pop_addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;numberLabelAnimation&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样当摇晃手机的时候就可以动态调整动画参数了，最后数据会保存在plist ：）。</p>

<p>越简单的越强大~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Patterns in iOS — Class Clusters]]></title>
    <link href="http://studentdeng.github.com/blog/2014/04/08/design-patterns-class-clusters/"/>
    <updated>2014-04-08T14:49:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/04/08/design-patterns-class-clusters</id>
    <content type="html"><![CDATA[<p>我对设计模式一直都是一个若有若无的感觉，特别是在手机端开发，觉得用处不是很大，认为设计模式是为了大规模团队合作，分工才能体现出效果。设计模式可以通过分不同的“层”让大家协同开发，相互之间不产生影响。但是最近看法有点改变，觉得还是需要多少了解一些。</p>

<p>天天使用的framework确实是一个庞大的项目，从framework的设计中可以找到很多设计模式的影子，而且还是一个很好的生产化的例子。这里先介绍 Class Clusters</p>

<p>Class Clusters 几乎涉及到iOS日常的所有开发过程中，也可能正是这样，导致我们很容易把它彻底遗忘。这里就拿最常用的 NSString 来讲。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">string1</span> <span class="o">=</span> <span class="s">@&quot;helloworld&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">string2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="s">@&quot;:%@&quot;</span><span class="p">,</span> <span class="s">@&quot;helloworld&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">string3</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSHomeDirectory</span><span class="p">()</span> <span class="nl">stringByAppendingPathComponent:</span><span class="n">string1</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSTextStorage</span> <span class="o">*</span><span class="n">storage</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTextStorage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString:</span><span class="n">string1</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">string4</span> <span class="o">=</span> <span class="p">[</span><span class="n">storage</span> <span class="n">string</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string1</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string2</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string3</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string4</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>不知道有多少人试过哈，string3的返回还是让我吃了一惊。下面的结果是在Xcode5.1 SDK7.1 下的结果。</p>

<pre><code>__NSCFConstantString
__NSCFString
NSPathStore2
NSBigMutableString
</code></pre>

<p>通过上面的方法创建的 NSString 最后都产生了不同的子类。有人可能会奇怪为什么需要不同的 NSString。因为对于大部分的以阅读内容为主的App来讲，很大部分资源消耗在了字符串处理上面（存储，解析，比较等等），所以对于字符串的存储需要有不同的方式来满足不同的情况，这样才能有性能上的提高。</p>

<div class='notebox'><p><strong>Note: </strong>设想一下，在这些场景上面，如果Apple直接把这些类扔给开发者，会有什么问题呢？</p><p>那么开发者需要自己在不同的场景决定使用不同的子类，不仅学习成本提高，而且也容易生成性能不太好的代码。<br/>现在简单的 NSString 就可以直接覆盖上面的所有场景。而且随着iOS的软硬件的后续开发，开发者还可以在不修改代码的情况下获得性能提升。</p></div>


<p>既然看到了它的强大之处，那么就开始了解吧。
既然这是第一篇DesignPattern那么就从最简单开始 ：)</p>

<h2>Abstract Classes</h2>

<p>这里引用一下Mike的内容</p>

<blockquote><p>An abstract class is a class which is not fully functional on its own. It must be subclassed, and the subclass must fill out the missing functionality.</p><p>An abstract class is not necessarily an empty shell. It can still contain a lot of functionality all on its own, but it&#8217;s not complete without a subclass to fill in the holes.</p><footer><strong>Mike Ash</strong> <cite><a href='https://mikeash.com/pyblog/friday-qa-2010-03-12-subclassing-class-clusters.html'>Friday Q&A 2010-03-12: Subclassing Class Clusters</a></cite></footer></blockquote>


<p>Abstract Class 的概念很简单，类中所有的方法不需要全部有具体的实现，相当于定义了很多的接口。比如一开始的 NSString</p>

<h2>Class Clusters</h2>

<blockquote><p>A class cluster is a hierarchy of classes capped off by a public abstract class. The public class provides an interface and a lot of auxiliary functionality, and then core functionality is implemented by private subclasses. The public class then provides creation methods which return instances of the private subclasses, so that the public class can be used without knowledge of those subclasses.</p><footer><strong>Mike Ash</strong> <cite><a href='https://mikeash.com/pyblog/friday-qa-2010-03-12-subclassing-class-clusters.html'>Friday Q&A 2010-03-12: Subclassing Class Clusters</a></cite></footer></blockquote>


<p>Clusters的角色不仅要实现 Abstract Class 的方法，还需要自己实现自己的特殊化需求。Abstract Class 负责提供一个“外壳”，真正“干活”的就是Cluster class。这样外部就只需要了解Abstract Class就可以了。</p>

<h2>NSString Benefits</h2>

<p>比如 __NSCFConstantString 负责 const string，类似 @&#8221;helloworld&#8221;这样的字符串。这样的字符串有一个特点，不会被修改，当真正处理的时候，可以分配大小合适的内存，甚至可以分配在只读 data segment上面，而不需要分配在堆上面，如果有相同的字符串引用就可以完全赋值相同的地址。那么在retainCount上面的处理也就和其他字符串处理有很大不同。</p>

<p>NSPathStore2 看上去是处理有Path相关的字符串，因为没有源代码，这里我们可以大胆猜测一下，path相关的主要是做字符串的拼接操作，而这些字符串通常很长，占用空间大，但是重复的概率缺很高，那么就可以缓存一些字符串，这样可以减少一些内存的分配释放开销。</p>

<h2>How to use</h2>

<blockquote><p>The class cluster architecture involves a trade-off between simplicity and extensibility: Having a few public classes stand in for a multitude of private ones makes it easier to learn and use the classes in a framework but somewhat harder to create subclasses within any of the clusters.</p><footer><strong>Apple Develpoer Document</strong> <cite><a href='https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/ClassCluster.html'>Cocoa Core Competencies</a></cite></footer></blockquote>


<p>就像Apple文档中提到的，Class Cluster 是在简单和扩展性上面做了一个妥协。Class Clusters 的子类化比较麻烦，而且也看上去也非常trick,Apple 更推荐的方法是用组合的方法来扩展。</p>

<p>大家都知道设计模式有一个非常重的坑就是被过渡设计。Class Cluster 可以帮我们</p>

<ul>
<li>减少了if else 这样缺乏扩展性的代码</li>
<li>增加新功能支持不影响其他代码</li>
</ul>


<p>那么这个非常适合应用在适配上面，比如不同屏幕的适配，不同厂家可能的不同的需求。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">alloc</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">SFSSearchTVC</span> <span class="n">class</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">([</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemMajorVersion</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">[</span><span class="n">SFSSearchTVC6</span> <span class="n">alloc</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemMajorVersion</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">[</span><span class="n">SFSSearchTVC7</span> <span class="n">alloc</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="n">alloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是代码来自<a href="http://bjmiller.me/post/69043165385/a-cluster-to-remove-clutter">BJ Miller&#8217;s blog A Cluster to Remove Clutter</a>
是用于适配iOS6，iOS7的简单例子。</p>

<h2>Conclusion</h2>

<p>很多设计模式都很像，也很容易糊涂，比如工厂模式和Class Clusters在某些地方就很类似，我自己也并不能很好的分清楚。
设计模式的本质是为了解耦。不管使用哪个设计模式，我们最后追求的都是简单、容易维护和扩展的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress notebox plugin]]></title>
    <link href="http://studentdeng.github.com/blog/2014/04/04/octopress-notebox-plugin/"/>
    <updated>2014-04-04T16:48:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/04/04/octopress-notebox-plugin</id>
    <content type="html"><![CDATA[<p>用了这么长时间的<a href="http://octopress.org/">octopress</a>总该扩展一点点事情了，在Blogging的时候，总有一些信息是需要被特殊标记的，但是我并不喜欢简单的加粗或是斜体。类似的东西在Apple Document中有很多</p>

<p><span class='caption-wrapper'><img class='caption' src='http://studentdeng.github.com/images/octopress_notebox_plugin1.png' width='' height='' title='Apple Document Note sample'><span class='caption-text'>Apple Document Note sample</span></span></p>

<p>这里我就把这个功能照搬到octopress中了。</p>

<p>1.在<em>plugins</em>目录创建一个notebox.rb</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='Ruby'><span class='line'><span class="k">module</span> <span class="nn">Jekyll</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Notebox</span> <span class="o">&lt;</span> <span class="ss">Liquid</span><span class="p">:</span><span class="ss">:Block</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span>
</span><span class='line'>      <span class="k">super</span>
</span><span class='line'>      <span class="vi">@id</span> <span class="o">=</span> <span class="nb">id</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
</span><span class='line'>      <span class="n">stressText</span> <span class="o">=</span> <span class="n">paragraphize</span><span class="p">(</span><span class="k">super</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;&lt;div class=&#39;notebox&#39;&gt;&lt;p&gt;&lt;strong&gt;Note: &lt;/strong&gt;</span><span class="si">#{</span><span class="n">stressText</span><span class="si">}</span><span class="s2">&lt;/p&gt;&lt;/div&gt;&quot;</span>
</span><span class='line'>      <span class="n">source</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">paragraphize</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
</span><span class='line'>      <span class="s2">&quot;</span><span class="si">#{</span><span class="n">input</span><span class="o">.</span><span class="n">lstrip</span><span class="o">.</span><span class="n">rstrip</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\n\n/</span><span class="p">,</span> <span class="s1">&#39;&lt;/p&gt;&lt;p&gt;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\n/</span><span class="p">,</span> <span class="s1">&#39;&lt;br/&gt;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="ss">Liquid</span><span class="p">:</span><span class="ss">:Template</span><span class="o">.</span><span class="n">register_tag</span><span class="p">(</span><span class="s1">&#39;notebox&#39;</span><span class="p">,</span> <span class="ss">Jekyll</span><span class="p">:</span><span class="ss">:Notebox</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在<em>sass/custom</em>中的文件<em>_stype.scss</em>的最后添加下面的代码</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.notebox</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">border</span><span class="o">:</span><span class="m">1px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">border-style</span><span class="o">:</span> <span class="k">solid</span><span class="p">;</span>
</span><span class='line'>  <span class="k">border-color</span><span class="o">:</span> <span class="m">#5088C5</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-color</span><span class="o">:</span><span class="m">#fff</span><span class="p">;</span>
</span><span class='line'>  <span class="k">margin</span><span class="o">:.</span><span class="m">75em</span> <span class="m">0</span> <span class="m">1.5em</span><span class="p">;</span>
</span><span class='line'>  <span class="k">padding</span><span class="o">:.</span><span class="m">75em</span> <span class="m">.667em</span> <span class="m">.75em</span> <span class="m">.750em</span><span class="p">;</span>
</span><span class='line'>  <span class="k">text-align</span><span class="o">:</span><span class="k">left</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.markdown的语法（<em>因为格式问题写成了％，需要替换成%</em>）</p>

<pre><code>{％ notebox ％}
the text to note
{％ endnotebox ％}
</code></pre>

<p>效果</p>

<div class='notebox'><p><strong>Note: </strong>text</p></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth Concept]]></title>
    <link href="http://studentdeng.github.com/blog/2014/03/22/corebluetooth/"/>
    <updated>2014-03-22T20:41:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/03/22/corebluetooth</id>
    <content type="html"><![CDATA[<p>Core Bluetooth 里面的名词还是挺多的，这里简单记录一下，一上来的时候，还是很容易混淆的，这里记录一下。</p>

<h1>Basic Concept</h1>

<p>Bluetooth low energy (<a href="http://en.wikipedia.org/wiki/Bluetooth_low_energy#Radio_interface">BLE</a>，还有地方叫做BTLE，最恨各种简写了) 简单说是一种低功耗的短距离无线传输技术，主要用于低功耗设备传输，比如心率、记步器、智能家居方向,还有连接其他iOS设备。</p>

<p>Core Bluetooth API 支持BLE4.0，做了协议封装，让开发者不需要完整了解BLE协议就可以快速开发APP。</p>

<h2>Central and Peripheral</h2>

<p>BLE中有2个非常重要的概念就是Central和Peripheral，有一点类似Client Server。</p>

<ul>
<li>Peripheral是数据的发送方（比如运动手环需要把位置，步数等数据传递给其他设备）。</li>
<li>Central是数据的接收方（比如手机接收手环传递来的步数）</li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue1.png" alt="1-1 Central 和 Peripheral 心率设备和Apple product" /></p>

<h2>Centrals Discover and Connect to Peripherals That Are Advertising</h2>

<ul>
<li><p>Peripheral把advertising packets广播出去，advertising packet 包括会包含一些重要的信息，比如设备名字，所提供的服务。</p></li>
<li><p>Central 则是扫描自己感兴趣的advertising packet，比如一个APP需要查找当前家里的室温，会通过参数设定，只是检索温度设备发来的packet。</p></li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue2.png" alt="1-2 一个简单的advertising模型" /></p>

<h2>Data structure</h2>

<ul>
<li>Peripheral 是最上层的一种服务抽象，比如iOS 系统内置的<a href="http://studentdeng.github.io/blog/2014/03/22/ancs/">ANCS</a>服务,另外我们自己也可以创建自己的服务。</li>
<li>characteristic 则是用来描述服务中的具体内容（比如手环有传递行走路程的接口，还有行走位置的接口），一个服务可以包含多个characteristics。</li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue3.png" alt="1-3 心率检测仪包含1个服务，1个服务中包含2个characteristics,一个用来传递心率，一个用来传递位置" /></p>

<h1>How to</h1>

<p><a href="https://github.com/kickingvegas/YmsCoreBluetooth">YmsCoreBluetooth</a> 是个不错的框架，有很详细的<a href="http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/docs/tutorial/Tutorial.html">介绍</a>，这里就不赘述了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apple Notification Center Service]]></title>
    <link href="http://studentdeng.github.com/blog/2014/03/22/ancs/"/>
    <updated>2014-03-22T15:42:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/03/22/ancs</id>
    <content type="html"><![CDATA[<h1>名词解释与约定</h1>

<h2>名词解释</h2>

<ul>
<li>Apple Notification Center Service 简称 ANCS。</li>
<li>ANCS 服务（iOS设备，如iPhone，iPad等）的publisher 称为 Notification Provider。</li>
<li>任意的ANCS服务的client（硬件设备，配件）称为 Notification Consumer。</li>
<li>Generic Attribute Profile简称GATT。</li>
<li>在iOS NotificationCenter 显示的通知称为 iOS notification。</li>
<li>通过GATT characteristic 发布的通知称为 GATT notification。</li>
<li>iPhone、 iPad等运行iOS系统的设备称为iOS设备</li>
</ul>


<h2>约定</h2>

<p>文本档覆盖的内容中除特别描述外，和字节序相关的都是用Little-endian (小端模式)。
文本档覆盖的内容中除特别描述外，和字符串传递相关的都是UTF-8</p>

<div class='notebox'><p><strong>Note: </strong>ANCS 并不保证始终存在，服务开启，关闭机制由iOS系统决定，Device 需要一直检测，查找ANCS是否存在。</p></div>


<h1>协议内容</h1>

<p>ANCS的uart profile UUID : ” 7905F431-B5CE-4E99-A40F-4B1E122D00D0”</p>

<p>uart profile 中包括3个 characteristic</p>

<ul>
<li>Notification Source   UUID: “9FBF120D-6301-42D9-8C58-25E699A21DBD” (notifiable)</li>
<li>Control Point             UUID: “69D1D8F3-45E1-49A8-9821-9BBDFDAAD9D9”(write with             response)</li>
<li>Data Source           UUID:” 22EAC6E9-24D6-4BB5-BE44-B36ACE7C7BFB &#8220;(notifiable)</li>
</ul>


<p>Device端Notification Source 是必须实现的。Centrol Point 和 Data Source 可选。</p>

<h2>Notification Source Characteristic</h2>

<p>Notification Source characteristic 包括3个功能</p>

<ul>
<li>新的iOS设备通知</li>
<li>iOS设备通知修改</li>
<li>iOS设备通知删除</li>
</ul>


<p>当Device端 subscribes Notification Source characteristic时，GATT Notification 会立刻分发出去。所以，Notification consumer （Device）在subscribe之前就需要做好立马接受和处理消息的状态。</p>

<h3>Notification Source response format</h3>

<p><span class='caption-wrapper'><img class='caption' src='http://studentdeng.github.com/images/ancs1.png' width='' height='' title='图2-1 Notification Source characteristic 通过GATT Notification 的格式。'><span class='caption-text'>图2-1 Notification Source characteristic 通过GATT Notification 的格式。</span></span></p>

<ul>
<li>EventID：描述iOS设备上面的通知是增加、删除、还是修改。</li>
<li>EventFlags: 标志位，描述iOS设备通知（重要， 静默）</li>
<li>CategoryID：iOS设备通知类型</li>
<li>CategoryCount：给定类型的通知数量，比如有2个未读email消息通知，这时有一个新的未读消息通知push到iOS设备，这时CategoryCount = 3
NotificationUID：通知的唯一标示，这个字段用于和Control Point characteristic 检索更多的信息。</li>
</ul>


<p><img src="http://studentdeng.github.io/images/ancs2.png" alt="image" /></p>

<p>表格3-1：CategoryID的描述</p>

<p><img src="http://studentdeng.github.io/images/ancs3.png" alt="image" /></p>

<h3>Notification Source Response Example</h3>

<p>Device 获取的来此Notification Source的数据是“00 01 00 01 43 00 00 00”</p>

<p><img src="http://studentdeng.github.io/images/ancs4.png" alt="image" /></p>

<p>图2-2一个iOS通知的生命周期。</p>

<p>比如当iOS设备（如iPhone）收到一个iMessage消息，iOS NotificationCenter会产生一个Notification，ANCS会通知device 有一个新的通知。当iOS设备阅读这个iMessage消息之后，iOS Not ificationCenter 会删除掉这个通知，ANCS把这个删除通知push到device</p>

<h2>Control Point 和 Data Source Characteristic</h2>

<p>只是Notification Source 不能获得足够的信息，
Control Point 和 Data Source characteristic用来解决这个问题。
Device 向Control Point characteristic 写一个命令，如果成功，会从DataSource characteristic 获得response。</p>

<h3>获取通知属性命令</h3>

<p>该命令根据NotificationUID 查找通知的详细内容（通知属性）。</p>

<p><img src="http://studentdeng.github.io/images/ancs5.png" alt="image" /></p>

<p>图2-3 获取通知属性命令格式
CommandID: 必须设置为0
NotificationUID：通知的唯一标示（Notification Source 获得）
AttributeIDS：需要检索信息list</p>

<p><img src="http://studentdeng.github.io/images/ancs6.png" alt="image" /></p>

<p>图3-5 可以检索的通知属性列表，其中Title， subtitle， Message 需要增加2个bytes的字段表示长度。</p>

<p>获取通知属性命令Example
“00 43 00 00 00 00 01 FF FF 05”</p>

<p><img src="http://studentdeng.github.io/images/ancs7.png" alt="image" /></p>

<h3>获取通知属性命令Response消息格式</h3>

<p><img src="http://studentdeng.github.io/images/ancs8.png" alt="image" /></p>

<p>图2-4 获取通知属性命令返回数据格式</p>

<p>CommandID： 0
NotificationUID：通知的唯一标示
AttributeList：具体的属性返回数据列表. 如果返回的属性空，长度是0</p>

<p>如果返回的数据长度大于 GATT MTU，那么数据会被分几段传输。Device 需要对数据拼接。</p>

<h3>通知属性命令Response 消息格式Example</h3>

<p>下图查找 NotificationUID为2的 AppIdentifier、Title、SubTitle、Message Date属性返回数据</p>

<p><img src="http://studentdeng.github.io/images/ancs9.png" alt="image" /></p>

<h2>获取APP属性命令</h2>

<p>该命令通过APPIdentifier查找iOS设备中安装的APP的属性。</p>

<p>图2-5 获取APP属性命令格式</p>

<p>CommandID: 必须设置成1
AppIdentifier：字符串’\0’ 结尾。
AttributeIDS：查找ID列表</p>

<h2>获取APP属性命令 Example</h2>

<p>查找AppIdentifier 为 “com.apple.mobilemail” 的APP属性</p>

<p><img src="http://studentdeng.github.io/images/ancs10.png" alt="image" /></p>

<h2>获取APP属性命令Response消息格式</h2>

<p><img src="http://studentdeng.github.io/images/ancs11.png" alt="image" /></p>

<p>图2-6获取APP属性命令返回数据格式</p>

<ul>
<li>CommandID：必须是1</li>
<li>AppIdentifier：字符串 ‘\0’结尾</li>
<li>AttributeList：具体的属性返回数据列表. 如果返回的属性空，长度是0</li>
</ul>


<p>如果返回的数据长度大于 GATT MTU，那么数据会被分几段传输。Device 需要对数据拼接。</p>

<h3>获取APP属性命令Response消息格式Example</h3>

<p>查找AppIdentifier 为 “com.apple.mobilemail” 的APP属性返回数据
汉字 “邮件”</p>

<p><img src="http://studentdeng.github.io/images/ancs12.png" alt="image" /></p>

<h2>sessions会话</h2>

<p>ANCS 的 session 从设备订阅characteristic 开始到取消订阅或是disconnect结束。所有的Identifier 比如 NotificationUID，AppIdentifier 只在当前的session有效。</p>

<p>当session结束后，设备需要删除掉所有的在session中获得的Identifier信息，这些信息会在session建立的时候重新通知设备.</p>

<h1>错误代码</h1>

<ul>
<li>未知命令：（0xA0）</li>
<li>无效命令:（0xA1）</li>
<li>无效参数（0xA2） : 比如NotificationUID 找不到</li>
</ul>


<p><em>注意：如果产生了上面的错误，都不会再收到任何的GATT 通知。</em></p>

<h1>参考内容</h1>

<p><a href="https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/AppleNotificationCenterServiceSpecification/Introduction/Introduction.html">Apple Notification Center Service (ANCS) Specification</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode5 Plugins 开发简介]]></title>
    <link href="http://studentdeng.github.com/blog/2014/02/21/xcode-plugin-fun/"/>
    <updated>2014-02-21T13:13:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/02/21/xcode-plugin-fun</id>
    <content type="html"><![CDATA[<p>这篇文章介绍如何给Xcode5开发插件。如果之前了解iPhone &amp; iPad 开发，那么下面的内容对您非常熟悉。最后我们会开发一个简单的插件，记录Xcode开发中Building的时间。</p>

<h1>准备工作</h1>

<p>首先编写一个Plugin还是需要不少额外的配置，这里推荐<a href="https://github.com/kattrali/Xcode5-Plugin-Template">Xcode Plugin Template</a>。用这个templage来帮助我们开发Plugin。</p>

<p>另外，编写插件和之前的iPhone or Mac上的APP不太一样。从某种意义上来说就是用Xcode调试Xcode。所以这里需要额外配置一点东西。</p>

<ul>
<li>修改Scheme</li>
</ul>


<p><img src="http://studentdeng.github.io/images/xcode_plugin1.png" alt="image" /></p>

<ul>
<li>Executable 选择Xcode.app</li>
</ul>


<p><img src="http://studentdeng.github.io/images/xcode_plugin2.png" alt="image" /></p>

<p>当我们Build &amp; Run Project的时候就可以看到启动了一个新的Xcode进程，当然除了Xcode， Mail或是其他程序我们都可以调试。</p>

<h1>如何编写插件</h1>

<p>因为Apple至今并没有公开Xcode Plugin的文档，所以我们需要通过一些其他方法寻找思路。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserver:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">notificationLog:</span><span class="p">)</span> <span class="nl">name:</span><span class="nb">nil</span> <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>  
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">notificationLog:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="n">notify</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>这里稍微有一点特殊，参数notificationName 设为nil，下面是Apple的文档，不是很清楚。</p>

<pre><code>notificationName If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer.
</code></pre>

<p>但是目前来看，似乎可以看到所有的通知。当然绝大部分是重复的，对我们没有意义。很幸运最后我们找到了2个通知是我们需要的，下面的代码，已经做了过滤。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">notificationLog:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="n">notify</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span> <span class="nl">hasPrefix:</span><span class="s">@&quot;IDEBuildOperation&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>这2个通知分别是</p>

<ul>
<li>IDEBuildOperationWillStartNotification</li>
<li>IDEBuildOperationDidStopNotification</li>
</ul>


<p>这个我们不得不赞一下cocoa的命名方式，大家都可以猜出这2个通知的含义。剩下的事情就很简单了。统计build时间。</p>

<h1>最后</h1>

<p>这是<a href="https://github.com/studentdeng/Buddy">项目源代码</a>。有兴趣的同学可以玩玩，看一下自己的编译时间有多长。另外最终的代码中还增加了2个小的features。</p>

<ul>
<li>查看当前打开Xcode的人数</li>
<li>查看自己打开Xcode专注的时间有多长，这个时间是当Xcode被focus的时候才统计，另外不足1分钟不计算在内。</li>
</ul>


<p>Have fun！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2008-2018]]></title>
    <link href="http://studentdeng.github.com/blog/2014/02/11/2008-2018/"/>
    <updated>2014-02-11T02:04:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/02/11/2008-2018</id>
    <content type="html"><![CDATA[<h1>5年前拿到人生第一个冠军</h1>

<p>因为小时候很贪玩，并没有考好大学。07年上了一个普通大学。08年正好大二，本来我是打算金盆洗手好好学习的，而且大一做的还不错。但是一个叫做Dota的游戏又给了我一次玩的机会。当时玩这个的人还很少，我和室友和另外3个其他学院的家伙们组成了一个电竞战队。我们的能力起初并不被看好，但是我们却拿到了当年全省第一届电竞Dota项目的冠军，也获得了人生第一桶金。再后来还参加了另一个比赛，最后去E世界演播大厅打比赛。一路上来每局都是逆风，但我们都一次次靠团队配合和抓对方失误扳了回来，最后成为一个黑马进入华北赛区8强。</p>

<p>游戏对很多人来说都是玩玩的娱乐项目，但是对我和我的小伙伴们来说，里面有很多个日日夜夜看比赛录像，锻炼意识，枯燥的基本功训练在里面。里面有成功的欢乐（冠军之后，还被媒体采访过）也有遗憾的泪水。我还记得打完最后一场在回旅店的路上。我挺自责的，因为团队中我是中单的Gank发起者（Dota游戏里面一个比较重要的位置），而我觉得我发挥的不够好，连累了大家。我的队长对我说，咱们没有北京这些学校这么好的电竞氛围，能走到这里已经很厉害了。Anyway，此生对游戏再也没有当年的执着劲了。因为能够在正确的时间，在一个玩游戏被众人鄙视的氛围里面遇到一帮子一起玩的人，组成一个团队，并且最后拿到冠军，已经是我能做到的极限了而且还有极大运气。</p>

<h1>4年前开始思考未来的工作</h1>

<p>在游戏人生将近10年之后，我发现，我还是得回到现实，为自己的未来做打算。因为当时在学生会网络部混日子，给学院和学校做个烂网站。然后有一天其他学院的同学找到我说咱们一起联合做一个项目，参加全国的比赛。也托玩游戏的福，我妈妈觉得她的儿子，这么多年来第一次战胜了“别人家的孩子”，给我买了一个多普达的手机，是我的第一部智能手机。极大的震撼了我，我觉得电脑太笨重了，便携的移动设备一定是王道，因为有大量的碎片时间可以利用，我觉得智能手机一定会超过PC，我的未来一定是在移动方面的。也托这个比赛的福，更刺激了我在移动方面的兴趣，从而在网上认识了一些IT界的大牛，都在大公司，还有在国外工作的，并且参与了他们的开源项目。大二的一个暑假我都在编程中度过的，最后那个比赛获得了优秀奖，全国前20。和他们一起工作，对我的帮助极大，不仅是理论还是实践。而且我相信给我更多的时间可以做的更好，因为我参加的那个开源项目是当时windows mobile上面最好的也是唯一的UI Framework。</p>

<h1>3年前开始创业</h1>

<p>不知不觉大四了，之前一起参加开源项目的一个家伙，准确说是2个家伙要出来创业了，不准备在大公司呆了，（他们一个在微软一个在中国移动），然后这个家伙给我吹了一个大泡泡，现在想想挺有趣的，当是准备做基于手机联系人的IM，那会还没有米聊和微信。我觉得挺有意思的，这个不就是做一个移动版本的QQ么，而且当是的手机发短信还是挺费钱的，一条信息的流量几乎忽略不计，而且没有字数限制。一定可以改变人们的沟通方式，后面还可以发图片发声音，而不是只是文字。当是的产品原型是国外的Kik Messenger。当然，我们并没有做到最后，因为各种各样的原因，最后我们放弃了这个项目。</p>

<p>在2010年底，我们开始把精力转向在线教育。更准确说的是在线英语教育。我接触在线教育是在小学的时候，在线教育能够把高质量的教学资源给更多的人，而且中国学英语的人会越来越多，市场会越来越大。另外结合手机本身就可以发音的特性，这些都是普通书本不能提供的。最后我们还找到了一家著名的英语培训机构作为我们的内容提供商。另外参考了一家广州企业的盈利模式，然后开始尝试。我在这个过程中开始把之前做IM项目积累的经验，快速应用到这个项目中。而且最后作为我的毕业设计，拿到最高分90，做为我大学生活的结束。</p>

<h1>2年前开始转行，拿投资</h1>

<p>我第一次看到iPhone是大二的时候，当时我觉得这东西就是一个掌机，后面才发现是手机（别笑话我），而且一直认为这是一个纯装逼的行为。但是当真正做到移动领域的时候，开发设计windows mobile上面App的时候，很多的设计的确都是参考iPhone的。也开始接触iPhone上面的开发，到后面发现windows mobile真的不行了。不管是工业设计，还是App的用户体验都差距巨大，但是价格缺没差多少。。。而Android的开放和便宜（相对于windwos mobile 的license），windows mobile 必然是没有前途的，于是乎开始了和AppStore 斗智斗勇的日子：），最后成为了国内比较早的一批iOS开发者。</p>

<p>创业的这个项目也遇到了问题，很多问题，盈利模式很难复制，用户没有在移动产品上面的付费习惯也缺乏渠道，而且用户量不仅不够，还在不断下滑。团队有部分人因为家庭问题，先走一步了（因为之前日子过的太苦逼，女朋友表示日子没法过）。我也考虑过离开，但是觉得不能以这种方式离开，主要是不能接受这种方式的失败，然后就继续做下去了。付费很难做，但是用户量还是可以有的。最后我们做了一个垂直社交————英语教育社区。当时英语教育软件里面为数不多的（可能是唯一的）移动社区App，我们被AppStore 推荐，iOS下载量一天增长了1W倍，加上Android成功内置电信，最后拿到了200W天使投资。这段日子虽然苦逼，却是我工作上面成长最快的时候，人总是被逼的么，拿着倒计时牌算日子过。中间遇到些问题并请教了很多国外的开发者，自己也写了一些内容比较深的blog（相对在那个时候），自认为在iOS设计和开发上面自己在业内可以排到top 5%，因为不仅产品被资本和Apple Store认可，而且那会自己的很多blog也在Google搜索的最前面。</p>

<p>另外，一个同学去CMU了，我觉得不管是我的工作，还是其他什么的，我都需要把英语学好了。我问他你准备了多长时间，他说4年。从英语到字幕组到论文到申请。
我知道我的大学成绩是这辈子不太可能去CMU了，但是我还是蛮想出国的，然后介于我低下的语言天赋，我觉得我至少需要准备3年英语。</p>

<h1>1年前退投资，分手</h1>

<p>2012年的开始还是蛮不错的，团队终于没有钱的压力了（暂时）。然后我们搬到了美团，美丽说他们曾经在的地方，创业公司么，大家都希望沾点喜气，而且交通也方便，而且便宜。然后我们3个月没有做事情，因为我们暂时走到了前面，而且前一段时间我们一直在转变，需要想清楚我们应该做什么。当然不是完全没做，只是主线产品没大的升级，做过一些其他的小尝试，但是效果都不好。整个团队都很迷茫，我也不例外。我觉得这样下去，我在年底就没有什么东西可以总结的了（最后显然我把事情想简单了），然后就报了EF的班，开始我的3年英语计划。另外开始健身，减肥。一个月减了20斤，每天游泳1.5km。工作方面开始负责服务器，不仅仅是负责iOS方向。实现并设计了新版本的服务器。时间转眼就到年底了。因为各种原因吧，我们和投资人谈崩，团队整体撤出，产品留给投资人。然后就是换办公室，无外乎就是换一个小房子，然后再清退一些人，有意思的是，这个时候也和女朋友分手了。这就是所谓的祸不单行吧。</p>

<p>2012挺特别的，我的生日正好是末日的那一天，可惜万分期待的末日并没有到来。我意识到我并不是真正的足够了解自己，也并不是真正的清楚自己在做什么，几年前我自认为我在做正确的事情，但是我在那个时候觉得我看不清楚。那会我开始接触MBTI，了解积极心理学，给自己灌超大量的鸡汤，感谢我的老大（leo,cube），感谢我周围的朋友（强X和顺X）,当然还有默默关注着我而且始终在背后默默帮我的风哥（突然想起来，最近实在太忙，坑了风哥了，对不住了），最后还要感谢一个远方的笔友。</p>

<h1>今年又转行了 Freelance</h1>

<p>2013年，移动互联网发生了天翻地覆的变化，一大堆的开发者涌入了这个行业，也有大量的App走到大家面前，我的tutor或是close friend，和他同甘共苦的另一半修成正果了，而且他也比较给力，前一段时间他们团队拿到$2000W的B轮，宝宝也有了，祝福。另外强X拿到Morgan的offer开始自己的职业生涯了。我呢？我觉得前几年过的太累了，按照老大的话，就是过的没有尊严。2013年准备挣挣钱。这一年来说我可以算是一个Freelance。平时就是看看书，学学英语，健健身，遛遛狗。有事情了，然后做一点。到头来还算不错，至少比一般大公司挣得多。不用上下班，没有人约束你做什么，想睡几点睡几点。一年也就工作不到4个月，大部分在休假。但却是我最难受的1年。因为这个生活显然是50岁的节奏，不是一个20多岁的人干得事情。当然这也有好处，就是我有大量的时间和负能量去支持我这个龌龊的灵魂又减了将近20斤，练出6块腹肌并且在年底来了一次马拉松。因为我如果不做一点东西的话，2013年总结的时候我该写点什么呢？</p>

<p>扯远了，移动行业2013年是一个起点，很多传统行业开始意识到移动领域的价值。而这一年中，我们的很多项目也和他们相关。年底也出现了很多将互联网概念和传统行业结合创业的例子，不管是黄太吉还是马佳佳的情趣用品，都在告诉我们移动互联网还有一波浪潮可以淌。很多传统企业在2014年会加大在移动方面的探索。这里面还是有很多机会。我们现在的能力在2014年做到2013年甚至可能比2013年还要好也并不是不可能。但是我却不得不看清楚一个现实就是移动互联网入门的门槛是如此之低。很多一线大公司的平台级别产品极大的简化了开发的风险和时间。而且投行是这个一个行业的方向标，我自己也并不看好自己现在处的行业中的位置————一个纯互联网方案提供商。</p>

<p>小米通过他的品牌不仅卖手机，还要卖路由器，电视等等。我依稀感觉到互联网不仅仅是改变人们的沟通方式，会开始慢慢的走近人们的生活，而且事实上有些地方已经走到前面，包括交通（机票，火车票，打车），运动健康（可穿戴设备），还有一些政府的项目也开始增加了不少移动部分。另外就是后端的XX云概念。而这些都是我现在没有办法做的事情。所以，我又准备转行了。</p>

<h1>朋友家人</h1>

<p>在创业的风风雨雨中，认识了一些朋友。有的走上正轨，拿到B轮，得到市场认可，而且资本也会让他们继续平稳的走下去。线上教育一直是我喜欢做的事情，但是教育本身就是一种回报很难估算的投资（不像一件衣服好看不好看那么直接），而且还有大量的时间成本。再他们赢得一些用户口碑之后，一段时间不容易被其他产品影响，还会越滚越大。另外一些朋友开始在大公司里面摸爬滚打，也蛮不错的。因为毕竟是主流价值观。有一大推可以借鉴的经验和路子。还有一些朋友准备考GMAT。</p>

<p>我家是一个普通家庭，可能唯一特别一点的就是我有一个特别开明的妈妈，我妈妈认为她最大的遗憾就是当初她老师告诉她要学好电脑，而她没咋当回事。所以她一直很支持我玩电脑。有一天我有意无意的在她的书柜里面找到的一本有关Basic语言的编程书，然后自己写下了我的第一段程序，一个简单的计算器，那会我上小学6年级。我一直觉得我有一个很特别的妈妈，我妈妈是一个大网虫，我的QQ号都是她替我申请的，而且特别喜欢电子游戏。但是，我显然让她失望了。我并没有按照她给我计划好的路子走，而是按照自己的性子来的。走了一条很大的弯路，而且是不归路。我没有考上一个好大学，也没有找一个可以让她安心的工作。而且现在我也没有办法告诉她我什么时候可以结婚生孩子。</p>

<p>妈妈的身体差一点，爸爸的身体比较厉害，打了30多年的拳，虽然比我大30岁但是在我减肥之前我确定他身体比我好。他们2个年轻的时候做过几次正确的投资，现在衣食无忧，自己没事弄点小买卖充实一下无聊的日子，按照我妈的话，这辈子剩下的事情就是等我结婚报孙子。</p>

<p>但是很明显，作为一个26岁，要啥没啥，连个稳定收入都没有的闲杂人等，到哪里给她找儿媳妇去？</p>

<h1>2014</h1>

<p>2014年我有2个比较大的计划需要尝试。抽象来说，就是给自己找一个大的平台。在这几年来，我深刻的认识到了自己的见识、理解还是能力都远远不够。不得不承认我可能错过了我人生中的第一次机会。我需要的是一个大的平台，让我从中学习理解这个行业。一个是出国，一个是去一家大公司，而且在一个不错的部门里面。我还没有找到这个大平台，但是我能确定一点的是，这个平台是符合主流价值观的。因为我这几年来偏离太多，虽然我自己收获不小，但是我希望能够走一些别人走过的路。最近的1个月来，自己一直在忙这2件事情，估计最晚需要忙到明年6月份。那句老话说得好，人无远虑，必有近忧。我现在还没有办法估计5年后的事情，因为我5年前每一年做的事情，都没有重复的，而且都是某种程度上面不一样的。我唯一能确定的就是2014年，也是一个完全不一样的一年。而且是我人生中最重要的一年。如果我找到一个平台，那么意味着我2013年成为一个美丽的间隔年，而如果没有，那么就是又一个非常大的教训。</p>

<h1>困惑 2015-2018</h1>

<p>上面的是我在一个月前写的，这几天我一直再思考一个问题，今天又失眠了。我未来的5年应该是什么打算呢？一直想不清楚，所以也不知道该如何写下去。其中有一个很重要的事情，就是成家是否在我的计划之中，同时它还附带了户口，房子，小孩上学等一系列问题。太原眼下，甚至是3年都很难有适合我的工作，但是生活还是未来小孩上学太原都要比北京的条件要好不少。花大量的时间和金钱拿一个北京的户口和房子值么？还是在太原的投资回报率高？抛开工作，太原的生活显然比北京舒适。但问问自己，甘心么？这一切都好难说。而且很多事情还涉及到父母，不是我一个人说了算，头疼。希望2014年底，我可以有一个自己的答案。恩，是希望，不是必须完成的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百度面试]]></title>
    <link href="http://studentdeng.github.com/blog/2014/02/11/baidu-interview/"/>
    <updated>2014-02-11T00:10:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/02/11/baidu-interview</id>
    <content type="html"><![CDATA[<p>百度移动云可穿戴部门的面试经历，面试官都非常热情友好，一上来到弄的我挺不好意思的。下面记录一下自己的面试过程，因为我真的没啥面试经验，需要总结下。</p>

<h1>1面</h1>

<ul>
<li>Objective C runtime library：Objective C的对象模型，block的底层实现结构，消息发送，消息转发，这些都需要背后C一层的描述，内存管理。</li>
<li>Core Data：中多线程中处理大量数据同步时的操作。</li>
<li>Multithreading：什么时候处理多线程，几种方式，优缺点。</li>
<li>Delegate， Notification，KVO， other 优缺点</li>
</ul>


<p>runtime有一点追问，category，method 的实现机制，class的载入过程。
1面整体感觉不错，40分钟不到，感觉回答的还可以。被通知一会儿二面。</p>

<h1>2面</h1>

<p>二面的时间非常长，差不多将近3个小时，直接面到快下班了。1面问的主要是知识点。2面问主要考察的是设计解决方案的能力，另外辅助追问的方式，考察深度和广度，回答过程中需要列出适合的具体例子，方案还需要细致到具体的关键的函数名称，方法。另外考察设计模式的理解，最后还考了算法。因为时间太长，这里记录一些重要的问题。</p>

<ol>
<li>设计一个progress bar解决方案，追问到 Core Graphic、CGPath、maskLayer。</li>
<li>设计一个popup view被追问到 keyWindow、UIWindow的layer、UIView hierarchy。</li>
<li>从设计模式的角度分析Delegate、Notification、KVO的区别。被追问到自己写的library和开源的项目中用到哪些设计模式，为什么使用，有哪些好处和坏处，现在能否改进。</li>
<li>算是问题3的追问，设计一个方案来检测KVO的同步异步问题。willChange和 didChange的不同点，然后被追问到有没有其他地方也有类似情况，被追问到Core Data 中falut object。</li>
<li>这个是问题4的追问，设计一个KVO系统。</li>
<li>Multithreading，什么时候采用Multithreading方案，以及理由。追问到系统还有哪些在后台运行的thread，被追问到view life cycle、iOS6之后的不同以及内存管理。</li>
<li>Multithreading中常常遇到的问题，追问到死锁，优先级翻转，线程池等。</li>
<li>百度有一个亿级别的APP需要统计用户行为的日志系统。不使用数据库，只是使用普通文件，设计一个系统。被追问到内存映射文件。这个问题本来是服务器的问题，我表示从来没做过，回答很瞎。</li>
</ol>


<p>算法考了2个。一个是如何求2个集合的交集。另一个是百亿数据中查找相同的数字以及出现的次数。</p>

<p>最后还补充了几个小问题</p>

<ul>
<li>自己对可穿戴设备的感受</li>
<li>自己如果进入这个team，自己准备做那方面的事情</li>
<li>为什么创业，自己未来规划</li>
</ul>


<p>一会被告知3面，但是因为太晚，约到次日下午3面。</p>

<h1>3面</h1>

<p>3面的时间和1面差不多40分钟，问了几个问题，主要是考察精神层面的东西。</p>

<ul>
<li>为什么做Windows Mobile</li>
<li>为什么改iOS</li>
<li>为什么来百度</li>
<li>为什么iPhone 可以成功，那些吸引你</li>
<li>如何看待AppStore 现在的生态圈</li>
</ul>


<p>后面就是他说的多一些，介绍团队遇到的困难以及14年团队的打算。最后他给了我2句话的评价，我觉得还是蛮对的。</p>

<ul>
<li>选择的时候都是经过深思熟虑的</li>
<li>有野心，wanna make a difference</li>
</ul>


<p>有意思的是，他说他也wanna make a difference。</p>

<h1>总结</h1>

<p>整体还是挺尴尬的，几乎所有的知识点都是1，2年前积累的，13年积累的东西基本上没有，都是一些虚的东西。
2面挺好的，暴露了自己不少问题，设计模式那部分几乎没有概念了。</p>

<h1>最后</h1>

<p>面试通过，我个人觉得2面我的问题在思考设计模式上面少，另外在window hierarchy 上面有不足。设计 KVO 上面在 didChange上面考虑不足。这些都是被当场戳穿的。
有一点疑虑的是整个面试中并没有问到Core Animation。这个还是我蛮喜欢的部分。Anyway 个人很喜欢追问的方式，很容易考察出来理解的深度和广度。</p>

<p>整个面试收获很大，发现了很多不足。另外1，2面的面试题目个人觉得也不错。这里分享给大家。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译 并发编程：API 和 挑战]]></title>
    <link href="http://studentdeng.github.com/blog/2014/01/15/concurrent-api/"/>
    <updated>2014-01-15T20:21:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/01/15/concurrent-api</id>
    <content type="html"><![CDATA[<p>并发（<a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29">Concurrency</a>）描述了一个同时运行多个任务的概念。他可以在单核设备上通过分时的方式实现，或者如果多个CPU则会真正的并行。</p>

<p>OSX和iOS提供了多种不同的API来实现并发编程。每一个API都有不同的功能和局限，适用于不同的任务。他们有不同的抽象层次。我们可以操作底层API，但是这也意味着我们需要做很多事情来保证正确。</p>

<p>并发编程是非常困难的，里面有很多陷阱。而且很容易被忘记，特别是我们使用API，比如 GCD 或者 NSOperationQueue。这篇文章来会总体介绍在iOS和OSX上面的不同的并发API，然后深入一点并发编程里面的固有的，每个API所独有的挑战。</p>

<h1>OSX和iOS上面的并发API</h1>

<p>Apple为移动和桌面操作系统提供了相同的并发编程API。这里我们会看一下pthread和NSThread。Grand Central Dispatch, NSOperationQueue 和 NSRunLoop。技术上来说，run loops 有一点奇怪。因为他们并不是真正的并发。但是他和这篇文章的主旨很接近，所以还是值得深入了解的。</p>

<p>我们从底层API开始，然后到上层API。我们这样做，因为上层的API是通过底层的API实现的。当然，在实际中，我们需要反过来考虑：用最上面的一层抽象搞定事情会简单很多。</p>

<p>你可能想知道为什么我们这个坚持推荐使用高抽象层会让并发编程代码简单。你可以阅读这篇文章的第二部分。也可以看 Peter Steinberger 的 <a href="http://www.objc.io/issue-2/thread-safe-class-design.html">线程安全</a>文章。</p>

<h1>线程</h1>

<p><a href="http://en.wikipedia.org/wiki/Thread_%28computing%29">线程</a>是进程的子单元，被操作系统独立调度执行。事实上，所有的并发API都基于线程。背后实际上的确是真的，不管是GCD还是operation queues。</p>

<p>多线程可以在同一个时间执行，即时在单核的CPU上。（或是至少看上去是在同时）。操作系统赋予每个线程一个时间片，用户看上去多个任务就像是在同时执行一样。如果CPU是多核的，那么多个线程就可以真正的并发执行，因此总的执行时间就会减少。</p>

<p>你可以使用<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html">CPU strategy view</a>Instruments中的几个工具来深入了解一下你的代码或者是framework代码在多核下是如何调用和执行的。</p>

<p>这里面有一个非常重要的需要记住的是你对什么时候执行代码，执行那段代码无能为力，执行多长时间，什么时候会被暂停去执行别的任务，也是不知道的。这个线程调度的技术非常强大。然而，也带来了非常大的复杂性，后面会提到。</p>

<p>让我们把这个复杂的情况暂时放在一边。你可以使用pthread API，或是其他的Objective-C封装的代码，NSThread去创建自己的线程。这里有一个简单的代码，查找100W和数中的最小和最大的数。使用了4个线程并发执行。这就是一个非常好的例子，告你你最好不要直接使用pThread。</p>

<pre><code>struct threadInfo {
    uint32_t * inputValues;
    size_t count;
};

struct threadResult {
    uint32_t min;
    uint32_t max;
};

void * findMinAndMax(void *arg)
{
    struct threadInfo const * const info = (struct threadInfo *) arg;
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; info-&gt;count; ++i) {
        uint32_t v = info-&gt;inputValues[i];
        min = MIN(min, v);
        max = MAX(max, v);
    }
    free(arg);
    struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));
    result-&gt;min = min;
    result-&gt;max = max;
    return result;
}

int main(int argc, const char * argv[])
{
    size_t const count = 1000000;
    uint32_t inputValues[count];

    // Fill input values with random numbers:
    for (size_t i = 0; i &lt; count; ++i) {
        inputValues[i] = arc4random();
    }

    // Spawn 4 threads to find the minimum and maximum:
    size_t const threadCount = 4;
    pthread_t tid[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {
        struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));
        size_t offset = (count / threadCount) * i;
        info-&gt;inputValues = inputValues + offset;
        info-&gt;count = MIN(count - offset, count / threadCount);
        int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);
        NSCAssert(err == 0, @"pthread_create() failed: %d", err);
    }
    // Wait for the threads to exit:
    struct threadResult * results[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {
        int err = pthread_join(tid[i], (void **) &amp;(results[i]));
        NSCAssert(err == 0, @"pthread_join() failed: %d", err);
    }
    // Find the min and max:
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; threadCount; ++i) {
        min = MIN(min, results[i]-&gt;min);
        max = MAX(max, results[i]-&gt;max);
        free(results[i]);
        results[i] = NULL;
    }

    NSLog(@"min = %u", min);
    NSLog(@"max = %u", max);
    return 0;
}
</code></pre>

<p>NSThread是</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013年度总结]]></title>
    <link href="http://studentdeng.github.com/blog/2013/12/14/25years/"/>
    <updated>2013-12-14T22:24:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/12/14/25years</id>
    <content type="html"><![CDATA[<h1>过去的一年</h1>

<p>人生的第25个年头就要过去了，现在是14号，离25岁的终点还有一个星期。这个意味着我马上就要26岁了。25岁的人生马上就要结束了。为什么这么害怕25岁。25岁到底意味着什么？身体开始衰老而且入行3年。身体衰老意味着如果希望有一个好身材，那么需要付出比之前大的多的时间和毅力，甚至保持都是一件越来越难的事情。入行3年意味着你完成1W小时体验，科学上意味着你应该是一个专家且小有成就了。你已经不是一个小孩子，那种看一篇文章，听一个演讲就马上行动起来的年轻人。你需要能够制定适合自己的计划，而且稳定靠谱的执行下去，没有为什么，因为这个就是这个时候应该做到的。你的试错的成本会变得越来越高，而且你不得不面对一些自己在年轻的时候不愿意面对的问题。那么看看这1年来我做的事情吧。</p>

<p>我养成了2个好习惯，一个健身一个学英语。而且这2个方面都有了不少的进步，之前已经写得太多，这里不多说了。旅行过一次，一次接力马拉松，另外看了52本书。下面是具体的统计</p>

<p><img src="http://studentdeng.github.io/images/25-1.png" alt="image" /></p>

<p><img src="http://studentdeng.github.io/images/25-2.png" alt="image" /></p>

<p>其中小说最多16篇，心理学6本，计算机5本。20篇读书笔记，5个书评。</p>

<p>翻翻去年给自己定得目标，除了雅思没有搞定以外，其他的还算过去了。</p>

<h1>我是谁</h1>

<p>现在的社交工具越来越多，会有越来越多人的生活不经意之间闯进我们的生活里。你需要学会辨别他们。就拿一个跑马拉松来说，有人会说敢于参加就好了。但是实际上你不会知道她背后做了什么，各种准备，训练，以及比赛当天的赛程详细计划，多少米需要做什么，以及自己的目标，多少是基本目标，多少是超额的。我这么说并不说一些人会刻意隐瞒什么，而是这些一切的小事情上面所积累的习惯，造就了一个人的做事态度，价值观。</p>

<p>1年前的这会，我写下了这样的一段话。</p>

<p>“I would not be able to find the most difficult task in my life that is changing myself. 我将失去,或是更晚的意识到, 这个人生中最困难的任务,就是改变自己, 因为有太多的人, 别说改变自己, 面对自己都做不到, 因为自己可以骗得了任何人,但唯独骗不了自己。”</p>

<p>今天和一个朋友聊天，也正好聊到了这个。人们最大的敌人是自己，真的真的只有极少数的人可以做到面对自己，可以自己揭开自己心中的伤疤。今天我清晰的感觉到了我心脏的跳动，那种砰砰砰跳动的感觉，我很害怕。非常害怕，害怕到想哭却哭不出来。因为很简单，这一年来不管我做过哪些改变以及努力，其实可以用8个字概况“看似忙碌，实则焦虑”——纤细的胳膊，蹩脚的英语，以及居无定所没有稳定收入来源的生活。</p>

<p>不管是工作上面的总结，还是人际交往的总结，还是我做的一切一切的东西的源动力在于我过的生活和我想的不一样。胸围长5cm腰围小12cm绝对不会是“我希望我的身体强壮一点”一句话搞定的，同样那个钢筋铁骨的30多岁大姐姐也不是一句“我希望更漂亮健康”搞定的，有谁会理解从一个相夫教子的全职太太到孤身一人的心理落差呢？</p>

<p>这就是现实的生活，生活中永远不缺努力的人，也不缺焦虑。虽然我现在要比1年前做得要好很多。我不会去抱怨。学会把用来抱怨的时间去做事情。人总会慢慢的发现自己似乎强壮起来了，就像温水煮青蛙，看上去不错，但实际上根本没有变化，我只是学得更会掩饰自己的内心，更会假装而已。</p>

<p>越忙碌，学得越多，做的越多，只是在给自己掩饰自己的焦虑,暗示自己过的还好，但其实一点也不好。不得不承认自己处在一个下降的电梯，这就是我心中的“坑”。</p>

<p>当然也有好消息。好消息就是不是我才有焦虑，这个几乎只要是一个有想法的年轻人都有的（好阴暗的感觉&#8230;）</p>

<h1>要到那里去</h1>

<p>当我们回头看自己走过来的路时，看到的似乎只是依稀莫辩的“或许”。我们所能明确认知的仅仅是现在这一瞬间，而这也只是与我们擦肩而过。看看自己，除了青春，什么都没有。青春就是时间，时间不像钱，可以存，可以攒，时间只能用于消费或是投资。不得不承认，过去的日子里面，我浪费了太多的时间，有太多的遗憾，小时候有太多的不懂事，让自己现在变成这个样子，但是我不后悔。我认定的事情我都全力去做，有部分做到了，有部分延期做到了，也有一部分最后失败了。</p>

<p>2014年，把2013年的一些遗憾弥补上之后，给自己一个新的平台。到了找一个新电梯的时候了。多年以前做的决定，现在也是搏一把的时候了。</p>

<h1>后记</h1>

<p>这篇是在14号写的，实际上，在14号之前我已经想了1个多月了。如果一件事情还有遗憾，那么就还没有到放弃的时候。我从来没有这么长时间的思考过自己，也第一次帮别人思考自己。回头看自己思路的时候，发现还是有很多坑和不足，但我也看到了我在慢慢的变好。即将的26岁这一年，真的将是我非常重要的一年。鸡血又开始打上了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译 《Getting Pixels onto the Screen》]]></title>
    <link href="http://studentdeng.github.com/blog/2013/12/09/getting-pixels-onto-the-screen/"/>
    <updated>2013-12-09T15:55:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/12/09/getting-pixels-onto-the-screen</id>
    <content type="html"><![CDATA[<p>这篇提交到<a href="http://blog.jobbole.com/?p=54511">伯乐在线</a></p>

<p><a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html#pixels">原文</a></p>

<h1>绘制像素到屏幕</h1>

<p>像素是如何绘制到屏幕上面的？有非常多的方式输出数据到屏幕，通过调用很多不同的framework和不同的函数。这里我们讲一下这个过程背后的东西。希望能够帮助大家了解什么时候该使用什么API，特别是当遇到性能问题需要调试的时候。当然，我们这里主要讲iOS，但是事实上，很多东西也是可以应用到OSX上面的。</p>

<h2>Graphics Stack</h2>

<p>绘制屏幕的过程中又很多都是不被人了解的。但是一旦像素被绘制到屏幕上面，那么像素就是有3种颜色组成：红绿蓝。这3个颜色单元通过特定的强弱组合形成一个特定的颜色。对于iPhone5 <a href="https://en.wikipedia.org/wiki/IPS_LCD">IPS_LCD</a> 的分辨率是1,136×640 = 727,040个像素，也就是有2,181,120个颜色单元。对于一个15寸高清屏幕的MacBook Pro来说，这个数字差不多是1500万。Graphics Stack 就是确保每一个单元的强弱都正确。当滑动整个屏幕的时候，上百万的颜色单元需要在每秒60次的更新。</p>

<h2>The Software Components</h2>

<p>下面是一个简单的例子，整个软件看起来是这个样子</p>

<p><img src="http://www.objc.io/images/issue-3/pixels-software-stack@2x.png" alt="image" /></p>

<p>显示器上面的就是GPU，图像处理单元。GPU是一个高度并发计算的硬件单元，特别是处理图形图像的并行计算。这就是为什么可以这么快的更新像素并输出到屏幕的原因。并行计算的设计让GPU可以高效的混合图像纹理。我们会在后面详细解释混合图像纹理这个过程。现在需要知道的就是GPU是被高度优化设计的，因此非常适合计算图像这种类型的工作。他比CPU计算的更快，更节约能耗。因为CPU是为了更一般的计算设计的硬件。CPU虽然可以做很多事情，但是在图像这方面还是远远慢于GPU。</p>

<p>GPU驱动是一些直接操作GPU的代码，由于各个GPU是不同的，驱动在他们之上创建一个层，这个层通常是OpenGL/OpenGL ES。</p>

<p>OpenGL（<a href="http://en.wikipedia.org/wiki/OpenGL">Open Graphics Library)</a>）是用来做2D和3G图形图像渲染的API。由于GPU是一个非常定制化的硬件，OpenGL和GPU紧密合作充分发挥GPU的能力来实现图形图像渲染硬件加速。对大多数情况，OpenGL太底层了。但是当1992年第一个版本发布后（20多年前），它就成为主流的操作GPU的方式，并且前进了一大步。因为程序员再也不用为了每一个GPU编写不同的应用程序。</p>

<p>在OpenGL上面，分开了几个。iOS设备几乎所有的东西变成了Core Animation，但是在OSX，绕过Core Animation而使用Core Graphic 并不是不常见。有一些特别的应用程序，特别是游戏，可能直接使用OpenGL/OpenGL ES. 然后事情变得让人疑惑起来，因为有些渲染Core Animation 使用 Core Graphic。类似AVFoundation， Core Image 这样的框架，或是其他的一些混合的方式。</p>

<p>这里提醒一件事情， GPU是一个强有力的图形图像硬件，在显示像素方面起着核心作用。它也连接着CPU。从硬件方面讲就是有一些总线把他们连接了起来。也有一些框架比如 OpenGL， Core Animation。Core Graphic控制GPU和CPU之间的数据传输。为了让像素能够显示到屏幕上面，有一些工作是需要CPU的。然后数据会被传给GPU，然后数据再被处理，最后显示到屏幕上面。</p>

<p>每一个过程中都有自己的挑战，在这个过程中也存在很多权衡。</p>

<h1>硬件层</h1>

<p><img src="http://www.objc.io/images/issue-3/pixels%2C%20hardware%402x.png" alt="image" /></p>

<p>这是一个很简单的图表用来描述一个挑战。GPU有纹理（位图）合成为一帧（比如1秒60帧）每一个纹理占用VRAM（显卡）因此GPU一次处理的纹理有大小限制。GPU处理合成方面非常高效，但是有一些合成任务比其他要复杂，所以GPU对处理能力有一个不能超过16.7ms的限制（1秒60帧）。</p>

<p>另一个挑战是把数据传给GPU。为了让GPU能够访问数据，我们需要把数据从内存复制到显存。这个过程叫做上传到GPU。这个可能看上去不重要，但是对于一个大的纹理来说，会非常耗时。</p>

<p>最后CPU运行程序。你可能告诉CPU从资源文件夹中加载一个PNG图片，并解压。这些过程都发生在CPU。当需要显示这些解压的图片时，就需要上传数据到GPU。一些事情看似非常简单，比如显示一段文字，对CPU来说是一个非常复杂的任务。需要调用Core Text 和 Core Graphic框架去根据文字生成一个位图。完成后，以纹理的方式上传到GPU，然后准备显示。当你滑动或是移动一段屏幕上面的文字时，同样的纹理会被重用，CPU会简单的告诉GPU只是需要一个新的位置，所以GPU可以重新利用现有的纹理。CPU不需要重新绘制文字，位图也不需要重新上传到GPU。</p>

<p>上面的有一点复杂，在有一个整体概念之后，我们会开始解释里面的技术细节。</p>

<h1>图像合成</h1>

<p>图像合成的字面意思就是把不同的位图放到一起创建成最后的图像然后显示到屏幕上面。在很多方面来看，这个过程都是显而易见的，所以很容易忽视其中的复杂性和运算量。</p>

<p>让我们忽视一些特殊情况，假设屏幕上面都是纹理。纹理就是一个RGBA值的矩形区域。每一个像素包括红，绿，蓝，透明度。在Core Animation世界里面，基本上相当于CALayer。</p>

<p>在这个简单的假设中，每一个层是一个纹理，所有的纹理通过栈的方式排列起来。屏幕上的每一个像素，CPU都需要明白应该如何混合这些纹理，从而得到相对应的RGB值。这就是合成的过程。</p>

<p>如果我们只有一个纹理，而且这个纹理和屏幕大小一致。每一个像素就和纹理中得一个像素对应起来。也就是说这个纹理的像素就是最后屏幕显示的样子。</p>

<p>如果我们有另一个纹理，这个纹理覆盖在之前的纹理上面。GPU需要首先把第二个纹理和第一个纹理合成。这里面有不同的覆盖模式，但是如果我们假设所有的纹理都是像素对齐且我们使用普通的覆盖模式。那么最后的颜色就是通过下面的公式计算出来的。</p>

<pre><code>R = S + D * (1 - Sa)
</code></pre>

<p>最后的结果是通过源的颜色（最上面的纹理）加目标颜色（下面的纹理） 乘以（1 - 源颜色的透明度）公式里面所有的颜色就假定已经预先乘以了他们的透明度。</p>

<p>很显然，这里面很麻烦。让我们再假设所有的颜色都是不透明的，也就是alpha = 1. 如果目标纹理（下面的纹理）是蓝色的（RGB = 0，0，1）源纹理（上面的纹理）是红色（RGB = 1，0，0）。因为Sa = 1， 那么这个公式就简化为</p>

<pre><code>R = S
</code></pre>

<p>结果就是源的红色，这个和你预期一致。</p>

<p>如果源（上面的）层50%透明，比如 alpha = 0，5. 那么 S 的RGB值需要乘以alpha会变成 （0.5,0,0）。这个公式会变成这个样子</p>

<pre><code>                   0.5   0               0.5
</code></pre>

<p>R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</p>

<pre><code>                   0     1               0.5
</code></pre>

<p>我们最后得到的RGB颜色是紫色(0.5, 0, 0.5) 。这个和我们的直觉预期一致。透明和红色和蓝色背景混合后成为紫色。</p>

<p>要记住，这个只是把一个纹理中的一个像素和另一个纹理中的一个像素合成起来。GPU需要把2个纹理之间覆盖的部分中的像素都合成起来。大家都知道，大多数的app都有多层，因此很多纹理需要被合成起来。这个对GPU的开销很大，即便GPU已经是被高度硬件优化的设备。</p>

<h1>不透明 VS 透明</h1>

<p>当源纹理是完全不透明，最终的颜色和源纹理一样。这就可以节省GPU的很多工作，因为GPU可以简单的复制源纹理而不用合成所有像素值。但是GPU没有办法区别纹理中的像素是不透明的还是透明。只有程序员才能知道CALayer里面的到底是什么。这也就是CAlayer有opaque属性的原因。如果opaque = YES, 那么GPU将不会做任何合成计算，而是直接直接简单的复制颜色，不管下面还有什么东西。GPU可以减少大量的工作。这就是Instruments（Xcode 的性能测试工具）中 <strong>color blended layers</strong> 选项做的事情。（这个选项也在模拟器菜单里面）。它可以让你了解哪一个层（纹理）被标记成透明，也就是说，GPU需要做合成工作。合成不透明层要比透明的层工作量少很多，因为没有那么多的数学运算在里面。</p>

<p>如果你知道哪一个层是不透明的，那么一定确保opaque = YES。如果你载入一个没有alpha通道的image，而且在UIImageView显示，那么UIImageView会自动帮你设置opaque = YES。但是需要注意一个没有alpha通道的图片和每个地方的alpha都是100%的图片区别很大。后面的情况，Core Animation 需要假定所有像素的alpha都不是100%。在Finder中，你可以使用Get Info并且检查More Info部分。它将告诉你这张图片是否拥有alpha通道。</p>

<h1>像素对齐和不对齐</h1>

<p>到目前为止，我们考虑的层都是完美的像素对齐的。当所有的像素都对齐时，我们有一个相对简单的公式。当GPU判断屏幕上面的一个像素应该是什么时，只需要看一下覆盖在屏幕上面的所有层中的单个像素，然后把这些像素合成起来，或者如果最上面的纹理是不透明的，GPU只需要简单的复制最上面的像素就好了。</p>

<p>当一个层上面的所有像素和屏幕上面的像素完美对应，我们就说这个层是像素对齐的。主要有2个原因导致可能不对齐。第一个是放大缩小；当放大或是缩小是，纹理的像素和屏幕像素不对齐。另一个原因是当纹理的起点不在一个像素边界上。</p>

<p>这2种情况，GPU不得不做额外的计算。这个需要从源纹理中混合很多像素来创建一个像素用来合成。当所有像素对齐时，GPU就可以少做很多工作。</p>

<p>注意，Core Animation Instrument和模拟器都有color misaligned images 选项，当CALayer中存在像素不对齐的时候，把问题显示出来。</p>

<h1>遮罩（mask）</h1>

<p>一个层可以有一个和它相关联的遮罩。遮罩是一个有alpha值的位图，而且在合成像素之前需要被应用到层的contents属性上。当你这顶一个层为圆角时，一就在设置一个遮罩在这个层上面。然而，我们也可以指定一个任意的遮罩。比如我们有一个形状像字母A的遮罩。只有CALayer的contents中的和字母A重合的一部分被会被绘制到屏幕。</p>

<h1>离屏渲染（Offscreen rendering）</h1>

<p>离屏渲染可以被Core Animation 自动触发或是应用程序手动触发。离屏渲染绘制layer tree中的一部分到一个新的缓存里面（这个缓存不是屏幕，是另一个地方），然后再把这个缓存渲染到屏幕上面。</p>

<p>你可能希望强制离屏渲染，特别是计算很复杂的时候。这是一种缓存合成好的纹理或是层的方式。如果你的呈现树（render tree）是复杂的。那么就希望强制离屏渲染到缓存这些层，然后再使用缓存合成到屏幕。</p>

<p>如果你的APP有很多层，而且希望增加动画。GPU一般来说不得不重新合成所有的层在1秒60帧的速度下。当使用离屏渲染时，GPU需要合成这些层到一个新的位图纹理缓存里面，然后再用这个纹理绘制到屏幕上面。当这些层一起移动时，GPU可以重复利用这个位图缓存，这样就可以提高效率。当然，如果这些层没有修改的化，才能有效。如果这些层被修改了，GPU就不得不重新创建这个位图缓存。你可以触发这个行为，通过设置shouldRasterize = YES</p>

<p>这是一个权衡，如果只是绘制一次，那么这样做反而会更慢。创建一个额外的缓存对GPU来说是一个额外的工作，特别是如果这个位图永远没有被复用。这个实在是太浪费了。然而，如果这个位图缓存可以被重用，GPU也可能把缓存删掉了。所以你需要计算GPU的利用率和帧的速率来判断这个位图是否有用</p>

<p>离屏渲染也可以在一些其他场景发生。如果你直接或是间接的给一个层增加了遮罩。Core Animation 会为了实现遮罩强制做离屏渲染。这个增加了GPU的负担，因为一般上来，这些都是直接在屏幕上面渲染的。</p>

<p>Instrument的Core Animation 有一个叫做Color Offscreen-Rendered Yellow的选项。它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时确保勾选Color Hits Green and Misses Red选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>

<p>一般来说，你需要避免离屏渲染。因为这个开销很大。在屏幕上面直接合成层要比先创建一个离屏缓存然后在缓存上面绘制，最后再绘制缓存到屏幕上面快很多。这里面有2个上下文环境的切换（切换到屏幕外缓存环境，和屏幕环境）。</p>

<p>所以当你打开Color Offscreen-Rendered Yellow后看到黄色，这便是一个警告，但这不一定是不好的。如果Core Animation能够复用屏幕外渲染的结果，这便能够提升性能，当绘制到缓存上面的层没有被修改的时候，就可以被复用了。</p>

<p>注意，缓存位图的尺寸大小是有限制的。Apple 提示大约是2倍屏幕的大小。</p>

<p>如果你使用的层引发了离屏渲染，那么你最好避免这种方式。增加遮罩，设置圆角，设置阴影都造成离屏渲染。</p>

<p>对于遮罩来说，圆角只是一个特殊的遮罩。clipsToBounds 和 masksToBounds 2个属性而已。你可以简单的创建一个已经设置好遮罩的层创建内容。比如，使用已经设置了遮罩的图片。当然，这个也是一种权衡。如果你希望在层的contents属性这只一个矩形的遮罩，那你更应该使用contentsRect而不是使用遮罩。</p>

<p>如果你最后这是shouldRasterize = YES，记住还要设置rasterizationScale = contentsScale</p>

<h1>更多的关于合成</h1>

<p>通常，维基百科上面有许多关于图像合成的<a href="https://en.wikipedia.org/wiki/Alpha_compositing">背景知识</a>。我们这里简单的拓展一下像素中的红、绿、蓝以及alpha是如何呈现在内存中的。</p>

<h1>OSX</h1>

<p>如果你在OSX上面工作，你会发现大部分的这些调试选项在一个独立的叫做“Quartz Debug”的程序里面。而并不在 Instruments 中。Quartz Debug是Graphics Tools中的一部分，这可以在苹果的developer portal中下载到</p>

<h1>Core Animation &amp; OpenGL ES</h1>

<p>就像名字所建议的那样，Core Animation 让我们可以创建屏幕动画。我们将跳过大部分的动画，关注于绘制部分。重要的是，Core Animation允许你坐高效的渲染。这就是为什么你可以通过Core Animation 实现每秒60帧的动画。</p>

<p>Core Animation 的核心就是基于OpenGL ES的抽象。简单说，它让你使用OpenGL ES的强大能力而不需要知道OpenGL ES的复杂性。当我讨论像素合成的时候，我们提到的层（layer）和 纹理（texture）是等价的。他们准确来说不是一个东西，但是缺非常类似。</p>

<p>Core Animation的层可以有多个子层。所以最后形成了一个layer tree。Core Animation做的最复杂的事情就是判断出那些层需要被绘制或重新绘制，那些层需要OpenGL ES 去合成到屏幕上面。</p>

<p>例如，当你这是一个layer的contents属性是一个CGImageRef时，Core Animation创建一个OpenGL 纹理，然后确保这个图片中的位图上传到指定的纹理中。或者，你重写了-drawInContext方法，Core Animation 会分配一个纹理，确保你的Core Graphics的调用将会被作用到这个纹理中。层的
性质和CALayer的子类会影响OpenGL渲染方式的效率。很多底层的OpenGL ES行为被简单的封装到容易理解的CALayer的概念中去。</p>

<p>Core Animation通过Core Graphics和OpenGL ES，精心策划基于CPU的位图绘制。因为Core Animation在渲染过程中处于非常重要的地位，所以如何使用Core Animation，将会对性能产生极大影响。</p>

<h1>CPU限制 vs GPU限制（CPU bound vs. GPU bound）</h1>

<p>当在屏幕上面显示的时候，有很多组件都参与其中。这里面有2个主要的硬件分别是CPU和GPU。P和U的意思就是处理单元。当东西被显示到屏幕上面是，CPU和GPU都需要处理计算。他们也都受到限制。</p>

<p>为了能够达到每秒60帧的效果，你需要确保CPU和GPU都不能过载。也就是说，即使你当前能达到60fps,你还是要尽可能多的绘制工作交给GPU做。CPU需要做其他的应用程序代码，而不是渲染。通常，GPU的渲染性能要比CPU高效很多，同时对系统的负载和消耗也更低一些。</p>

<p>因为绘制的性能是基于GPU和CPU的。你需要去分辨哪一个是你绘制的瓶颈。如果你用尽的GPU的资源，GPU是性能的瓶颈，也就是绘制是GPU的瓶颈，反之就是CPU的瓶颈。</p>

<p>如果你是GPU的瓶颈，你需要为GPU减负（比如把一些工作交给CPU），反之亦然。</p>

<p>如果是GPU瓶颈，可以使用OpenGL ES Driver instrument，然后点击 i 按钮。配置一下，同时注意查看Device Utilization % 是否被选中。然后运行app。你会看到GPU的负荷。如果这个数字接近100%，那么你交给GPU的工作太多了。</p>

<p>CPU瓶颈是更加通常的问题。可以通过Time Profiler instrument，找到问题所在。</p>

<h1>Core Graphics / Quartz 2D</h1>

<p>通过Core Graphics这个框架名字，Quartz 2D更被人所知。</p>

<p>Quartz 2D 有很多小功能，我们不会在这里提及。我们不会讲有关PDF创建，绘制，解析或打印。只需要了解答应PDF和创建PDF和在屏幕上面绘制位图原理几乎一致，因为他们都是基于Quartz 2D。</p>

<p>让我们简单了解一下Quartz 2D的概念。更多细节可以参考Apple的 <a href="https://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html">官方文档</a></p>

<p>Quartz 2D是一个处理2D绘制的非常强大的工具。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立等很多特性。因为是更为底层的基于C的API，所以看上去会有一点让人恐惧。</p>

<p>主要概念是非常简单的。UIKit和AppKit都封装了Quartz 2D的一些简单API，一旦你熟练了，一些简单C的API也是很容易理解的。最后你可以做一个引擎，它的功能和Photoshop一样。Apple提到的一个 <a href="https://developer.apple.com/videos/wwdc/2011/?id=129">app</a>，就是一个很好的Quartz 2D例子。</p>

<p>当你的程序进行位图绘制时，不管使用哪种方式，都是基于Quartz 2D的。也就是说，CPU通过Quartz 2D绘制。尽管Quartz可以做其他事情，但是我们这里还是集中于位图绘制，比如在缓存(一块内存)绘制位图会包括RGBA数据。</p>

<p>比方说，我们要画一个八角形，我们通过UIKit能做到这一点</p>

<pre><code>UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
[path addLineToPoint:CGPointMake(0.4, 18.05)];
[path addLineToPoint:CGPointMake(18.8, -0.47)];
[path addLineToPoint:CGPointMake(37.21, 18.05)];
[path addLineToPoint:CGPointMake(34.31, 20.83)];
[path addLineToPoint:CGPointMake(20.88, 7.22)];
[path addLineToPoint:CGPointMake(20.88, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 7.22)];
[path closePath];
path.lineWidth = 1;
[[UIColor redColor] setStroke];
[path stroke];
</code></pre>

<p>Core Graphics 的代码差不多</p>

<pre><code>CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
CGContextAddLineToPoint(ctx, 0.4, 18.05);
CGContextAddLineToPoint(ctx, 18.8, -0.47);
CGContextAddLineToPoint(ctx, 37.21, 18.05);
CGContextAddLineToPoint(ctx, 34.31, 20.83);
CGContextAddLineToPoint(ctx, 20.88, 7.22);
CGContextAddLineToPoint(ctx, 20.88, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 7.22);
CGContextClosePath(ctx);
CGContextSetLineWidth(ctx, 1);
CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
CGContextStrokePath(ctx);
</code></pre>

<p>问题就是，绘制到哪里呢？ 这就是CGContext做的事情。我们传递的ctx这个参数。这个context定义了我们绘制的地方。如果我们实现了CALayer的-drawInContext:方法。我们传递了一个参数context。在context上面绘制，最后会在layer的一个缓存里面。我们也可以创建我们自己的context，比如 CGBitmapContextCreate（）。这个函数返回一个context，然后我们可以传递这个context，然后在刚刚创建的这个context上面绘制。</p>

<p>这里我们发现，UIKit的代码并没有传递context。这是因为UIKit或AppKit的context是隐形的。UIKit和UIKit维护着一个context栈。这些UIKit的方法始终在最上面的context绘制。你可以使用UIGraphicsPushContext（）和 UIGraphicsPopContext（）来push和pop对应的context。</p>

<p>UIKit有一个简单的方式，通过 UIGraphicsBeginImageContextWithOptions（） 和 UIGraphicsEndImageContext()来创建一个位图context，和 CGBitmapContextCreate（）一样。混合UIKit和 Core Graphics调用很简单。</p>

<pre><code>UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2);
CGContextRef ctx = UIGraphicsGetCurrentContext();
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
...
CGContextStrokePath(ctx);
UIGraphicsEndImageContext();
</code></pre>

<p>或其他方式</p>

<pre><code>CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo);
CGContextScaleCTM(ctx, 0.5, 0.5);
UIGraphicsPushContext(ctx);
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
...
[path stroke];
UIGraphicsPopContext(ctx);
CGContextRelease(ctx);
</code></pre>

<p>通过 Core Graphics可以做很多有趣的事情。苹果的文档有很多例子，我们这里就不太细说他们了。但是Core Graphics有一个非常接近Adobe Illustrator和Adobe Photoshop如何工作的绘图模型，并且大多数工具的理念翻译成Core Graphics了。毕竟这就是NextStep一开始做的。</p>

<h1>CGLayer</h1>

<p>一件非常值得提起的事，便是CGLayer。它经常被忽视，并且它的名字有时会造成困惑。他不是Photoshop中的图层的意思，也不是Core Animation中的层的意思。</p>

<p>把CGLayer想象成一个子context。它共用父context的所有特性。你可以独立于父context，在它自己的缓存中绘制。并且因为它跟context紧密的联系在一起，CGLayer可以被高效的绘制到context中。</p>

<p>什么时候这将变得有用呢?如果你用Core Graphics来绘制一些相当复杂的，并且部分内容需要被重新绘制的，你只需将那部分内容绘制到CGLayer一次，然后便可绘制这个CGLayer到父context中。这是一个非常优雅的性能窍门。这和我们前面提到的离屏绘制概念有点类似。你需要做出权衡，是否需要为CGLayer的缓存申请额外的内存，确定这是否对你有所帮助。</p>

<h1>像素（Pixels）</h1>

<p>屏幕上面的像素是通过3个颜色组成的：红，绿，蓝。因此位图数据有时候也被成为RGB数据。你可能想知道这个数据在内存中是什么样子。但是实际上，有非常非常多的方式。</p>

<p>后面我们会提到压缩，这个和下面讲得完全不一样。现在我们看一下RGB位图数据。RGB位图数据的每一个值有3个组成部分，红，绿，蓝。更多的时候，我们有4个组成部分，红，绿，蓝，alpha。这里我们讲4个组成部分的情况。</p>

<h1>默认的像素布局</h1>

<p>iOS和OS X上面的最通常的文件格式是32 bits-per-pixel (bpp),8 bits-per-component (bpc)，alpha会被预先计算进去。在内存里面像这个样子</p>

<pre><code>  A   R   G   B   A   R   G   B   A   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这个格式经常被叫做ARGB。每一个像素使用4个字节，每一个颜色组件1个字节。每一个像素有一个alpha值在R，G，B前面。最后RGB分别预先乘以alpha。如果我们有一个橘黄的颜色。那么看上去就是 240，99，24. ARGB就是 255，240，99，24 如果我们有一个同样的颜色，但是alpha是0.33，那么最后的就是 ARGB就是 84，80，33，8</p>

<p>另一个常见的格式是32bpp，8bpc，alpha被跳过了。</p>

<pre><code>x   R   G   B   x   R   G   B   x   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这个也被称为xRGB。像素并没有alpha（也就是100%不透明），但是内存结构是相同的。你可能奇怪为什么这个格式很流行。因为如果我们把这个没用的字节从像素中去掉，我们可以节省25%的空间。实际上，这个格式更适合现代的CPU和图像算法。因为每一个独立的像素和32字节对齐。现代CPU不喜欢读取不对其的数据。算法会处理大量的位移，特别是这个格式和ARGB混合在一起的时候。</p>

<p>当处理xRGB时，Core Graphic也需要支持把alpha放到最后的格式，比如RGBA，RGBx（RGB已经预先乘以alpha的格式）</p>

<h1>深奥的布局</h1>

<p>大多数时候，当我们处理位图数据时，我们就在使用Core Graphic 或是 Quartz 2D。有一个列表包括了所有的支持的文件格式。让我们先看一下剩余的RGB格式。</p>

<p>有16bpp，5bpc，不包括alpha。这个格式比之前节省50%空间（2个字节一个像素）。但是如果解压成RGB数据在内存里面或是磁盘上面就有用了。但是，因为只有5个字节一个像素，图像特别是一些平滑的渐变，可能就混合到一起了。（图像质量下降）。</p>

<p>还有一个是64bpp，16bpc，最终为128bpp，32bpc，浮点数组件(有或没有alpha值)。它们分别使用8字节和16字节，并且允许更高的精度。当然，这会造成更多的内存和更复杂的计算。</p>

<p>最后，Core Graphics 也支持一些其他格式，比如CMYK，还有一些只有alpha的格式，比如之前提到的遮罩。</p>

<h1>平面数据 （Planar Data color plane）</h1>

<p>大多数的框架（包括 Core Graphics）使用的像素格式是混合起来的。这就是所谓的 planar components, or component planes。每一个颜色组件都在内存中的一个区域。比如，对于RGB数据。我们有3个独立的内存空间，分别保存红色，绿色，和蓝色的数值。</p>

<p>在某些情况下，一些视频框架会使用 Planar Data。</p>

<h1>YCbCr</h1>

<p>YCbCr 是一个常见的视频格式。同样有3个部分组成（Y，Cb，Cr）。但是它更倾向于人眼识别的颜色。人眼是很难精确识别出来Cb和Cr的色彩度。但是却能很容易识别出来Y的亮度。在相同的质量下，Cb和Cr要比Y压缩的更多。</p>

<p>JPEG有时候把RGB格式转换为YCbCr格式。JPEG单独压缩每一个color plane。当压缩YCbCr格式时，Cb和Cr比Y压缩得更好。</p>

<h1>图片格式</h1>

<p>iOS和OSX上面的大多数图片都是JPEG和PNG格式。下面我们再了解一下</p>

<h1>JPEG</h1>

<p>每个人都知道JPEG，他来自相机。他代表了图片是图和存储在电脑里，即时是你的妈妈也听过JPEG。</p>

<p>大家都认为JPEG就是一个像素格式。就像我们之前提到的RGB格式一样，但是实际上并不是这样。</p>

<p>真正的JPEG数据变成像素是一个非常复杂的过程。一个星期都没有办法讲清楚，或是更久。对于一个color plane， JPEG使用一种离散余弦变换的算法。讲空间信息转换为频率（convert spatial information into the frequency domain）。然后通过哈夫曼编码的变种来压缩。一开始会把RGB转换成YCbCr，解压缩的时候，再反过来。</p>

<p>这就是为什么从一个JPEG文件创建一个UIImage然后会知道屏幕上面会有一点点延迟的原因。因为CPU正在忙于解压图片。如果每个TableViewCell都需要解压图片的话，那么你的滚动效果就不会平滑。</p>

<p>那么，为什么使用JPEG文件呢？因为JPEG可以把图片压缩的非常非常好。一个没有压缩过的IPhone5拍照的图片差不多24MB。使用默认的压缩设置，这个只有2-3MB。JPEG压缩效果非常好，因为几乎没有损失。他把那些人眼不能识别的部分去掉了。这样做可以远远的超过gzip这样的压缩算法。但是，这个仅仅在图片上面有效。因为，JPEG依赖于丢掉那些人眼无法识别的数据。如果你从一个基本是文本的网页截取一张图片，JPEG就不会那么高效，压缩效率会变得低下。你甚至都可以看出图片已经变形了。</p>

<h1>PNG</h1>

<p>PNG读作“ping”，和JPEG相反，他是无损压缩的。当你保存图片成PNG时，然后再打开。所有的像素数据和之前的完全一样。因为有这个限制，所有PNG压缩图片的效果没有JPEG那么好。但是对于app中的设计来说，比如按钮，icon，PNG就非常适合。而且PNG的解码工作要比JPEG简单很多。</p>

<p>在真实的世界里面，事情没有这么简单。有很多不同的PNG格式。维基百科上面有很多细节。但是简单说，PNG支持压缩有alpha或是没有alpha通道的RGB像素，这也就是为什么他适合app上面的原因。</p>

<h1>格式挑选</h1>

<p>当在app中使用颜色是，你需要使用者2种格式中得一个，PNG和JPEG。他们的解码和压缩算法都是被高度硬件优化的。有些情况甚至支持并行计算。同时Apple也在不断地提高解码的能力在未来的操作系统版本中。如果使用其他格式，这可能会对你的程序性能产生影响，而且可能会产生漏洞，因为图像解码的算法是黑客们最喜欢攻击的目标。</p>

<p>已经讲了好多有关<a href="https://duckduckgo.com/?q=%22optimizing%20PNG%22">PNG</a>的优化了，你可以在互联网上面自己查找。这里需要注意一点，Xcode的压缩算法和大部分的压缩引擎不一样。</p>

<p>当Xcode压缩png时，技术上来说，已经不是一个有效的PNG文件了。但是iOS系统可以读取这个文件，然后比通常的PNG图片处理速度更快。Xcode这样做，是为了更好地利用解码算法，而这些解码算法不能在一般的PNG文件上面适用。就像上面提到的，有非常多的方法去表示RGB数据。而且如果这个格式不是iOS图形图像系统需要的，那么就需要增加额外的计算。这样就不会有性能上的提高了。</p>

<p>再抢到一次，如果你可以，你需要设置 resizable images。你的文件会变得更小，因此，这样就会有更小的文件需要从文件系统里面读取，然后在解码。</p>

<h1>UIKit and Pixels</h1>

<p>UIKit中得每一个view都有自己的CALayer，一般都有一个缓存，也就是位图，有一点类似图片。这个缓存最后会被绘制到屏幕上面。</p>

<h1>-drawRect：</h1>

<p>如果你的自定义view的类实现了-drawRest：，那么就是这样子工作的：</p>

<p>当你调用-setNeedsDisplay时，UIKit会调用这个view的层的 -setNeedsDisplay方法。这个设置一个标记，表明这个层已经脏了（dirty，被修改了）。实际上，并没有做任何事情，所以，调用多次-setNeedsDisplay 没有任何问题。</p>

<p>当渲染系统准备好后，会调用层的-display方法。这时，层会设置缓存。然后设置缓存的Core Graphics的上下文环境（CGContextRef）。后面的绘制会通过这个CGContextRef绘制到缓存中。</p>

<p>当你调用UIKit中的函数，比如UIRectFill() 或者 -[UIBezierPath fill]时，会通过这个CGContextRef调用你的drawRect方法。他们是通过把上面的CGContextRef push 到 图形图像堆栈中，也就是设置成当前的上下文环境。UIGraphicsGetCurrent（）会返回刚才push的那个context。由于UIKit绘制方法使用UIGraphicsGetCurrent（），所以这些绘制会被绘制到缓存中。如果你希望直接使用 Core Graphics 方法，那么你需要调用UIGraphicsGetCurrent（）方法，然后自己手动传递context参数到Core Graphics的绘制函数中去。</p>

<p>那么，一个个层的缓存都会被绘制到屏幕上面，知道下一次设置-setNeedsDisplay，然后再重新更新缓存，再重复上面的过程。</p>

<h1>不使用 drawRect</h1>

<p>当你使用UIImageView的时候，有一点点的不同。这个view依然包含一个CALayer，但是这个层并不会分配一个缓存空间。而是使用CGImageRef作为CALayer的contents属性，渲染系统会把这个图片绘制到帧的缓存，比如屏幕。</p>

<p>这个情况下，就没有继续绘制的过程了。我们就是简单的通过传递位图这种方式把图片传递给UIImageView，然后传递给Core Animation，然后传递给渲染系统。</p>

<h1>使用drawRect 还是不使用drawRect</h1>

<p>听上去不怎么样，但是，最快速的方法，就是不使用。</p>

<p>大多数情况，你可以通过自定义view或是组合其他层来实现。可以看一下Chris的文章，有关<a href="http://www.objc.io/issue-3/custom-controls.html">自定义控件</a>。这个方法是推荐的，因为UIKit非常高效。</p>

<p>当你需要自定义绘制的时候 <a href="https://developer.apple.com/videos/wwdc/2012/?id=506">WWDC2012 session 506 Optimizing 2D Graphics and Animation Performance</a>是一个非常好的例子 。</p>

<p>另一个地方需要自定义绘制的是iOS的股票软件。这个股票图是通过Core Graphics实现的。注意，这个只是你需要自定义绘制，并不是一定要实现drawRect函数，有时候通过UIGraphicsBeginImageContextWithOptions（）或是 CGBitmapContextCreate（）创建一个额外的位图，然后再上面绘制图片，然后传递给CALayer的contents会更容易。下面有一个测试<a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html#concurrent-drawing">例子</a></p>

<h1>单色</h1>

<p>这是一个简单的例子</p>

<pre><code>// Don't do this
- (void)drawRect:(CGRect)rect
{
    [[UIColor redColor] setFill];
    UIRectFill([self bounds]);
}
</code></pre>

<p>我们知道为什么这样做很烂，我们让Core Animation创建了一个额外的缓存，然后我们让Core Graphics 在缓存上面填充了一个颜色。然后上传给了GPU。</p>

<p>我们可以不实现-drawRect:函数来省去这些步骤。只是简单的设置view的backgroundColor就好了。如果这个view有CAGradientLayer，那么同样的方法也可以设置成渐变的颜色。</p>

<h1>可变大小的图片（resizable image）</h1>

<p>你可以简单的通过可变大小的图片减少图形系统的工作压力。如果你原图上面的按钮大小是300*50。那么就有 600 * 100 = 60k 像素 * 4 = 240KB的内存数据需要传递给GPU。传递给显存。如果我们使用resizable image。我们可以使用一个 52 * 12 大小的图片，这样可以节省10kb的内存。这样会更快。</p>

<p>Core Animation 通过 contentsCenter 来resize图片，但是，更简单的是通过 -[UIImage resizableImageWithCapInsets:resizingMode:]。</p>

<p>而且，在第一次绘制的时候，我们并不需要从文件系统读取60K像素的PNG文件，然后解码。越小的图片解码越快。这样，我们的app就可以启动的更快。</p>

<h1>并发绘制</h1>

<p><a href="http://www.objc.io/issue-2/index.html">上一个</a>我们讲到了并发。UIKit的线程模型非常简单，你只能在主线程使用UIKit。所以，这里面还能有并发的概念？</p>

<p>如果你不得不实现-drawRect:，并且你必须绘制大量的东西，而这个会花费不少时间。而且你希望动画变得更平滑，除了在主线程中，你还希望在其他线程中做一些工作。并发的绘图是复杂的，但是除了几个警告，并发的绘图还是比较容易实现的。</p>

<p>你不能在CAlayer的缓存里面做任何事情出了主线程，否则不好的事情会发生。但是你可以在一个独立的位图上面绘制。</p>

<p>所有的Core Graphics的绘制方法需要一个context参数，指定这个绘制到那里去。UIKit有一个概念是绘制到当前的context上。而这个当前的context是线程独立的。</p>

<p>为了实现异步绘制，我们做下面的事情。我们在其他队列（queue，GCD中的概念）中创建一个图片，然后我们切换到主队列中把结果传递给UIImageView。这个技术被<a href="https://developer.apple.com/videos/wwdc/2012/?id=211">WWDC 2012 session 211</a>中提到</p>

<pre><code>- (UIImage *)renderInImageOfSize:(CGSize)size;
{
    UIGraphicsBeginImageContextWithOptions(size, NO, 0);

    // do drawing here

    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return result;
}
</code></pre>

<p>这个函数通过UIGraphicsBeginImageContextWithOptions 创建一个新的CGContextRef。这个函数也修改了当前的UIKit的context。然后可以铜鼓UIKit的方法绘制，然后通过UIGraphicsGetImageFromCurrentImageContext（）根据位图数据生成一个UIImage。然后关闭掉创建的这个context。</p>

<p>保证线程安全是非常重要的，比如你访问UIKit的属性，必须线程安全。如果你在其他队列调用这个方法，而这个方法在你的view类里面，这个事情就可能古怪了。更简单的方法是创建一个独立的渲染类，然后当触发绘制这个图片的时候才设置这些必须得属性。</p>

<p>但是UIKit的绘制函数是可以在其他队列中调用的，只需要保证这些操作在 UIGraphicsBeginImageContextWithOptions（） 和 UIGraphicsEndImageContext （）之前就好。</p>

<p>你可以通过下面的方法触发绘制</p>

<pre><code>UIImageView *view; // assume we have this
NSOperationQueue *renderQueue; // assume we have this
CGSize size = view.bounds.size;
[renderQueue addOperationWithBlock:^(){
    UIImage *image = [renderer renderInImageOfSize:size];
    [[NSOperationQueue mainQueue] addOperationWithBlock:^(){
        view.image = image;
    }];
}];
</code></pre>

<p>注意view.image = image; 必须在主队列调用。这是非常重要的细节。你不能在其他队列中调用。</p>

<p>通常来说，异步绘制会带来很多复杂度。你需要实现取消绘制的过程。你还需要限制异步操作的最大数目。</p>

<p>所以，最简单的就是通过NSOperation的子类来实现renderInImageOfSize方法。</p>

<p>最后，有一点非常重要的就是异步设置UITableViewCell 的content有时候很诡异。因为当异步绘制结束的时候，这个Cell很可能已经被重用到其他地方了。</p>

<h1>CALayer的奇怪和最后</h1>

<p>现在你是到了CALayer某种程度上很像GPU中的纹理。层有自己的缓存，缓存就是一个会被绘制到屏幕上的位图。
大多数情况，当你使用CALayer时，你会设置contents属性给一个图片。这个意思就是告诉 Core Animation，使用这个图片的位图数据作为纹理。 如果这个图片是PNG或JPEG，Core Animation 会解码，然后上传到GPU。</p>

<p>当然，还有其他种类的层，如果你使用CALayer，不设置contents，而是这事background color，  Core Animation不会上传任何数据给GPU，当然这些工作还是要被GPU运算的，只是不需要具体的像素数据，同理，渐变也是一个道理，不需要把像素上传给GPU。</p>

<h1>图层和自定义绘制</h1>

<p>如果CALayer或是子类实现了 -drawInContext 或是-drawLayer:inContext delegate。Core Animation会为这个layer创建一个缓存，用来保存这些函数中绘制的结果。这些代码是在CPU上面运行的，结果会被传递给GPU。</p>

<h1>形状和文本层（Shape and Text Layers）</h1>

<p>形状和文本层会有一点不同。首先，Core Animation 会为每一个层生成一个位图文件用来保存这些数据。然后Core Animation 会绘制到layer的缓存上面。如果你实现了-drawInContext方法，结果和上面提到的一样。最后性能会受到很大影响。</p>

<p>当你修改形状层或是文本层导致需要更新layer的缓存时，Core Animation会重新渲染缓存，比如。当实现shape layer的大小动画时，Core Animation会在动画的每一帧中重新绘制形状。</p>

<h1>异步绘制</h1>

<p>CALayer 有一个属性是 drawsAsynchronously。这个似乎看上去很不错，可以解决所有问题。实际上虽然可能会提高效率，但是可能会让事情更慢。</p>

<p>当你设置 drawsAsynchronously = YES 后，-drawRect: 和 -drawInContext: 函数依然实在主线程调用的。但是所有的Core Graphics函数（包括UIKit的绘制API，最后其实还是Core Graphics的调用）不会做任何事情，而是所有的绘制命令会被在后台线程处理。</p>

<p>这种方式就是先记录绘制命令，然后在后台线程执行。为了实现这个过程，更多的事情不得不做，更多的内存开销。最后只是把一些工作从主线程移动出来。这个过程是需要权衡，测试的。</p>

<p>这个可能是代价最昂贵的的提高绘制性能的方法，也不会节省很多资源。</p>

<h1>翻译吐槽</h1>

<p>这篇文章实在是太长了，而且太啰嗦了。真是累觉不爱。觉得侮辱读者智商，不过内容还是非常值得学习的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译：《iOS7 新功能 视图控制器API》]]></title>
    <link href="http://studentdeng.github.com/blog/2013/11/19/ios7-viewcontroller/"/>
    <updated>2013-11-19T18:12:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/11/19/ios7-viewcontroller</id>
    <content type="html"><![CDATA[<p>这篇文章投稿在 <a href="http://blog.jobbole.com/51588/">伯乐在线</a></p>

<p>原文出处: <a href="http://www.objc.io/issue-5/view-controller-transitions.html">objc</a></p>

<h1>View Controller Transitions</h1>

<p><a href="http://www.objc.io/issue-5/index.html">Issue #5 iOS 7</a>, October 2013</p>

<p>作者 <a href="http://twitter.com/chriseidhof">Chris Eidhof</a></p>

<h1>自定义动画</h1>

<p>iOS7对我来说最激动人心的特性就是新的 View Controller Transitioning API。 iOS7之前，View Controller之间切换，我需要创建自定义的transitions。 而且这些方法都支持不完整，让人头疼。在transitions中增加交互功能就更难了。</p>

<p>在开始这篇文章之前，我要提醒一下：这是一个新的API，我们尽最大努力让他可以实用，但是并不能保证是最佳。可能需要至少一个月后才能确定，这篇文章是不是最佳的实用方案，这里只是一个对新功能的探索。如果有更好的使用这个API的方法，请联系我们，这样就可以修正这篇文章。</p>

<p>在开始介绍这个API之前，我们需要知道导航控制器的默认行为在iOS7下已经改变了：导航控制器下，切换2个view controller的动画有一点细微的改变，变得更有交互性。例如，当你希望弹出一个view controller时，可以从屏幕左边开始拖动，把整个内容拖动到屏幕右边。</p>

<p>让我们仔细看一下这个API，我发现这个被重度使用的接口是协议并不是一个实体。虽然一上来看上去有一点怪，但是我喜欢这个API，它给了我们更多的灵活性。我们从简单开始：用自定义动画代替原有的view controller的push动画（这里是<a href="https://github.com/objcio/issue5-view-controller-transitions">sample project</a> 在github）。我们首先需要实现这个新的 UINavigationControllerDelegate 方法：</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
               navigationController:(UINavigationController *)navigationController
    animationControllerForOperation:(UINavigationControllerOperation)operation
                 fromViewController:(UIViewController*)fromVC
                   toViewController:(UIViewController*)toVC
{
    if (operation == UINavigationControllerOperationPush) {
        return self.animator;
    }
    return nil;
}
</code></pre>

<p>我们可以观察一下这种类型的操作（push 和 pop）返回一个不同的 animator。如果我们分享代码的话，这个可能是一个对象。我们可能需要把这个变量通过property保存下来。我们也可以为不同的操作创建不同的对象，这里有很高的灵活性。</p>

<p>让这个动画运行起来，我们创建一个自定义对象实现 UIViewControllerContextTransitioning 协议。</p>

<pre><code>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end
</code></pre>

<p>这个协议要求我们实现2个方法，其中一个是描述动画的执行时间</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    return 0.25;
}
</code></pre>

<p>另一个是描述动画的执行。</p>

<pre><code>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    [[transitionContext containerView] addSubview:toViewController.view];
    toViewController.view.alpha = 0;

    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
        toViewController.view.alpha = 1;
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];

    }];

}
</code></pre>

<p>这里你可以看到这个协议是怎么用的：没有提供实体的对象参数，而是通过这个类型 id<UIViewControllerContextTransitioning> 得到transitionContext
唯一的最重要的东西就是在完成动画之后要调用 completeTransition 这个告诉 transitionContext 我们已经完成动画并且相应的更新了 view controller的状态。其他代码是标准的，我们通过transitionContext得到2个UIViewController，然后使用简单的 UIView 动画，这里我们很简单的做了一个zooming的动画</p>

<p>注意，我们只是写了push的自定义动画，当view controller pop时,iOS系统还是会使用默认的滑动动画。而且，实现这个方法后。导航栏也不能交互了（就是从左到右拖动实现pop view controller）。下面完善他</p>

<h1>交互动画</h1>

<p>让之前的动画变得能够交互起来非常简单。我们需要实现另一个UINavigationControllerDelegate</p>

<pre><code>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
{
    return self.interactionController;
}
</code></pre>

<p>注意，如果在一个不能交互的动画中，这里会返回nil。（译注：当不能交互时 self.interactionController 为 nil）</p>

<p>interactionController是UIPercentDrivenInteractionTransition的实例，没有必要更多的设置。我们通过创建拖动手势（UIPanGestureRecognizer）来实现：</p>

<pre><code>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
    }
} 
</code></pre>

<p>只有当用户在屏幕右边操作时，我们才设置动画是可以交互的（通过设置interactionController 属性）。然后我们调用performSegueWithIdentifier（或是不用storyboards，直接push view controller）
在这个手势变化中，我们调用interactionController 的一个方法 updateInteractiveTransition:</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
    [interactionController updateInteractiveTransition:d];
} 
</code></pre>

<p>这里根据拖动的距离设置百分比，非常cool的事情是交互控制器（interactionController）和 动画控制器（animation controller）相互协作。而且因为是普通的 UIView 动画，它控制着动画的进程。我们不需要处理他们之前的事情，
所有的事情都在背后默默的自动搞定了。</p>

<p>最后，当手势停止或是取消掉，我们需要调用interaction controller相应的方法</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
        [interactionController finishInteractiveTransition];
    } else {
        [interactionController cancelInteractiveTransition];
    }
    navigationControllerDelegate.interactionController = nil;
}
</code></pre>

<p>当切换动画完毕时，设定interactionController为nil非常重要。如果下一个动画是非交互的，我们不希望得到一个奇怪的 interactionController</p>

<p>现在我们已经有一个完整的自定义的可交互的过度变换（transition）了。通过普通的拖动手势和一个UIKit提供的实体对象，几行代码就搞定了。对于大多数的自定义交互过度变换，你可以在这里停下来，用上面提到的方法做任何你想做得动画
或是交互。</p>

<h1>GPUImage自定义动画</h1>

<p>我们现在已经能够实现一个完整的自定义动画了，可以不用UIView 甚至Core Animation，做自己喜欢的动画。一开始，我用Core Image实现了一个项目<a href="http://www.macstories.net/featured/a-conversation-with-loren-brichter/">Letterpress-style</a>。但是在我的旧iPhone4上面只能跑到大约9FPS，这个和我所期望的60FPS差距太大了。</p>

<p>但是当我使用<a href="https://github.com/BradLarson/GPUImage">GPUImage</a>后，实现一个非常漂亮的自定义动画效果变得非常简单。我们希望这个动画能够做到像素级的消融在2个view controller切换的时候。这个是通过分别对2个view controller 截屏，然后应用GPUImage的图片滤镜实现的。</p>

<p>首先，我们创建一个自定义类，实现animation 和 interactive transition 协议。</p>

<pre><code>@interface GPUImageAnimator : NSObject
  &lt;UIViewControllerAnimatedTransitioning,
   UIViewControllerInteractiveTransitioning&gt;

@property (nonatomic) BOOL interactive;
@property (nonatomic) CGFloat progress;

- (void)finishInteractiveTransition;
- (void)cancelInteractiveTransition;

@end
</code></pre>

<p>为了让这个动画跑的飞快，我们只把图片传给GPU一次，然后把所有的图像处理绘制交给GPU，而不是传给CPU（GPU和CPU之间的数据传输非常慢）。通过GPUImageView，我们可以用OpenGL绘制动画效果（不需要手动编写底层的OpenGL代码，我们可以继续编写上层代码）</p>

<p>创建这样的滤镜链非常方便。这里可以看一下下面的例子。有一点挑战的是实现动态的滤镜。GPUImage不能给我们直接提供动画效果。这里我们通过在每一帧的时候更新滤镜来实现动画的绘制。我们使用CADisplayLink类来做这个。</p>

<pre><code>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
</code></pre>

<p>在frame:方法中，我们根据时间更新动画进度，然后更新滤镜</p>

<pre><code>- (void)frame:(CADisplayLink*)link
{
    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
    self.blend.mix = self.progress;
    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
    [self triggerRenderOfNextFrame];
}
</code></pre>

<p>以上就是我们所有要讲得了。在交互变换中，我们需要确保我们的进度是根据手势识别设置的，而不是根据时间。但是剩下的代码几乎都一样了。</p>

<p>这个真的太强大了，你可以使用GPUImage提供的任何滤镜或是自己写的OpenGL代码来实现上面的效果。</p>

<h1>小结</h1>

<p>我们这里仅仅提到了导航控制器下面的2个 view controller 之间的动画，事实上你可以做相同的事情在tabbar controller 或是自定义的container view controller。而且 UICollectionViewController 现在已经可以在layout上面自动实现交互动画了。他们都是使用相同的机制。这个真的太强大了。</p>

<p>当我和<a href="https://twitter.com/orta">Orta</a>提到这个API时，他指出他已经使用这个功能创建了一些轻量级的view controller。不要在每一个view controller 保存管理动画的代码，而是创建一个新的view controller，然后实现2个view controlller视图切换时的自定义的动画效果。</p>

<h1>更多</h1>

<ul>
<li><a href="http://asciiwwdc.com/2013/sessions/218">WWDC: Custom Transitions using View Controllers</a></li>
<li><a href="http://www.teehanlax.com/blog/custom-uiviewcontroller-transitions/">Custom UIViewController transitions</a></li>
<li><a href="http://www.doubleencore.com/2013/09/ios-7-custom-transitions/">iOS 7: Custom Transitions</a></li>
<li><a href="http://whoisryannystrom.com/2013/10/01/View-Controller-Transition-Orientation/">Custom View Controller Transitions with Orientation
</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一次马拉松，也是这段时间健身的总结]]></title>
    <link href="http://studentdeng.github.com/blog/2013/11/17/sports-nov/"/>
    <updated>2013-11-17T21:41:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/11/17/sports-nov</id>
    <content type="html"><![CDATA[<h1>第一次接力马拉松</h1>

<p>11月16日是个特别的日子，健身满16个月，更重要的是参加了人生第一次马拉松，香山接力赛，平均坡度35，一次往返3km，一个队伍4个人，每人4圈，每人总共12km。时间从上午11点，跑到下午4点。16个月前，当我开始准备减肥的时候，我从来没有想过可以一口气做6个引体向上，没有想过可以一口气600多个仰卧起坐，也没有想过我的胸围可以长5cm，没有想过我的腰围可以减少12cm，没有想到我可以减40斤，更没有想过，我居然有了参加山地马拉松的能力，虽然仅仅是接力赛。</p>

<p>说道马拉松，不得不多说几句，跑一次全程马拉松是我30岁前必须完成的人生目标之一。为了方便去香山，15日我暂住一个朋友家，在14日在家的时候，我开心的一晚上睡不着觉，弄得我不得不担心我会不会因为过于兴奋而导致体力消耗太大最后不能完赛。好在16日的时候，我已经完全调整过来，而且老天也特别配合，PM2.5出奇的低，给我一个风和日丽的早上。整个比赛还算轻松，或是对自己要求不够高吧，除了第一圈比较吃力以外，后面越来越好，特别是最后一圈，如果再给我一次机会，我会更努力的跑。</p>

<h1>16个月运动统计</h1>

<p>说了这么多虚的，这是我运动的统计，由于没有想到过自己能够坚持这么长时间，统计只是从2013年4月5日开始到今天。总共226天的时间其中健身160.73小时,下面是每个月的运动时间统计，纵坐标单位分钟。</p>

<p><img src="http://studentdeng.github.com/images/sports-nov1.png" alt="image" /></p>

<p>一个月的维度已经很大了。这个充分说明，即便我已经有了这样大的运动效果，16个月，我的健身习惯还没有真正的养成，不管是计划制定，还是执行层面，因为一个习惯的正常曲线应该是这样子的。</p>

<p><img src="http://studentdeng.github.com/images/sports-nov2.png" alt="image" /></p>

<p>这是我的英语听写计划时间统计，英语计划相对健身更简单可控。记得有一本书中写道，一个成熟的人制定的计划是稳步递增的，而那些年轻人的计划，往往都是大起大落。好吧，这里就不嘲笑自己了。</p>

<p>很多人都问我，坚持下来的原因是什么，这个真的很难说，在一开始的时候，想法总是很简单的，和很多人一样，希望更好看一点，更健壮一点。但是如果一直是这么简单的想法，必然不能长久，很多东西会在这个改变的过程中加入进来，甚至变成最重要的东西。反之也会有很多东西变得不那么重要最后离我而去。现在来说，最大的原因在于我的性格上的变化。这半年来，我性格上面最大的变化就是变得越来越goal oriented， 在健身的过程中，最能体现的就是一个个目标达成的幸福感，这个让我非常开心，因为就目前我能做的事情来看，像健身这种只要做，就比不做强的事情，而且还有不少附加价值的实在是少之又少。</p>

<h1>意志力</h1>

<p>健身的过程的确是很苦的，当然这个世界上被认为有价值的习惯都是很难达到，需要花费大量的时间，不仅是健身，还是英语我实际花费的时间都比上面统计的要多的多。比如你可能需要学习做饭，你可能需要控制饮食，我在减脂的3个月中，几乎不吃肉，把一切零食，甜食，饮料当成毒药。忌口对于我这种意志力薄弱的人来说，真的是相当的难。不管是再好吃的东西，要做到能够停下来，或是坚决不吃。一个朋友说过这样子的话“我常常把吃得放在一边，人必须学会控制自己的嘴巴，这是一种训练意志力的方式，因为很简单，如果自己的嘴巴都控制不了，还指望她能做点什么”。这个怎么说呢，话粗理不粗吧。我反正是不同意这个观点，但是喜欢这个做事态度。</p>

<p>说道意志力，让我想起了施瓦辛格说的一句话“健身的精髓在于力竭后的最后一个”，同样还有很多类似的话“马拉松比赛在20km之后才开始”。对现在的我来说，健身在跑完5km，或是300个仰卧起坐，或是300个深蹲又或是10组pull ups，俯卧撑，推胸之后才真正开始，之前做得一切运动都只是为了积累身体疲劳到一定程度,这样才能有意义，因为力竭之后的动作，才是给身体最好的信号“我要变得更强壮”。</p>

<p>讲锻炼意志力的书有很多很多，方法也很多很多，在健身的方面，我最喜欢的就是P90X里面教练提到的方法，另外我增加了最后面一条。</p>

<p>1、设定目标
2、达成目标
3、记录下来
4、忘掉它</p>

<h3>设定目标</h3>

<p><strong>设定目标</strong>的动机很明白，跑马拉松的时候，大家不会设定一个终点这样的目标，而是将这个过程分解成一个弯角，一段斜坡。同样力量训练也是分成25个一组的小重量，8-12个的大重量。设定目标最大得作用在于clear your mind and focus on the things。</p>

<h3>达成目标</h3>

<p><strong>达成目标</strong>，这个毋庸置疑，目标就是要被达成的。</p>

<h3>记录下来</h3>

<p>前2个一般人都可以做到，但是后面的2个才是真正的精髓。在任何过程中都会产生迷茫，哪怕是改变一个小小的习惯，因为不管怎样你都无法逃避掉一个问题“How to be better XXX”。<strong>记录下来</strong>就是为了这个准备的。我是那种容易消极的人，数据让我不会把一些局部失败看得太重，把局部成功看得太重。这一点对我帮助很大，我看到了我最近3个月器械力量增大一倍，但是整体时间依然波动很大等等这些都是帮助我抵抗不良情绪最好的良药。</p>

<h3>忘掉它</h3>

<p><strong>忘掉它</strong>是一个很神奇的东西，在跳出舒适区的过程中，特别有用。比如你已经做了500多个仰卧起坐，每一个都已经burning，如果你脑子里面想得是我已经做了500个了，一般人200个都做不了，那么就很难做到600+。忘掉它是一种归零的心态，每一组动作都是一个新的起点，新的开始。也是对抗懒惰最好的良药，特别是我这种对自己要求比较低，喜欢放纵自己的人。我是真的对自己要求低，特别是在健身上面。我见过非常多的人一起跑步的时候吐过，一起踢球的时候抽筋过，也亲眼见过跑步训练跑到眼底角膜充血的，也见过做yoga把腿都拉伤的，很多很多的例子。而我则是被教练说“你就是对自己要求太低”，“你之前炼过吧，额，你怎么不跑了？还有5圈呢？”，从小到大一直都是。</p>

<h1>后记</h1>

<p>健身已经从一开始的甩掉大肚子，变成了我生活的一部分或是他本身就是我生活的缩影。在香山认识了也见识了很多牛人，有骑行川藏的，海拔5000km，有跑戈壁滩的，一天30km，连续跑4天的。而他们有的甚至平均年龄高达45岁。除了这些已经几乎bt的人以外，也有30大几的已婚姐姐锻炼成“钢筋铁骨”的，相比而言我这25岁的“小娃娃”，记得当时我开始健身的时候，最大的原因就在于，我已经25岁了，老了，而且我之前2次减肥失败，这次再不减肥肯定就完蛋了的心态。呵呵，现在想起来还是蛮好笑的。虽然人的确在经过25岁之后，心肺，肌肉等等身体各项机能都会开始退化开始衰老，更容易产生脂肪，但是我很开心，在我25岁的时候，我所做的一切。身体和灵魂，至少有一个需要在路上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stanford 算法课 part 2 Scheduling]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/16/algo-class-02-scheduling/"/>
    <updated>2013-09-16T20:46:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/16/algo-class-02-scheduling</id>
    <content type="html"><![CDATA[<p>当一个人每天都有做不完的事情时，不知道大家又没有这种感觉。各种各样的事情，各种deadline，甚至是一些无关紧要的琐碎事情也会不断的在大脑中被回想，而且还是反复的，没有任何理由的会冒出来。对像我这样非常懒惰的人来说，这就是一个非常致命的打击，因为我需要中断当前的事情，这会让我多消耗不少脑力。。。</p>

<p>这应该算是时间管理中的一部分，如何给自己安排任务。人的大脑和电脑的工作模式还是有一些类似的，比如如果一直不断的记录一大堆事情而不是执行，那么就会影响到他们的工作效率。同样，如果重要的事情不作，最后也会不断的在大脑里面被回想，而造成效率降低。</p>

<p>在我看来，解决这些回想问题最关键的事情就是把这些东西搞定，这样才能把大脑清空，然后去做那些更加有意义的事情。</p>

<p>最近再跟algorithm part2里面正好有一个scheduling application的东西，挺有意思的。这里记录一下。</p>

<h1>问题描述</h1>

<h2>Setup</h2>

<p>scheduling 的基本模型是有一个shared resource，比如CPU。但是有许多jobs，比如很多线程，需要使用CPU才能运行。</p>

<h2>Question</h2>

<p>我们应该如何调度这个jobs的顺序，哪一个job优先于其他job执行，从而让整个计划执行时间最少。</p>

<h2>Assume</h2>

<p>为了更清楚的定义数学模型，每一个job有2个维度。</p>

<ul>
<li>weight 重要性</li>
<li>length 时间</li>
</ul>


<h2>Defintion</h2>

<p>Completion time。 第J个任务的完成时间（Completion time）Cj 是 （任务J之前的等待时间 + 任务J的length）* 任务J的weight</p>

<h1>思路</h1>

<p>这里根据直觉可以很明显的知道 我们需要把重要的事情放在前面，把时间短的事情放置在前面，这样可以很快的打一个勾勾，清空大脑中的这个任务。也就是说Cj 和 Wj 正相关，和 Lj负相关。但是总是有一些事情让人欲罢不能，就是那些很重要，而且做起来还比较费劲，时间花费长的事情，和那些不重要但是时间花费短的事情。真实世界的事情太复杂，还是回到我们这个简单的模型中。</p>

<p>一种常见的思维是设法将问题转换成之前我们已经解决了的思路之中，所以很容易想到我们需要找到单位长度中最重要的事情先做。因为我们的这个模型的任务调度不是抢占式的么。</p>

<p>将上面的单位时间的含义翻译过来就是 wj / lj。 也就是我们的调度程序将按照w / l的值，从大到小排列
<img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_01.png" alt="scheduling 1" /></p>

<p>这里我们假定任务i > j。这个图则表示这2个任务相连在一起，stuff表示之前的任务，more stuff表示之后的任务。</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_02.png" alt="scheduling 2" /></p>

<p>而这里，我们做一次任务i、j的交换，就像这样</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_03.png" alt="image" /></p>

<p>那个这2个scheduling中，i,j之前的任务的完成时间不会变，之后的任务完成时间也不会变。那么受到影响的只是任务i，j。</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_04.png" alt="image" /></p>

<p>那么这里显然scheduling 2 也就是后面的那张图的顺序比第一个要小。</p>

<p>然后我们可以想象最后的任务流程，就如果冒泡排序一样，一次次的比较把相对重要的数据一次次的放置到前面。</p>

<p>而当所有相邻的任务都按照这样的规则排列完毕后，得到的就是一个 wj / lj 的从大到小的序列。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[calm down]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/15/calm-down/"/>
    <updated>2013-09-15T23:03:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/15/calm-down</id>
    <content type="html"><![CDATA[<p>最近已经发生了很多事情，将来也会发生一些事情，这里为了不让我负能量爆发，就不写这些细节了。昨天和老大聊到晚上3点半，这里我还很dt的查了一下，上一次聊这么晚也就是2个月前。刚刚突然发现有人赞了一下我的微博，哦，很好，长出一口气，终于不是强X的无脑赞了。微博的内容是一篇关于《女人明白要趁早》的读书笔记，书里写过一句这样的话“这世上只有快乐的猪和悲伤的哲学家”，但在我看来，还有另一类人是悲伤的猪，而我显然属于后者。当然这不是我想说的，书中有一些这样的话。</p>

<p>“当你一无所知、一无所有、一无所成的时候,没事不要去想“个人尊严”和“个人价值”这 类虚词儿。一、做好眼前事。二、假以时日。 有完美榜样是好的,能让我们矢志不渝地去为追求完美努力;知道榜样其实不完美也是好的, 避免我们成为偏执狂,或者因为目标难以企及而自暴自弃。”</p>

<p>这个世界上面充斥这这样子的言论，你没有办法去反驳它，因为他本身说的就是事实，是正确的，而且是毫无疑问正确的，但是如果只是做到这些是不可能成功，或是更严格讲，这些都不是成功的关键因素，从心理学角度来看，这些话没有办法被证伪。这些话就是一个个成功人士为了安慰屌丝们的心灵鸡汤而已。</p>

<p>对于年轻的人们来说，经历的苦难和挫折大概都是因为阅历，资历不足，内心却比地球还大，一开始就像构建一艘航空母舰。但最后发现这样的航母根本做不出来，或是做出来随便小小的浪头就能把它拍的粉碎。而也有不少人意识到了这一点，做出了一艘艘驱逐舰，潜艇。但最后发现，光这艘船，根本不可能带你穿过那些暴风雨频发的海域。</p>

<p>我们害怕跌入日复一日平淡庸碌的结婚、生子、还房贷、终老一生的生活中去。但是现实就是这个社会最不缺的就是空想家，社会不仅不看你的想法，不在意你的未来，更不在意你的过去，只是看你的现在，你的所作所为。你所能掌握的资源，你能做出多少选择的能力。</p>

<p>大家都会成长，会慢慢看淡这些ups and downs，大家都在说，现在社会多么浮躁，年轻人要学会等待，假以时日，每天坚持，就会变好的。我只想说“呵呵”。平静会很容易的掩饰内心的平庸，诚然平静很重要，但绝对不是逃避，需要cope，而这需要一个强大的内心。只有内心足够强大才能做出抵挡风浪的船，而不是随流漂动的木板，虽然他们都是在水上浮着，当然木板也有好处，船会翻。木板不会。</p>

<p>一个朋友曾今问过我为什么给自己设定一个30岁的目标，因为有太多的东西我们不能左右，在到一定年纪就不得不考虑，作为一个男孩子，不得不去承担一些该来的责任，那么自由时间必定要被压缩，而且有一些事情，年纪大了，也就错过机会了，或是需要付出比年轻时候更多的投入。所以必须趁年轻，因为在再不疯狂就来不及了。</p>

<p>Tal在幸福课中提到一句，平庸和卓越在表面都很平静时是如何区分出来。卓越的人更会相信自己会做到。</p>

<p>额，本来还是想写下去，发现自己已经不知不觉开始写心灵鸡汤了，看来我已经被毒害不少了，再删掉一大段之后，思路瞬间被阻塞了。一阵阵困意袭来，呼~，昨天睡得有一点少了。今天最开心的就是，去东直门上了一节跳舞课，按照我以往对我自己的了解，我应该死宅在家里才对，绝对不会出门，更别说走这么远。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocoapods 入门]]></title>
    <link href="http://studentdeng.github.com/blog/2013/09/13/cocoapods-tutorial/"/>
    <updated>2013-09-13T23:48:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/09/13/cocoapods-tutorial</id>
    <content type="html"><![CDATA[<h1>介绍</h1>

<p>最近一直在搞<a href="https://github.com/CocoaPods/CocoaPods">cocoapods</a>。 ios 这么多年终于有一个好使的包管理了。真的好激动好激动。。。
之前开发一些App的时候，在一开始的时候，总是需要手动添加framework， library，设置一些 search path，有时候还会忘记那么几个，然后出来一大堆的link error。当一些library更新的时候，还需要自己手动去更换。3句话说就是</p>

<ol>
<li>手动增加framework，library</li>
<li>手动增加编译参数</li>
<li>手动维护代码更新</li>
</ol>


<p>完全是一大堆的体力活，当然，这些简单的配置和复制并不会花费太多的时间，但是，还是觉得在浪费生命，而这时候CocoaPods就出来了。我们只需要设置一个Podfile文件，执行</p>

<pre><code>$ pod install 
</code></pre>

<p>CocoaPods会帮我们下载好代码，设置好编译参数，配置好framework， library。</p>

<h1>安装和更新</h1>

<pre><code>$ sudo gem install cocoapods
</code></pre>

<h1>使用</h1>

<p>在project根目录下，create Podfile文件，下面一个例子</p>

<pre><code>platform :ios, '5.0'
pod 'CURestKit', '~&gt;1.0.1' 
pod 'SDWebImage','~&gt;3.4'
pod 'MBProgressHUD', '~&gt; 0.7'
pod 'UALogger', '~&gt; 0.2.3'
</code></pre>

<p>CocoaPods 会帮我们从git clone下来配置好的这些代码。后面的部分表示代码的版本号，一般来说和tag挂钩。</p>

<p>配置好Podfile之后，执行</p>

<pre><code>$ pod install
</code></pre>

<p>则会帮我们配置好这些项目。并生成一个XXXX.xcworkspace。 以后project使用这个文件就可以了。CocoaPods其实就是帮我们配置一个静态库作为项目的依赖。</p>

<p>CocoaPods里面有大量的代码，现在最新的版本安装后是在这里</p>

<pre><code>~/.cocoapods/repo/master/ 
</code></pre>

<h1>制作自己的项目配置</h1>

<p>实际开发过程中，我们还有不少代码需要被改动，而CocoaPods上面的代码，大部分都比较旧，都是很稳定的代码，当然也有一些不能用的（大部分是国内的公司做的，大家都懂的）。另外还有一些我们自己写的一些其他代码，暂时还么有被CocoaPods收录的。这时候我们就需要配置自己的项目啦。</p>

<p>这里是我的一个项目配置例子。cocoapods的配置文件就是一个 *.podspec的文件，这是一个例子文件名ShareCenter.podspec。这是一个典型的ruby，</p>

<pre><code>Pod::Spec.new do |s|
s.name         = "ShareCenter"
s.version      = "2.0"
s.summary      = "share client include sina weibo ,tencent weibo, renren"

s.description  = &lt;&lt;-DESC
               share client include sina weibo ,tencent weibo, renren
               DESC

s.homepage     = "https://github.com/studentdeng/ShareCenterExample"
s.license      = 'MIT'
s.author       = { "curer" =&gt; "studentdeng@hotmail.com" }
s.platform     = :ios, '5.0'

s.source       = { :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git", :tag =&gt; s.version.to_s }
s.source_files  = 'ShareCenter', 'ShareCenter/**/*.{h,m}'

s.frameworks   = 'QuartzCore', 'Security', 'CoreGraphics', 'AudioToolbox'
s.library = 'sqlite3.0'
s.vendored_libraries = 'ShareCenter/Vender/sina/libWeiboSDK/libWeiboSDK.a'

s.prefix_header_contents = &lt;&lt;-EOS
#ifdef __OBJC__
#import "ROConnect.h"
#endif /* __OBJC__*/
EOS
end
</code></pre>

<p>这个基本上都是自解释的，这里有几个需要说明一下</p>

<h2>s.source s.source_files</h2>

<p>这里的 <em>source</em> 我们看出是一个git 的地址，这里我们调试的时候，可以先暂时设置成本地git，调试完毕之后就可以发布 增加tag。想要最新的代码只需要这样设置就好</p>

<pre><code>{ :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git"}
</code></pre>

<p>我们的git项目中，并不是所有的代码都需要被引用到我们的代码中，通常project还会包括一些example，test cases等，这里的 <em>source_files</em> 就是用来指定一些文件夹，或是文件。我这里的设置也很容易理解，就是ShareCenter下面的递归后的所有后缀是h、m的子文件。</p>

<h2>s.frameworks s.library</h2>

<p>这里配置的就是我们的framework 和 library，这里注意一下library的名字规则就好。</p>

<h2>vendored_libraries</h2>

<p>这里用来指定外部的静态库。这里我们指定了sina sso认证的SDK</p>

<h2>s.prefix_header_contents</h2>

<p>这里用来指定预编译的配置，这里一定要鄙视一下renren的超级渣渣SDK。这里提供一种解决方法。</p>

<h2>部署我们的配置到cocoapods中</h2>

<p>cocoapods的代码配置文件是在这里<a href="https://github.com/CocoaPods/Specs">Specs</a></p>

<p>这里最好是去fork一个自己的project，然后保存一个自己或是团队的配置，这样不会在更新cocoapods的时候，丢掉自己的配置。当然，如果觉得自己搞的还不错，也可以去pull requests。</p>

<p>在之前提到的目录<em>~/.cocoapods/repo/master/</em> 下面，我们可以看到已经有超级多的项目了，我们可以也可以通过</p>

<pre><code>$ pod search XXX
</code></pre>

<p>来查找项目，或是直接在这个文件夹下面找，可以学习不少project的配置技巧，我这里也是从他们学到的。</p>

<p>最后添加一个project的配置是这样子的。</p>

<p>例如上面的例子，
在<em>~/.cocoapods/repo/master/</em> 下面创建一个文件夹ShareCenter，然后在创建一个2.0的文件夹表示这是version2.0的配置。
然后在把之前的ShareCenter.podspec复制到2.0目录下面。</p>

<p>也就是最后的目录是这样子的</p>

<pre><code>~/.cocoapods/repo/master/ShareCenter/2.0/ShareCenter.podspec
</code></pre>

<p>如果希望更多的了解cocoapods，还是需要去<a href="https://github.com/CocoaPods/CocoaPods">Github</a>上面 :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis服务器启动流程]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/19/redis-start-up/"/>
    <updated>2013-08-19T10:26:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/19/redis-start-up</id>
    <content type="html"><![CDATA[<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<p>让我们从 redis.c -> main() 开始</p>

<h1>读取配置文件</h1>

<p>在初始化完毕一些系统时间之后，redis开始初始化服务器配置。</p>

<h2>initServerConfig</h2>

<p>在这个函数中，初始化全局变量</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>struct redisServer 结构体描述了服务器的状态。这种庞大的数据结构实在是看的烦躁。
这里可以很方便的看到redis的系统默认配置。另外还初始化了系统命令表。</p>

<pre><code>server.commands = dictCreate(&amp;commandTableDictType,NULL);
populateCommandTable();
</code></pre>

<p>这里我们可以找到redis的命令所对应的函数名称。</p>

<pre><code>struct redisCommand redisCommandTable[] = {
    {"get",getCommand,2,"r",0,NULL,1,1,1,0,0},
    {"set",setCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setnx",setnxCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setex",setexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"psetex",psetexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
    //...
}


struct redisCommand {
    // 命令的名字
    char *name;
    // 命令的实现函数
    redisCommandProc *proc;
    // 命令所需的参数数量
    int arity;
    // 字符形式表示的 FLAG 值
    char *sflags; /* Flags as string represenation, one char per flag. */
    // 实际的 FLAG 值，由 sflags 计算得出
    int flags;    /* The actual flags, obtained from the 'sflags' field. */
    /* Use a function to determine keys arguments in a command line.
     * Used for Redis Cluster redirect. */
    // 可选，在以下三个参数不足以决定命令的 key 参数时使用
    redisGetKeysProc *getkeys_proc;
    /* What keys should be loaded in background when calling this command? */
    // 第一个 key 的位置
    int firstkey; /* The first argument that's a key (0 = no keys) */
    // 第二个 key 的位置
    int lastkey;  /* THe last argument that's a key */
    // 两个 key 之间的空隔
    int keystep;  /* The step between first and last key */
    // 这个命令被执行所耗费的总毫秒数
    long long microseconds;
    // 这个命令被调用的总次数
    long long calls;
};
</code></pre>

<p>这里可以看出，redis的命令配置，保存在底层数据结构dic中。</p>

<h1>服务器初始化</h1>

<h2>initServer</h2>

<p>这里设置信号回调函数，和继续初始化</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>结构外，创建了SharedObjects。</p>

<h3>createSharedObjects</h3>

<pre><code>initServer-&gt;createSharedObjects
</code></pre>

<p>redis这里将除了把一些常用的字符串保存起来，目的就是为了减少不断申请释放时CPU时间，内存碎片等等,常用的返回客户端的命令，消息等。如</p>

<pre><code>shared.ok = createObject(REDIS_STRING,sdsnew("+OK\r\n"));
shared.err = createObject(REDIS_STRING,sdsnew("-ERR\r\n"));

//...

shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(
    "-WRONGTYPE Operation against a key holding the wrong kind of value\r\n"));
//...
</code></pre>

<p>还初始化了一个很大的共享数字对象。</p>

<pre><code>#define REDIS_SHARED_INTEGERS 10000

for (j = 0; j &lt; REDIS_SHARED_INTEGERS; j++) {
    shared.integers[j] = createObject(REDIS_STRING,(void*)(long)j);
    shared.integers[j]-&gt;encoding = REDIS_ENCODING_INT;
}
</code></pre>

<h3>aeCreateEventLoop</h3>

<pre><code>initServer-&gt;aeCreateEventLoop



/* Include the best multiplexing layer supported by this system.
* The following should be ordered by performances, descending. */
#ifdef HAVE_EVPORT
    #include "ae_evport.c"
#else
    #ifdef HAVE_EPOLL
        #include "ae_epoll.c"
    #else
        #ifdef HAVE_KQUEUE
            #include "ae_kqueue.c"
        #else
            #include "ae_select.c"
        #endif
    #endif
#endif
</code></pre>

<p>接下来创建eventloop。这里调用 aeApiCreate 创建event loop。redis这里根据不同平台会选择不同的event方式，
Linux 使用epoll，BSD上面使用kqueue，其他选择select</p>

<h3>初始化网络连接</h3>

<pre><code>if (server.port != 0) {
    server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);
    if (server.ipfd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening port %d: %s",
            server.port, server.neterr);
        exit(1);
    }
}

if (server.unixsocket != NULL) {
    unlink(server.unixsocket); /* don't care if this fails */
    server.sofd = anetUnixServer(server.neterr,server.unixsocket,server.unixsocketperm);
    if (server.sofd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening socket: %s", server.neterr);
        exit(1);
    }
}
</code></pre>

<h3>创建系统cron定时器</h3>

<pre><code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);

aeCreateTimeEvent
aeCreateTimeEvent accepts the following as parameters:
eventLoop: This is server.el in redis.c
milliseconds: The number of milliseconds from the current time after which the timer expires.
proc: Function pointer. Stores the address of the function that has to be called after the timer expires.
clientData: Mostly NULL.
finalizerProc: Pointer to the function that has to be called before the timed event is removed from the list of timed events.
</code></pre>

<p>aeCreateTimeEvent 创建一个定时器，redis会在这个serverCron中清理系统变量，判断是否需要写入文件等操作。</p>

<h3>在event loop中绑定回调函数</h3>

<pre><code>if (server.ipfd &gt; 0 &amp;&amp; aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,
    acceptTcpHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.ipfd file event.");            
</code></pre>

<h1>设置启动event loop</h1>

<pre><code>// 设置事件执行前要运行的函数
aeSetBeforeSleepProc(server.el,beforeSleep);

// 启动服务器循环
aeMain(server.el);

// 关闭服务器，删除事件
aeDeleteEventLoop(server.el);
</code></pre>

<p>aeMain函数和之前用的很多的windows中的message queue非常相似。redis不断循环等待执行event。这里不论是定时器还是socket event，都会在这个event loop中被执行。</p>

<pre><code>void aeMain(aeEventLoop *eventLoop) {

eventLoop-&gt;stop = 0;

while (!eventLoop-&gt;stop) {

    // 如果有需要在事件处理前执行的函数，那么运行它
    if (eventLoop-&gt;beforesleep != NULL)
        eventLoop-&gt;beforesleep(eventLoop);

    // 开始处理事件
    aeProcessEvents(eventLoop, AE_ALL_EVENTS);
    }
}
</code></pre>

<p>方便整理，这里重复一下一开始的流程图</p>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<h1>处理客户端命令流程</h1>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/request-response.png" alt="处理客户端命令流程图" /></p>

<p>之前我们已经注册了socket acceptTcpHandler 回调函数，现在的流程是</p>

<pre><code>acceptTcpHandler-&gt;acceptCommonHandler-&gt;createClient-&gt;aeCreateFileEvent

if (aeCreateFileEvent(server.el, c-&gt;fd, AE_READABLE,
    readQueryFromClient, c) == AE_ERR) {
    freeClient(c);
    return NULL;
}
</code></pre>

<p>这里又向event loop中加入一个新的事件callback函数：aeCreateFileEvent 用于把event loop中的监听的事件和回调函数绑定在一起。</p>

<p>readQueryFromClient 则是客户端一切命令的入口函数。</p>

<pre><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
    redisClient *c = (redisClient*) privdata;
    char buf[REDIS_IOBUF_LEN];
    int nread;
    // ...

    nread = read(fd, buf, REDIS_IOBUF_LEN);
    // ...
    if (nread) {
        size_t oldlen = sdslen(c-&gt;querybuf);
        c-&gt;querybuf = sdscatlen(c-&gt;querybuf, buf, nread);
        c-&gt;lastinteraction = time(NULL);
        /* Scan this new piece of the query for the newline. We do this
        * here in order to make sure we perform this scan just one time
        * per piece of buffer, leading to an O(N) scan instead of O(N*N) */
        if (c-&gt;bulklen == -1 &amp;&amp; c-&gt;newline == NULL)
            c-&gt;newline = strchr(c-&gt;querybuf+oldlen,'\n');
    } else {
        return;
    }
    Processinputbuffer(c);
}
</code></pre>

<p> readQueryFromClient读取客户端命令，交给Processinputbuffer处理。</p>

<pre><code>void processInputBuffer(redisClient *c) {
    //...

    if (processCommand(c) == REDIS_OK)
        resetClient(c);
}

int processCommand(redisClient *c) {
    //...
    call(c,REDIS_CALL_FULL);
}
</code></pre>

<p>这里call回根据command定义的callback函数，执行相对应的redis命令代码。</p>

<p>当command执行完毕之后，准备将结果传递给客户端。这里可以看到注册了sendReplyToClient回调函数。</p>

<pre><code>int prepareClientToWrite(redisClient *c) {
    if (c-&gt;flags &amp; REDIS_LUA_CLIENT) return REDIS_OK;
    if (c-&gt;fd &lt;= 0) return REDIS_ERR; /* Fake client */
    if (c-&gt;bufpos == 0 &amp;&amp; listLength(c-&gt;reply) == 0 &amp;&amp;
        (c-&gt;replstate == REDIS_REPL_NONE || c-&gt;replstate == REDIS_REPL_ONLINE) &amp;&amp;
        aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR)
            return REDIS_ERR;
    return REDIS_OK;
}
</code></pre>

<p>读到这里，我们已经看到了。redis在处理event loop的时候，不仅仅是处理客户端的连接，很多redis内部的流程也是通过event loop实现的。这个是event driven常常遇到的方式。</p>

<p>内容资料、图片、代码参考</p>

<ul>
<li><a href="https://github.com/huangz1990/annotated_redis_source">huangz的redis2.6代码注释</a></li>
<li><a href="http://pauladamsmith.com/articles/redis-under-the-hood.html#back-up-to-main">Redis: under the hood</a></li>
<li><a href="http://redis.io/topics/internals-rediseventlib">Redis Event Library</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box2d 05 RevoluteJoint and b2WeldJoint]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/08/box2d-05/"/>
    <updated>2013-08-08T15:11:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/08/box2d-05</id>
    <content type="html"><![CDATA[<p>资料代码，思路来自 <a href="http://www.raywenderlich.com/4756/how-to-make-a-catapult-shooting-game-with-cocos2d-and-box2d-part-1">raywenderlich</a>。这个只是自己学习时的笔记，非原创。</p>

<h1>b2RevoluteJoint</h1>

<ul>
<li>将刚体固定在一个点上，刚体可以围绕这个点旋转</li>
<li>可以提供马达，提供刚体旋转的动力</li>
</ul>


<p>所以，通过b2RevoluteJoint的第一个特性，我们可以很方便的模拟跷跷板。而第二个特性，我们可以很方便的实现汽车运动，或是弹弓类似的东西，今天实现一个类似疯狂小鸟的demo</p>

<p>创建b2RevoluteJoint很简单，但是里面有一些属性还是让人比较纠结，特别是好多中文blog，不知道是笔误还是无心，都是错的 =, =!</p>

<pre><code>b2RevoluteJointDef armJointDef;
armJointDef.Initialize(groundBody, armBody, b2Vec2(233.0 / PTM_RATIO, FLOOR_HEIGHT / PTM_RATIO));

armJointDef.enableLimit = true;
armJointDef.lowerAngle = CC_DEGREES_TO_RADIANS(9);
armJointDef.upperAngle = CC_DEGREES_TO_RADIANS(75);

armJointDef.enableMotor = true;
armJointDef.maxMotorTorque = 200;
armJointDef.motorSpeed = - 10;

armJoint = (b2RevoluteJoint *)world-&gt;CreateJoint(&amp;armJointDef);
</code></pre>

<p>这3个很好理解，就是对我们的旋转做限制。单位是弧度。</p>

<ul>
<li>enableLimit</li>
<li>lowerAngle</li>
<li>upperAngle</li>
</ul>


<p>这3个稍微不好理解</p>

<ul>
<li>enableMotor：     表示是否开启我们的旋转马达</li>
<li>motorSpeed：      表示我们希望马达给我们提供的速度是多少，小于0表示顺时针</li>
<li>maxMotorTorque：  表示马达给我们提供的扭矩有多少。</li>
</ul>


<p>简单的说，就是maxMotorTorque为我们提供改变速度的力。motorSpeed表示我们希望达到的最大速度是多少。</p>

<h1>b2WeldJoint</h1>

<p>b2WeldJoint又是一个很好理解的连接器。b2WeldJoint通过一个点把2个刚体绑定在一起运动。</p>

<pre><code>b2WeldJointDef weldJointDef;
weldJointDef.Initialize(bulletBody, armBody, b2Vec2(230.0f/PTM_RATIO,(155.0f+FLOOR_HEIGHT)/PTM_RATIO));
weldJointDef.collideConnected = false;

bulletJoint = (b2WeldJoint*)world-&gt;CreateJoint(&amp;weldJointDef);
</code></pre>

<p>在弹弓实例下，我们可以将炮弹绑定在我们的发射架上，当发射架运动到一定角度时，我们可以释放这个连接器，炮弹就可以射出了。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/05">source code</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTkzMzI0ODAw" frameborder=0 allowfullscreen></iframe>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跳跃表 skip list]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/08/skip-list/"/>
    <updated>2013-08-08T09:51:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/08/skip-list</id>
    <content type="html"><![CDATA[<p>最近在学习<a href="http://redis.cn">redis</a>，这时才知道了<a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>，结合<a href="http://v.163.com/movie/2010/12/7/S/M6UTT5U0I_M6V2TTJ7S.html">Mit 算法导论 lecture 12</a>，在奋斗了2个早上的时间后有了下面的东东。</p>

<p>对于我们熟悉的binary search来说，我们需要能够做到random access才行。但是在普通的link这种数据结构中却不能做到。而这种情况下我们有很多类似的工具比如heap，tree，b tree，red－black tree。等等类似的都是来自AVL的变种。但是说实话，这些东东，的确是挺难实现的，需要做各种的旋转啊，调整啊，来保持平衡。特别是red－black tree。而这时的skip list 就为我们提供了一个很好的思路。</p>

<h1>introduction</h1>

<p>让我们先从简单的开始</p>

<p><img src="http://studentdeng.github.io/images/skip_list1.png" alt="image" /></p>

<p>如果最下面的数字是已经排序好的数列，我们想要快速查找其中一项，而不是简单的便利。我们可以增加一个link，也就是上面的一条，来让我们能够“跳过”一些元素，也就是减少一些不必要的比较。</p>

<p>那么在2条时，我们的访问程度是多少呢？L2 + L1 / L2, 也就是第二条link的个数+ 每一个小端个数，这个是最差情况。显然，让这个不等式和最小，需要 L2 = L1 / L2。 显然L1是一个定值。这里设为N,那么，2条link下，我们的查找复杂度是 2 * √n</p>

<p>如何再优化呢？这个思路很简单，就是在L2上面再构建一个link L3. 整个时间也就是 L3 ＋ L2 ／ L3 ＋ L1 ／ L2 ，根据不等式性质，他们的和最小时，也就是 L3 ＝ L2 ／ L3 ＝ L1 ／ L2。当L1 ＝ N时，他们的和时 3 * 立方根（N）</p>

<p><img src="http://studentdeng.github.io/images/skip_list_l3.png" alt="image" /></p>

<p>当第k层时， 我们的时间则是 k * k次方跟（N）</p>

<p>当k = lgN 时，我们的时间为 lgN * lg 次方跟（N），根据对数的换底公式，我们可以得出 时间是 2lgN. 哈，我们现在已经降到O(lgN).我们满足了。</p>

<p>这时我们可以想象一下，这个skip list的结构，其实就是一个binary tree。我们通过最上面的一层访问类似跟节点的情况，然后一层层link 相当于tree的孩子节点，整个比较过程和binary search 非常的相似。</p>

<h1>insert</h1>

<p>对于这些结构来说，搞定search不是难点，插入和删除则是最麻烦的东西。这里我们可以自己思考一下，为了保证我们的link的结构足够完美，可能需要记录没一段的个数，然后我们可能有一些节点要上几层或是下几层。但是这个其实，本质上和那些avl树又一样了。skip list则是基于一种随机的策略来决定这些节点。其实我们可以思考一下，最完美的分法就是和binary tree一样的，所以这种2倍数的关系就可以用抛硬币的方式来决定。</p>

<p>这里为了程序时间方便，我们创建一个无穷小的节点作为我们的其实节点，这样，我们所有的开始都是从最左边。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_01.png" alt="image" /></p>

<p>我们插入一个元素30，这时我们可以判断一下这个新的元素是否需要“升级”，这里我扔了一下，反面，不用升级了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_02.png" alt="image" /></p>

<p>这里我们插入一个15，我扔了一下，反面。不用升级</p>

<p><img src="http://studentdeng.github.io/images/skip_list_03.png" alt="image" /></p>

<p>这里我们插入一个20，我扔了一个正面，又扔了一个正面，额，好吧第三次终于是反面了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_04.png" alt="image" /></p>

<p>这里涉及到了一点点的随机算法的证明，这些东西实在是让人烦躁。主要还是大学时候的概率学得就不咋地，现在也都忘了。从最直观的来看，就是一层层升级的概率会越来越低，在随机算法足够独立和大量的数目上来看，不难形成这样子的一个类似tree的结构。</p>

<h1>delete</h1>

<p>删除这里的操作简直就是blazingly simple,因为我们整个list layer 都是建立在随机上的，删除则是直接删除就好了</p>

<p>我在看到这里，基本已经受不了要吐槽了。实现这个也太简单了，相对red-black tree这种东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stanford 算法课上 Kosaraju algorithm]]></title>
    <link href="http://studentdeng.github.com/blog/2013/08/04/algorithms-class4/"/>
    <updated>2013-08-04T23:32:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/08/04/algorithms-class4</id>
    <content type="html"><![CDATA[<p>强连通图的应用场景我就不在这里赘述了。其中<a href="http://en.wikipedia.org/wiki/Kosaraju's_algorithm">Kosaraju</a>是最常见的一种。</p>

<p>这个也是Stanford 算法课<a href="https://class.coursera.org/algo-004/quiz/attempt?quiz_id=57">弟四周的作业</a>，现在看来是最难的一道题。那么这里我就给一个我自己的实现了。</p>

<p>这个作业的难度就在于他的输入是一个相当大的数据，处理不好，很容易溢出。那份大数据，我没有留在这里，感兴趣的同学可以自己下载。70多M，实在不适合放在github上面。</p>

<p><a href="https://github.com/studentdeng/algorithms_class">source_code</a></p>

<p>由于是xcode的环境，在g++下是过不去的。。。</p>
]]></content>
  </entry>
  
</feed>
