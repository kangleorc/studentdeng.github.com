
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hash - studentdeng Blog</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="在应用程序中，常常需要将一个集合U（键值集合）和另一个集合T（数据集合）建立关系构造dictionary结构，来达到增删查改的需求。如果键值集合很小，那么可以直接采用Direct-address tables的方式实现。 假如我们的集合 U = {0, 1, &#8230;, m - 1}, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com/blog/2011/08/26/hash/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="studentdeng Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">studentdeng Blog</a></h1>
  
    <h2>不会开机的男孩</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Hash</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-26T23:28:00+08:00" pubdate data-updated="true">Aug 26<span>th</span>, 2011</time>
        

        
      | <a href="#comments">Comments</a>
        

      </p>
    
  </header>


<div class="entry-content"><p>在应用程序中，常常需要将一个集合U（键值集合）和另一个集合T（数据集合）建立关系构造dictionary结构，来达到增删查改的需求。如果键值集合很小，那么可以直接采用Direct-address tables的方式实现。</p>

<p>假如我们的集合 U = {0, 1, &#8230;, m - 1}, 而且m并不大。如果我们的键和值对应唯一，那么我们可以通过构造一个大的数组来保存集合U，如下结构。</p>

<p><img src="/images/hash-1.png" alt="alt text" /></p>

<p>显然，当集合U增大，那么直接存储集合U变的不那么明智起来，而且，如果使用键的集合K变小是，我们浪费的空间也越来越大。当集合K比集合U小很多的时候，就是hash粉墨登场的时候了。hash将保存空间压缩到集合K的大小，并且控制查找元素的时间仍在O(1) 在平均情况下。</p>

<p>hash 通过hash函数h，将集合U 映射到hash表T[0,…, m-1]中， 即 h : U → {0, 1, &#8230;, m - 1}。显然，由于集合大小的限制，很可能造成有相同的key 指向了hash表中的同一项，如图。</p>

<p><img src="/images/hash-2.png" alt="alt text" /></p>

<p>我们将这一情况称为碰撞（Collision），解决碰撞的方法很多，最容易想到的是通过链表来保存碰撞的key。</p>

<p><img src="/images/hash-3.png" alt="alt text" /></p>

<p>一个简单的例子，linux2.4 在处理进程中，需要一个通过pid找到进程的要求，而具体实现则是利用了hash。在处理冲突时，采用的是链表的方法。不过由于是操作系统的代码，所以这里并不是通常意义的双向链表，pidhash_next 指向后一个进程，但是pidhash_pprev指向的是前一个进程的pidhash_next的地址。虽然不长，但是理解这段还是需要稍微动下脑筋，系统之所以这么实现，似乎是能够提高增加和删除时链表的效率。</p>

<p>/<em> PID hashing. (shouldnt this be dynamic?) </em>/</p>

<h1>define PIDHASH_SZ (4096 >> 2)</h1>

<p>extern struct task_struct *pidhash[PIDHASH_SZ];</p>

<h1>define pid_hashfn(x) ((((x) >> 8) ^ (x)) &amp; (PIDHASH_SZ - 1))</h1>

<p>static inline void hash_pid(struct task_struct *p)
{</p>

<pre><code>struct task_struct **htable = &amp;pidhash[pid_hashfn(p-&gt;pid)]; 
if((p-&gt;pidhash_next = *htable) != NULL)//如果发生的冲突 
    (*htable)-&gt;pidhash_pprev = &amp;p-&gt;pidhash_next;//这里可以看出，pprev是上一个进程的next指针的地址 
*htable = p; 
p-&gt;pidhash_pprev = htable;//新的进程的pprev是指向了hash表项中的自己的地址 
</code></pre>

<p>}
static inline void unhash_pid(struct task_struct *p)
{</p>

<pre><code>if(p-&gt;pidhash_next)//如果有冲突 
    p-&gt;pidhash_next-&gt;pidhash_pprev = p-&gt;pidhash_pprev; 
*p-&gt;pidhash_pprev = p-&gt;pidhash_next;//当没有冲突时，就会置NULL 
</code></pre>

<p>}
static inline struct task_struct *find_task_by_pid(int pid)
{</p>

<pre><code>struct task_struct *p, **htable = &amp;pidhash[pid_hashfn(pid)]; 
for(p = *htable; p &amp;&amp; p-&gt;pid != pid; p = p-&gt;pidhash_next); 
return p; 
</code></pre>

<p>}
SGI STL的例子 hash</p>

<p>SGI STL中的hashtable 同样采用的是开链法设计，这里就是hashtable中节点的样子</p>

<p>template <class _Val>
struct <em>Hashtable_node
{
  </em>Hashtable_node* <em>M_next;
  </em>Val _M_val;
};</p>

<p>这里可以看出，hashtable并没有利用现有的list等容器，而是自己简单的创建一个单向链表并维护。由于hashtable中的每一项元素都是一连串的数据（处理冲突而在一个链表中），所以将hashtable中的元素成为bucket，表示这个元素其实可能有“一桶子”东西，最后hashtable通过vector管理bucket，实现动态增长。</p>

<p>同之前一样，首先从iterator开始了解。下面是hashtable的iterator实现。</p>

<p>template &lt;class <em>Val, class </em>Key, class _HashFcn,</p>

<pre><code>      class _ExtractKey, class _EqualKey, class _Alloc&gt;
</code></pre>

<p>struct <em>Hashtable_iterator {
  typedef hashtable&lt;</em>Val,<em>Key,</em>HashFcn,<em>ExtractKey,</em>EqualKey,_Alloc></p>

<pre><code>      _Hashtable;
</code></pre>

<p>  typedef <em>Hashtable_iterator&lt;</em>Val, <em>Key, </em>HashFcn,</p>

<pre><code>                          _ExtractKey, _EqualKey, _Alloc&gt;
      iterator;
</code></pre>

<p>  typedef <em>Hashtable_const_iterator&lt;</em>Val, <em>Key, </em>HashFcn,</p>

<pre><code>                                _ExtractKey, _EqualKey, _Alloc&gt;
      const_iterator;
</code></pre>

<p>  typedef <em>Hashtable_node<_Val> </em>Node;
  typedef forward_iterator_tag iterator_category;
  typedef <em>Val value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef </em>Val&amp; reference;
  typedef <em>Val* pointer;
  </em>Node<em> <em>M_cur;         //指向当前的节点
  </em>Hashtable</em> <em>M_ht;     //指向hashtable容器
  </em>Hashtable_iterator(<em>Node* __n, </em>Hashtable* __tab)</p>

<pre><code>: _M_cur(__n), _M_ht(__tab) {}
</code></pre>

<p>  <em>Hashtable_iterator() {}
  reference operator*() const { return </em>M_cur->_M_val; }</p>

<h1>ifndef __SGI_STL_NO_ARROW_OPERATOR</h1>

<p>  pointer operator->() const { return &amp;(operator*()); }</p>

<h1>endif /<em> __SGI_STL_NO_ARROW_OPERATOR </em>/</h1>

<p>  iterator&amp; operator++();
  iterator operator++(int);
  bool operator==(const iterator&amp; __it) const</p>

<pre><code>{ return _M_cur == __it._M_cur; }
</code></pre>

<p>  bool operator!=(const iterator&amp; __it) const</p>

<pre><code>{ return _M_cur != __it._M_cur; }
</code></pre>

<p>};
可以看出，这里的迭代器设计成只能向后移动，在operator ++ 中，我们可以看到迭代器的移动。</p>

<p>template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
class _All>
<em>Hashtable_iterator&lt;</em>Val,<em>Key,</em>HF,<em>ExK,</em>EqK,<em>All>&amp;
</em>Hashtable_iterator&lt;<em>Val,</em>Key,<em>HF,</em>ExK,<em>EqK,</em>All>::operator++()
{</p>

<pre><code>const _Node* __old = _M_cur;
_M_cur = _M_cur-&gt;_M_next;
if (!_M_cur) {
    size_type __bucket = _M_ht-&gt;_M_bkt_num(__old-&gt;_M_val);
    while (!_M_cur &amp;&amp; ++__bucket &lt; _M_ht-&gt;_M_buckets.size())
       _M_cur = _M_ht-&gt;_M_buckets[__bucket];
 }
 return *this;
</code></pre>

<p>}
首先在链表（一个bucket）中寻找下一个节点，如果是链表中的最后一个节点，那么寻找下一个链表（bucket）中的节点。了解迭代器之后，开始了解容器本身。</p>

<p>之前可以看出，SGI STL 虽然采用的是开链法，但是在分配空间大小时，依然采用的是质数，这一点和.net framework 中的dictionary一样。大小差不多是2倍</p>

<p>static const int <strong>stl_num_primes = 28;
static const unsigned long </strong>stl_prime_list[<strong>stl_num_primes] =
{
  53ul,         97ul,         193ul,       389ul,       769ul,
  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
  1610612741ul, 3221225473ul, 4294967291ul
};
//找到下一个大于n的质数，lower_bound是一个二分法查找。
inline unsigned long </strong>stl_next_prime(unsigned long <strong>n)
{
  const unsigned long* </strong>first = <strong>stl_prime_list;
  const unsigned long* </strong>last = <strong>stl_prime_list + </strong>stl_num_primes;
  const unsigned long<em> pos = lower_bound(<strong>first, </strong>last, <strong>n);
  return pos == </strong>last ? </em>(__last - 1) : *pos;
}
hashTable 中最重要的部分是扩容。那么，我们看看，SGI STL是怎么做的</p>

<p>pair&lt;iterator, bool> insert_unique(const value_type&amp; <strong>obj)
{
  resize(_M_num_elements + 1);
  return insert_unique_noresize(</strong>obj);
}</p>

<p>template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable&lt;<em>Val,</em>Key,<em>HF,</em>Ex,<em>Eq,</em>All>
  ::resize(size_type <strong>num_elements_hint)
{
  const size_type </strong>old_n = _M_buckets.size();
  if (<strong>num_elements_hint > </strong>old_n) {</p>

<pre><code>//如果需要扩容，我们找到下一个质数
const size_type __n = _M_next_size(__num_elements_hint);
if (__n &gt; __old_n) {
  //搞一个新的buckets
  vector&lt;_Node*, _All&gt; __tmp(__n, (_Node*)(0),
                             _M_buckets.get_allocator());
  __STL_TRY {
    for (size_type __bucket = 0; __bucket &lt; __old_n; ++__bucket) {
      //遍历之旧的buckets
      _Node* __first = _M_buckets[__bucket];
      while (__first) {
        //遍历旧的bucket，这里，我们根据新的大小找到了新的位置
        size_type __new_bucket = _M_bkt_num(__first-&gt;_M_val, __n);
        //将旧的bucket数据改为 我们正在处理的item的下一个 
        _M_buckets[__bucket] = __first-&gt;_M_next;
        //把我们现在处理的item 插入到新的buckets中。
        __first-&gt;_M_next = __tmp[__new_bucket];
        __tmp[__new_bucket] = __first;
        //将我们当前处理的item，修改为旧数据的下一个
        __first = _M_buckets[__bucket];          
      }
    }
    //都搞定了，我们将buckets更换。
    _M_buckets.swap(__tmp);
  }
</code></pre>

<h1>ifdef __STL_USE_EXCEPTIONS</h1>

<pre><code>  catch(...) {
    for (size_type __bucket = 0; __bucket &lt; __tmp.size(); ++__bucket) {
      while (__tmp[__bucket]) {
        _Node* __next = __tmp[__bucket]-&gt;_M_next;
        _M_delete_node(__tmp[__bucket]);
        __tmp[__bucket] = __next;
      }
    }
    throw;
  }
</code></pre>

<h1>endif /<em> __STL_USE_EXCEPTIONS </em>/</h1>

<pre><code>}
</code></pre>

<p>  }
}
当然，这个只是insert_unique ，insert_equal 类似，这里不做描述。</p>

<p>除了resize，hashtable中还有一个吸引我们的就是hash func。但是，一般我们并不会指定hash func， 那么，我们看看SGI STL 是如何选择hash 函数的。</p>

<h1>ifndef __SGI_STL_HASH_FUN_H</h1>

<h1>define __SGI_STL_HASH_FUN_H</h1>

<h1>include &lt;stddef.h></h1>

<p><strong>STL_BEGIN_NAMESPACE
template <class _Key> struct hash { };
//字符串这里看来稍微有了一些操作
inline size_t </strong>stl_hash_string(const char<em> <strong>s)
{
  unsigned long </strong>h = 0;
  for ( ; </em><strong>s; ++</strong>s)</p>

<pre><code>__h = 5*__h + *__s;
</code></pre>

<p>  return size_t(<strong>h);
}
//这些东西，通过c++ 模板偏特化实现，我们看到，这些东西，啥都没做，只是返回而已。所以，如果
//希望获得最佳的性能，实现仿函数。是非常必要的。
</strong>STL_TEMPLATE_NULL struct hash&lt;char<em>>
{
  size_t operator()(const char</em> <strong>s) const { return </strong>stl_hash_string(<strong>s); }
};
</strong>STL_TEMPLATE_NULL struct hash<const char*>
{
  size_t operator()(const char* <strong>s) const { return </strong>stl_hash_string(<strong>s); }
};
</strong>STL_TEMPLATE_NULL struct hash<char> {
  size_t operator()(char <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<unsigned char> {
  size_t operator()(unsigned char </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<signed char> {
  size_t operator()(unsigned char <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<short> {
  size_t operator()(short </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned short> {
  size_t operator()(unsigned short <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<int> {
  size_t operator()(int </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned int> {
  size_t operator()(unsigned int <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<long> {
  size_t operator()(long </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned long> {
  size_t operator()(unsigned long <strong>x) const { return </strong>x; }
};
SQLite 的hash表。</p>

<p>SQLite是在移动设备上普遍的一个家伙， 他用到了2种HASH， 一种和上面的SGI STL 类似，在PC端，在做增加的时候，判断了数据量大小（一般10个），如果小于，则采用双向链表的方式，不是则采用hash存储。只是，在移动分支中我没有找到，PC端的确有这样的设计，也许在mobile上做了精简。这种hash，用于SQLite底层的内存管理，缓存部分，SQLite采用的是LRU的方式缓存。</p>

<p>另一种Hash是叫做perfect hash。这是一种在最坏情况下，依然能够达到O(1) 的能力，听上去似乎挺吓人的，但是大多数是指固定的表，当然，似乎有些能够做到动态保证，不过，不管他了，我可不是科学家。</p>

<p>SQLite 的前端是需要做词法语法分析的。这部分就涉及到了关键字的保存，这里SQLite 通过perfect hash来达到快速查找。具体的策略了解编译原理的都比较明白，但是，这个的确比较有意思。</p>

<p>构造关键字是通过一个起始位置和长度来获取的。如 “REINDEX 、 INDEXED 、 INDEX 、 DESC”；将保存成“REINDEXEDESC”。那么 REINDEX = （0， 7）。而剩下的工作可以交给一些程序，他们会帮助我们生成perfect hash。</p>

<p>大数据量下，hash信息指纹的应用。可以参考 google黑板报  http://www.google.com.hk/ggblog/googlechinablog/2006/08/blog-post_8115.html</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">studentdeng</span></span>

      








  


<time datetime="2011-08-26T23:28:00+08:00" pubdate data-updated="true">Aug 26<span>th</span>, 2011</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/stl/'>STL</a>, <a class='category' href='/blog/categories/algorithms/'>algorithms</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  

  
      <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_tsina">新浪微博</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_renren">人人网</a>

<a href="http://www.jiathis.com/share?uid=1737602" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
	data_track_clickback:true,
	siteNum:5,
	sm:"renren,douban,tsina,tqq,qzone",
	summary:"",
	hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js?uid=1737602" charset="utf-8">
</script>
<!-- JiaThis Button END -->

  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2011/03/31/sendthreadmessage/" title="Previous Post: 为什么没有SendThreadMessage呢？">&laquo; 为什么没有SendThreadMessage呢？</a>
      
      
        <a class="basic-alignment right" href="/blog/2011/10/05/objcclass/" title="Next Post: objcclass">objcclass &raquo;</a>
      
    </p>
  </footer>
</article>



  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"studentdeng"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->
</div>
  </section>


</div>

<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/ios/'>IOS (1)</a></li>
<li class='category'><a href='/blog/categories/objective-c/'>Objective-C (6)</a></li>
<li class='category'><a href='/blog/categories/stl/'>STL (5)</a></li>
<li class='category'><a href='/blog/categories/wpf-sl/'>WPF/SL (1)</a></li>
<li class='category'><a href='/blog/categories/algorithms/'>algorithms (8)</a></li>
<li class='category'><a href='/blog/categories/asm/'>asm (1)</a></li>
<li class='category'><a href='/blog/categories/c-/'>c++ (6)</a></li>
<li class='category'><a href='/blog/categories/configure/'>configure (2)</a></li>
<li class='category'><a href='/blog/categories/emotion/'>emotion (7)</a></li>
<li class='category'><a href='/blog/categories/operating-system/'>operating_system (3)</a></li>
<li class='category'><a href='/blog/categories/tips/'>tips (1)</a></li>
<li class='category'><a href='/blog/categories/windows/'>windows (9)</a></li>
<li class='category'><a href='/blog/categories/windows-mobile/'>windows_mobile (2)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/03/03/selfos/">Orange‘s 一个操作系统的实现 配置问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/03/arc/">ARC 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/26/tips/">tips</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/15/happiness/">哈佛幸福课 杂感一</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/14/bochs-configure/">bochs-configure</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/03/objblock/">Objective-C block</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/13/plan/">plan</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/13/knownless/">转 从无知到有知</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/12/objcbase/">Objective-C 一些很基础的总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/10/16/objcsel/">Objective C SEL</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/studentdeng">@studentdeng</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'studentdeng',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





<section>
<h1>Recent Comments</h1>
<ul class="ds-recent-comments" data-num-items="10" data-show-avatars="0" data-show-time="0" data-show-title="0" data-show-admin="0" data-excerpt-length="18"></ul>

</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
