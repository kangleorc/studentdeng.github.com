
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不会开机的男孩</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="让我们从 redis.c -> main() 开始 读取配置文件 在初始化完毕一些系统时间之后，redis开始初始化服务器配置。 initServerConfig 在这个函数中，初始化全局变量 struct redisServer server; /* server global state &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com/blog/page/4">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="不会开机的男孩" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">不会开机的男孩</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  	<li><a href="/">Blog</a></li>
  	<li><a href="/blog/archives">Archives</a></li>
	 <li><a href="/tags/index.html">Tags</a></li>
	<li><a href="/favorite/index.html">Favorite</a></li>
	<li><a href="/about/index.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/19/redis-start-up/">Redis服务器启动流程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-19T10:26:00+08:00" pubdate data-updated="true">Aug 19<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/19/redis-start-up/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<p>让我们从 redis.c -> main() 开始</p>

<h1>读取配置文件</h1>

<p>在初始化完毕一些系统时间之后，redis开始初始化服务器配置。</p>

<h2>initServerConfig</h2>

<p>在这个函数中，初始化全局变量</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>struct redisServer 结构体描述了服务器的状态。这种庞大的数据结构实在是看的烦躁。
这里可以很方便的看到redis的系统默认配置。另外还初始化了系统命令表。</p>

<pre><code>server.commands = dictCreate(&amp;commandTableDictType,NULL);
populateCommandTable();
</code></pre>

<p>这里我们可以找到redis的命令所对应的函数名称。</p>

<pre><code>struct redisCommand redisCommandTable[] = {
    {"get",getCommand,2,"r",0,NULL,1,1,1,0,0},
    {"set",setCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setnx",setnxCommand,3,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"setex",setexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"psetex",psetexCommand,4,"wm",0,noPreloadGetKeys,1,1,1,0,0},
    {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
    //...
}


struct redisCommand {
    // 命令的名字
    char *name;
    // 命令的实现函数
    redisCommandProc *proc;
    // 命令所需的参数数量
    int arity;
    // 字符形式表示的 FLAG 值
    char *sflags; /* Flags as string represenation, one char per flag. */
    // 实际的 FLAG 值，由 sflags 计算得出
    int flags;    /* The actual flags, obtained from the 'sflags' field. */
    /* Use a function to determine keys arguments in a command line.
     * Used for Redis Cluster redirect. */
    // 可选，在以下三个参数不足以决定命令的 key 参数时使用
    redisGetKeysProc *getkeys_proc;
    /* What keys should be loaded in background when calling this command? */
    // 第一个 key 的位置
    int firstkey; /* The first argument that's a key (0 = no keys) */
    // 第二个 key 的位置
    int lastkey;  /* THe last argument that's a key */
    // 两个 key 之间的空隔
    int keystep;  /* The step between first and last key */
    // 这个命令被执行所耗费的总毫秒数
    long long microseconds;
    // 这个命令被调用的总次数
    long long calls;
};
</code></pre>

<p>这里可以看出，redis的命令配置，保存在底层数据结构dic中。</p>

<h1>服务器初始化</h1>

<h2>initServer</h2>

<p>这里设置信号回调函数，和继续初始化</p>

<pre><code>struct redisServer server; /* server global state */
</code></pre>

<p>结构外，创建了SharedObjects。</p>

<h3>createSharedObjects</h3>

<pre><code>initServer-&gt;createSharedObjects
</code></pre>

<p>redis这里将除了把一些常用的字符串保存起来，目的就是为了减少不断申请释放时CPU时间，内存碎片等等,常用的返回客户端的命令，消息等。如</p>

<pre><code>shared.ok = createObject(REDIS_STRING,sdsnew("+OK\r\n"));
shared.err = createObject(REDIS_STRING,sdsnew("-ERR\r\n"));

//...

shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(
    "-WRONGTYPE Operation against a key holding the wrong kind of value\r\n"));
//...
</code></pre>

<p>还初始化了一个很大的共享数字对象。</p>

<pre><code>#define REDIS_SHARED_INTEGERS 10000

for (j = 0; j &lt; REDIS_SHARED_INTEGERS; j++) {
    shared.integers[j] = createObject(REDIS_STRING,(void*)(long)j);
    shared.integers[j]-&gt;encoding = REDIS_ENCODING_INT;
}
</code></pre>

<h3>aeCreateEventLoop</h3>

<pre><code>initServer-&gt;aeCreateEventLoop



/* Include the best multiplexing layer supported by this system.
* The following should be ordered by performances, descending. */
#ifdef HAVE_EVPORT
    #include "ae_evport.c"
#else
    #ifdef HAVE_EPOLL
        #include "ae_epoll.c"
    #else
        #ifdef HAVE_KQUEUE
            #include "ae_kqueue.c"
        #else
            #include "ae_select.c"
        #endif
    #endif
#endif
</code></pre>

<p>接下来创建eventloop。这里调用 aeApiCreate 创建event loop。redis这里根据不同平台会选择不同的event方式，
Linux 使用epoll，BSD上面使用kqueue，其他选择select</p>

<h3>初始化网络连接</h3>

<pre><code>if (server.port != 0) {
    server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);
    if (server.ipfd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening port %d: %s",
            server.port, server.neterr);
        exit(1);
    }
}

if (server.unixsocket != NULL) {
    unlink(server.unixsocket); /* don't care if this fails */
    server.sofd = anetUnixServer(server.neterr,server.unixsocket,server.unixsocketperm);
    if (server.sofd == ANET_ERR) {
        redisLog(REDIS_WARNING, "Opening socket: %s", server.neterr);
        exit(1);
    }
}
</code></pre>

<h3>创建系统cron定时器</h3>

<pre><code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);

aeCreateTimeEvent
aeCreateTimeEvent accepts the following as parameters:
eventLoop: This is server.el in redis.c
milliseconds: The number of milliseconds from the current time after which the timer expires.
proc: Function pointer. Stores the address of the function that has to be called after the timer expires.
clientData: Mostly NULL.
finalizerProc: Pointer to the function that has to be called before the timed event is removed from the list of timed events.
</code></pre>

<p>aeCreateTimeEvent 创建一个定时器，redis会在这个serverCron中清理系统变量，判断是否需要写入文件等操作。</p>

<h3>在event loop中绑定回调函数</h3>

<pre><code>if (server.ipfd &gt; 0 &amp;&amp; aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,
    acceptTcpHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.ipfd file event.");            
</code></pre>

<h1>设置启动event loop</h1>

<pre><code>// 设置事件执行前要运行的函数
aeSetBeforeSleepProc(server.el,beforeSleep);

// 启动服务器循环
aeMain(server.el);

// 关闭服务器，删除事件
aeDeleteEventLoop(server.el);
</code></pre>

<p>aeMain函数和之前用的很多的windows中的message queue非常相似。redis不断循环等待执行event。这里不论是定时器还是socket event，都会在这个event loop中被执行。</p>

<pre><code>void aeMain(aeEventLoop *eventLoop) {

eventLoop-&gt;stop = 0;

while (!eventLoop-&gt;stop) {

    // 如果有需要在事件处理前执行的函数，那么运行它
    if (eventLoop-&gt;beforesleep != NULL)
        eventLoop-&gt;beforesleep(eventLoop);

    // 开始处理事件
    aeProcessEvents(eventLoop, AE_ALL_EVENTS);
    }
}
</code></pre>

<p>方便整理，这里重复一下一开始的流程图</p>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/startup.png" alt="整个系统初始化流程图" /></p>

<h1>处理客户端命令流程</h1>

<p><img src="http://pauladamsmith.com/articles/redis_under_the_hood/request-response.png" alt="处理客户端命令流程图" /></p>

<p>之前我们已经注册了socket acceptTcpHandler 回调函数，现在的流程是</p>

<pre><code>acceptTcpHandler-&gt;acceptCommonHandler-&gt;createClient-&gt;aeCreateFileEvent

if (aeCreateFileEvent(server.el, c-&gt;fd, AE_READABLE,
    readQueryFromClient, c) == AE_ERR) {
    freeClient(c);
    return NULL;
}
</code></pre>

<p>这里又向event loop中加入一个新的事件callback函数：aeCreateFileEvent 用于把event loop中的监听的事件和回调函数绑定在一起。</p>

<p>readQueryFromClient 则是客户端一切命令的入口函数。</p>

<pre><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
    redisClient *c = (redisClient*) privdata;
    char buf[REDIS_IOBUF_LEN];
    int nread;
    // ...

    nread = read(fd, buf, REDIS_IOBUF_LEN);
    // ...
    if (nread) {
        size_t oldlen = sdslen(c-&gt;querybuf);
        c-&gt;querybuf = sdscatlen(c-&gt;querybuf, buf, nread);
        c-&gt;lastinteraction = time(NULL);
        /* Scan this new piece of the query for the newline. We do this
        * here in order to make sure we perform this scan just one time
        * per piece of buffer, leading to an O(N) scan instead of O(N*N) */
        if (c-&gt;bulklen == -1 &amp;&amp; c-&gt;newline == NULL)
            c-&gt;newline = strchr(c-&gt;querybuf+oldlen,'\n');
    } else {
        return;
    }
    Processinputbuffer(c);
}
</code></pre>

<p> readQueryFromClient读取客户端命令，交给Processinputbuffer处理。</p>

<pre><code>void processInputBuffer(redisClient *c) {
    //...

    if (processCommand(c) == REDIS_OK)
        resetClient(c);
}

int processCommand(redisClient *c) {
    //...
    call(c,REDIS_CALL_FULL);
}
</code></pre>

<p>这里call回根据command定义的callback函数，执行相对应的redis命令代码。</p>

<p>当command执行完毕之后，准备将结果传递给客户端。这里可以看到注册了sendReplyToClient回调函数。</p>

<pre><code>int prepareClientToWrite(redisClient *c) {
    if (c-&gt;flags &amp; REDIS_LUA_CLIENT) return REDIS_OK;
    if (c-&gt;fd &lt;= 0) return REDIS_ERR; /* Fake client */
    if (c-&gt;bufpos == 0 &amp;&amp; listLength(c-&gt;reply) == 0 &amp;&amp;
        (c-&gt;replstate == REDIS_REPL_NONE || c-&gt;replstate == REDIS_REPL_ONLINE) &amp;&amp;
        aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR)
            return REDIS_ERR;
    return REDIS_OK;
}
</code></pre>

<p>读到这里，我们已经看到了。redis在处理event loop的时候，不仅仅是处理客户端的连接，很多redis内部的流程也是通过event loop实现的。这个是event driven常常遇到的方式。</p>

<p>内容资料、图片、代码参考</p>

<ul>
<li><a href="https://github.com/huangz1990/annotated_redis_source">huangz的redis2.6代码注释</a></li>
<li><a href="http://pauladamsmith.com/articles/redis-under-the-hood.html#back-up-to-main">Redis: under the hood</a></li>
<li><a href="http://redis.io/topics/internals-rediseventlib">Redis Event Library</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/08/box2d-05/">Box2d 05 RevoluteJoint and b2WeldJoint</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-08T15:11:00+08:00" pubdate data-updated="true">Aug 8<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/08/box2d-05/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>资料代码，思路来自 <a href="http://www.raywenderlich.com/4756/how-to-make-a-catapult-shooting-game-with-cocos2d-and-box2d-part-1">raywenderlich</a>。这个只是自己学习时的笔记，非原创。</p>

<h1>b2RevoluteJoint</h1>

<ul>
<li>将刚体固定在一个点上，刚体可以围绕这个点旋转</li>
<li>可以提供马达，提供刚体旋转的动力</li>
</ul>


<p>所以，通过b2RevoluteJoint的第一个特性，我们可以很方便的模拟跷跷板。而第二个特性，我们可以很方便的实现汽车运动，或是弹弓类似的东西，今天实现一个类似疯狂小鸟的demo</p>

<p>创建b2RevoluteJoint很简单，但是里面有一些属性还是让人比较纠结，特别是好多中文blog，不知道是笔误还是无心，都是错的 =, =!</p>

<pre><code>b2RevoluteJointDef armJointDef;
armJointDef.Initialize(groundBody, armBody, b2Vec2(233.0 / PTM_RATIO, FLOOR_HEIGHT / PTM_RATIO));

armJointDef.enableLimit = true;
armJointDef.lowerAngle = CC_DEGREES_TO_RADIANS(9);
armJointDef.upperAngle = CC_DEGREES_TO_RADIANS(75);

armJointDef.enableMotor = true;
armJointDef.maxMotorTorque = 200;
armJointDef.motorSpeed = - 10;

armJoint = (b2RevoluteJoint *)world-&gt;CreateJoint(&amp;armJointDef);
</code></pre>

<p>这3个很好理解，就是对我们的旋转做限制。单位是弧度。</p>

<ul>
<li>enableLimit</li>
<li>lowerAngle</li>
<li>upperAngle</li>
</ul>


<p>这3个稍微不好理解</p>

<ul>
<li>enableMotor：     表示是否开启我们的旋转马达</li>
<li>motorSpeed：      表示我们希望马达给我们提供的速度是多少，小于0表示顺时针</li>
<li>maxMotorTorque：  表示马达给我们提供的扭矩有多少。</li>
</ul>


<p>简单的说，就是maxMotorTorque为我们提供改变速度的力。motorSpeed表示我们希望达到的最大速度是多少。</p>

<h1>b2WeldJoint</h1>

<p>b2WeldJoint又是一个很好理解的连接器。b2WeldJoint通过一个点把2个刚体绑定在一起运动。</p>

<pre><code>b2WeldJointDef weldJointDef;
weldJointDef.Initialize(bulletBody, armBody, b2Vec2(230.0f/PTM_RATIO,(155.0f+FLOOR_HEIGHT)/PTM_RATIO));
weldJointDef.collideConnected = false;

bulletJoint = (b2WeldJoint*)world-&gt;CreateJoint(&amp;weldJointDef);
</code></pre>

<p>在弹弓实例下，我们可以将炮弹绑定在我们的发射架上，当发射架运动到一定角度时，我们可以释放这个连接器，炮弹就可以射出了。</p>

<p><a href="https://github.com/studentdeng/box2d-tutorials/tree/master/05">source code</a></p>

<div class="video-container">
    <iframe height=498 width=510 src="http://player.youku.com/embed/XNTkzMzI0ODAw" frameborder=0 allowfullscreen></iframe>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/08/skip-list/">跳跃表 Skip List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-08T09:51:00+08:00" pubdate data-updated="true">Aug 8<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/08/skip-list/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在学习<a href="http://redis.cn">redis</a>，这时才知道了<a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>，结合<a href="http://v.163.com/movie/2010/12/7/S/M6UTT5U0I_M6V2TTJ7S.html">Mit 算法导论 lecture 12</a>，在奋斗了2个早上的时间后有了下面的东东。</p>

<p>对于我们熟悉的binary search来说，我们需要能够做到random access才行。但是在普通的link这种数据结构中却不能做到。而这种情况下我们有很多类似的工具比如heap，tree，b tree，red－black tree。等等类似的都是来自AVL的变种。但是说实话，这些东东，的确是挺难实现的，需要做各种的旋转啊，调整啊，来保持平衡。特别是red－black tree。而这时的skip list 就为我们提供了一个很好的思路。</p>

<h1>introduction</h1>

<p>让我们先从简单的开始</p>

<p><img src="http://studentdeng.github.io/images/skip_list1.png" alt="image" /></p>

<p>如果最下面的数字是已经排序好的数列，我们想要快速查找其中一项，而不是简单的便利。我们可以增加一个link，也就是上面的一条，来让我们能够“跳过”一些元素，也就是减少一些不必要的比较。</p>

<p>那么在2条时，我们的访问程度是多少呢？L2 + L1 / L2, 也就是第二条link的个数+ 每一个小端个数，这个是最差情况。显然，让这个不等式和最小，需要 L2 = L1 / L2。 显然L1是一个定值。这里设为N,那么，2条link下，我们的查找复杂度是 2 * √n</p>

<p>如何再优化呢？这个思路很简单，就是在L2上面再构建一个link L3. 整个时间也就是 L3 ＋ L2 ／ L3 ＋ L1 ／ L2 ，根据不等式性质，他们的和最小时，也就是 L3 ＝ L2 ／ L3 ＝ L1 ／ L2。当L1 ＝ N时，他们的和时 3 * 立方根（N）</p>

<p><img src="http://studentdeng.github.io/images/skip_list_l3.png" alt="image" /></p>

<p>当第k层时， 我们的时间则是 k * k次方跟（N）</p>

<p>当k = lgN 时，我们的时间为 lgN * lg 次方跟（N），根据对数的换底公式，我们可以得出 时间是 2lgN. 哈，我们现在已经降到O(lgN).我们满足了。</p>

<p>这时我们可以想象一下，这个skip list的结构，其实就是一个binary tree。我们通过最上面的一层访问类似跟节点的情况，然后一层层link 相当于tree的孩子节点，整个比较过程和binary search 非常的相似。</p>

<h1>insert</h1>

<p>对于这些结构来说，搞定search不是难点，插入和删除则是最麻烦的东西。这里我们可以自己思考一下，为了保证我们的link的结构足够完美，可能需要记录没一段的个数，然后我们可能有一些节点要上几层或是下几层。但是这个其实，本质上和那些avl树又一样了。skip list则是基于一种随机的策略来决定这些节点。其实我们可以思考一下，最完美的分法就是和binary tree一样的，所以这种2倍数的关系就可以用抛硬币的方式来决定。</p>

<p>这里为了程序时间方便，我们创建一个无穷小的节点作为我们的其实节点，这样，我们所有的开始都是从最左边。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_01.png" alt="image" /></p>

<p>我们插入一个元素30，这时我们可以判断一下这个新的元素是否需要“升级”，这里我扔了一下，反面，不用升级了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_02.png" alt="image" /></p>

<p>这里我们插入一个15，我扔了一下，反面。不用升级</p>

<p><img src="http://studentdeng.github.io/images/skip_list_03.png" alt="image" /></p>

<p>这里我们插入一个20，我扔了一个正面，又扔了一个正面，额，好吧第三次终于是反面了。</p>

<p><img src="http://studentdeng.github.io/images/skip_list_04.png" alt="image" /></p>

<p>这里涉及到了一点点的随机算法的证明，这些东西实在是让人烦躁。主要还是大学时候的概率学得就不咋地，现在也都忘了。从最直观的来看，就是一层层升级的概率会越来越低，在随机算法足够独立和大量的数目上来看，不难形成这样子的一个类似tree的结构。</p>

<h1>delete</h1>

<p>删除这里的操作简直就是blazingly simple,因为我们整个list layer 都是建立在随机上的，删除则是直接删除就好了</p>

<p>我在看到这里，基本已经受不了要吐槽了。实现这个也太简单了，相对red-black tree这种东西。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/04/algorithms-class4/">Stanford 算法课上 Kosaraju Algorithm</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-04T23:32:00+08:00" pubdate data-updated="true">Aug 4<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/04/algorithms-class4/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>强连通图的应用场景我就不在这里赘述了。其中<a href="http://en.wikipedia.org/wiki/Kosaraju's_algorithm">Kosaraju</a>是最常见的一种。</p>

<p>这个也是Stanford 算法课<a href="https://class.coursera.org/algo-004/quiz/attempt?quiz_id=57">弟四周的作业</a>，现在看来是最难的一道题。那么这里我就给一个我自己的实现了。</p>

<p>这个作业的难度就在于他的输入是一个相当大的数据，处理不好，很容易溢出。那份大数据，我没有留在这里，感兴趣的同学可以自己下载。70多M，实在不适合放在github上面。</p>

<p><a href="https://github.com/studentdeng/algorithms_class">source_code</a></p>

<p>由于是xcode的环境，在g++下是过不去的。。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/03/apache-test/">Apache 压力测试入门</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-03T13:05:00+08:00" pubdate data-updated="true">Aug 3<span>rd</span>, 2013</time>
        
         | <a href="/blog/2013/08/03/apache-test/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近一直想总结一点有关测试服务器性能的东西，今天先写一点入门的小东西了。
网站的stress test 工具很多，这里介绍一个我觉得最简单的webbench</p>

<h2>安装webbench</h2>

<pre><code>wget http://www.ha97.com/code/webbench-1.5.tar.gz
tar zxvf webbench-1.5.tar.gz
cd webbench-1.5
make
make install
</code></pre>

<h2>使用webbench</h2>

<pre><code>webbench -c 1000 -t 60 http://server_address/
</code></pre>

<p>c: 并发数， t 运行时间
下面是测试结果</p>

<pre><code>Speed=2798 pages/min, 53286 bytes/sec.
Requests: 2798 susceed, 0 failed.
</code></pre>

<p>表示 每分钟处理请求2798， 每秒钟传输量53286</p>

<h2>apache 的一点小问题</h2>

<p>前几天换了一个阿里云的服务器，最低配置。内存只有512M，在做测试的时候遇到了一点小问题，这里记录一下。
服务器使用lamp默认配置，在低配置的情况下，我发现在-c 100 的情况下 mysql 就已经crash了。</p>

<p>这里是mysql日志</p>

<pre><code>130803 13:26:40 InnoDB: Initializing buffer pool, size = 128.0M
InnoDB: mmap(137363456 bytes) failed; errno 12
130803 13:26:40 InnoDB: Completed initialization of buffer pool
130803 13:26:40 InnoDB: Fatal error: cannot allocate memory for the buffer pool
130803 13:26:40 [ERROR] Plugin 'InnoDB' init function returned error.
130803 13:26:40 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
130803 13:26:40 [ERROR] Unknown/unsupported storage engine: InnoDB
130803 13:26:40 [ERROR] Aborting
</code></pre>

<p>发现系统内存似乎已经不够用了。
用下面命令查看系统性能</p>

<pre><code>top -i

top - 13:32:45 up 4 days, 18:01,  2 users,  load average: 1.54, 9.10, 8.42
Tasks: 242 total,  74 running, 168 sleeping,   0 stopped,   0 zombie
Cpu(s): 85.1%us, 14.5%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st
Mem:    501892k total,   496672k used,     5220k free,     4000k buffers
Swap:        0k total,        0k used,        0k free,    35128k cached

PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
6527 www-data  20   0  295m  13m 3952 R  2.3  2.8   0:00.75 apache2
6531 www-data  20   0  294m  13m 3204 R  2.3  2.7   0:00.51 apache2
7439 www-data  20   0  293m  12m 3484 R  2.3  2.6   0:00.30 apache2
7441 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.21 apache2
7455 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.14 apache2
7456 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.14 apache2
7463 www-data  20   0  293m  12m 3480 R  2.3  2.6   0:00.08 apache2
7465 www-data  20   0  294m  13m 3480 R  2.3  2.7   0:00.08 apache2
7466 www-data  20   0  294m  13m 3480 R  2.3  2.7   0:00.08 apache2
6491 www-data  20   0  294m  13m 3204 R  2.0  2.7   0:00.51 apache2
6495 www-data  20   0  294m  13m 3268 R  2.0  2.7   0:00.52 apache2
6526 www-data  20   0  295m  13m 3872 R  2.0  2.9   0:00.57 apache2
6529 www-data  20   0  294m  13m 3212 R  2.0  2.7   0:00.48 apache2
6536 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.48 apache2
6537 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.47 apache2
6538 www-data  20   0  294m  13m 3244 R  2.0  2.7   0:00.48 apache2
7442 www-data  20   0  293m  12m 3484 R  2.0  2.6   0:00.21 apache2
7458 www-data  20   0  293m  12m 3476 R  2.0  2.6   0:00.13 apache2
7464 www-data  20   0  294m  12m 3480 R  2.0  2.6   0:00.08 apache2
7467 www-data  20   0  294m  13m 3480 R  2.0  2.7   0:00.08 apache2
7468 www-data  20   0  294m  12m 3480 R  2.0  2.6   0:00.08 apache2
6528 www-data  20   0  295m  13m 3884 R  1.7  2.8   0:00.62 apache2
7457 www-data  20   0  293m  12m 3480 R  1.7  2.6   0:00.13 apache2
7469 www-data  20   0  294m  13m 3480 R  1.7  2.7   0:00.07 apache2
7470 www-data  20   0  294m  13m 3480 R  1.7  2.7   0:00.07 apache2
7492 www-data  20   0  293m  12m 3484 R  1.7  2.6   0:00.05 apache2
7484 www-data  20   0  293m  12m 3484 R  1.3  2.6   0:00.04 apache2
…
</code></pre>

<p>一下子看到好多的apache procress，让我大吃一惊。。。可见我有多弱了。。。原来每一个http请求，apache都开了一个进程来处理，而一个进程需要13M的物理内存。 而这一台服务器总共物理内存只有512M</p>

<h2>apache 的工作模式</h2>

<p>apache 的工作模式有几种，我们可以通过下面命令查看</p>

<pre><code>apachectl -l

Compiled in modules:
core.c
mod_log_config.c
mod_logio.c
prefork.c
http_core.c
mod_so.c
</code></pre>

<p>这个表明我们在prefork工作模式下，也是最稳定用的最多的工作模式。
在这个模式下每一个用户的请求都会交给一个进程来处理，但是频繁的创建和销毁进程这种重量级操作降低不少系统性能，所以我们可以通过设置一些参数。但不管怎么样，都是一个请求一个进程。当进程数收到限制时，请求只能等待。而最大的请求书，显然受到系统硬件限制。</p>

<p>我们可以在查看默认配置</p>

<pre><code># prefork MPM
# StartServers: number of server processes to start
# MinSpareServers: minimum number of server processes which are kept spare
# MaxSpareServers: maximum number of server processes which are kept spare
# MaxClients: maximum number of server processes allowed to start
# MaxRequestsPerChild: maximum number of requests a server process serves
&lt;IfModule mpm_prefork_module&gt;
    StartServers          5
    MinSpareServers       5
    MaxSpareServers      10
    MaxClients           150
    MaxRequestsPerChild   0
&lt;/IfModule&gt;
</code></pre>

<p>这个已经说的很清楚了，对于现在的服务器配置，尝试MaxClients 修改成 40</p>

<p>再次查看系统性能</p>

<pre><code>top - 13:44:13 up 4 days, 18:12,  2 users,  load average: 12.10, 6.50, 8.88
Tasks: 209 total,  41 running, 168 sleeping,   0 stopped,   0 zombie
Cpu(s): 91.7%us,  7.9%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st
Mem:    501892k total,   399804k used,   102088k free,     6936k buffers
Swap:        0k total,        0k used,        0k free,    71048k cached 
</code></pre>

<p>这是-c 100 已经没有问题了。</p>

<pre><code>Speed=2780 pages/min, 52868 bytes/sec.
Requests: 2780 susceed, 0 failed.
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/5/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/3/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'studentdeng';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>
