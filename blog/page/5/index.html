
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不会开机的男孩</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="这篇文章投稿在 伯乐在线 原文出处: objc View Controller Transitions Issue #5 iOS 7, October 2013 作者 Chris Eidhof 自定义动画 iOS7对我来说最激动人心的特性就是新的 View Controller &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com/blog/page/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="不会开机的男孩" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/jquery.min1.9.1.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">不会开机的男孩</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  	<li><a href="/">Blog</a></li>
  	<li><a href="/blog/archives">Archives</a></li>
	 <li><a href="/tags/index.html">Tags</a></li>
	<li><a href="/favorite/index.html">Favorite</a></li>
	<li><a href="/about/index.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/19/ios7-viewcontroller/">翻译：《iOS7 新功能 视图控制器API》</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-19T18:12:00+08:00" pubdate data-updated="true">Nov 19<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/11/19/ios7-viewcontroller/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇文章投稿在 <a href="http://blog.jobbole.com/51588/">伯乐在线</a></p>

<p>原文出处: <a href="http://www.objc.io/issue-5/view-controller-transitions.html">objc</a></p>

<h1>View Controller Transitions</h1>

<p><a href="http://www.objc.io/issue-5/index.html">Issue #5 iOS 7</a>, October 2013</p>

<p>作者 <a href="http://twitter.com/chriseidhof">Chris Eidhof</a></p>

<h1>自定义动画</h1>

<p>iOS7对我来说最激动人心的特性就是新的 View Controller Transitioning API。 iOS7之前，View Controller之间切换，我需要创建自定义的transitions。 而且这些方法都支持不完整，让人头疼。在transitions中增加交互功能就更难了。</p>

<p>在开始这篇文章之前，我要提醒一下：这是一个新的API，我们尽最大努力让他可以实用，但是并不能保证是最佳。可能需要至少一个月后才能确定，这篇文章是不是最佳的实用方案，这里只是一个对新功能的探索。如果有更好的使用这个API的方法，请联系我们，这样就可以修正这篇文章。</p>

<p>在开始介绍这个API之前，我们需要知道导航控制器的默认行为在iOS7下已经改变了：导航控制器下，切换2个view controller的动画有一点细微的改变，变得更有交互性。例如，当你希望弹出一个view controller时，可以从屏幕左边开始拖动，把整个内容拖动到屏幕右边。</p>

<p>让我们仔细看一下这个API，我发现这个被重度使用的接口是协议并不是一个实体。虽然一上来看上去有一点怪，但是我喜欢这个API，它给了我们更多的灵活性。我们从简单开始：用自定义动画代替原有的view controller的push动画（这里是<a href="https://github.com/objcio/issue5-view-controller-transitions">sample project</a> 在github）。我们首先需要实现这个新的 UINavigationControllerDelegate 方法：</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
               navigationController:(UINavigationController *)navigationController
    animationControllerForOperation:(UINavigationControllerOperation)operation
                 fromViewController:(UIViewController*)fromVC
                   toViewController:(UIViewController*)toVC
{
    if (operation == UINavigationControllerOperationPush) {
        return self.animator;
    }
    return nil;
}
</code></pre>

<p>我们可以观察一下这种类型的操作（push 和 pop）返回一个不同的 animator。如果我们分享代码的话，这个可能是一个对象。我们可能需要把这个变量通过property保存下来。我们也可以为不同的操作创建不同的对象，这里有很高的灵活性。</p>

<p>让这个动画运行起来，我们创建一个自定义对象实现 UIViewControllerContextTransitioning 协议。</p>

<pre><code>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end
</code></pre>

<p>这个协议要求我们实现2个方法，其中一个是描述动画的执行时间</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    return 0.25;
}
</code></pre>

<p>另一个是描述动画的执行。</p>

<pre><code>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    [[transitionContext containerView] addSubview:toViewController.view];
    toViewController.view.alpha = 0;

    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
        toViewController.view.alpha = 1;
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];

    }];

}
</code></pre>

<p>这里你可以看到这个协议是怎么用的：没有提供实体的对象参数，而是通过这个类型 id<UIViewControllerContextTransitioning> 得到transitionContext
唯一的最重要的东西就是在完成动画之后要调用 completeTransition 这个告诉 transitionContext 我们已经完成动画并且相应的更新了 view controller的状态。其他代码是标准的，我们通过transitionContext得到2个UIViewController，然后使用简单的 UIView 动画，这里我们很简单的做了一个zooming的动画</p>

<p>注意，我们只是写了push的自定义动画，当view controller pop时,iOS系统还是会使用默认的滑动动画。而且，实现这个方法后。导航栏也不能交互了（就是从左到右拖动实现pop view controller）。下面完善他</p>

<h1>交互动画</h1>

<p>让之前的动画变得能够交互起来非常简单。我们需要实现另一个UINavigationControllerDelegate</p>

<pre><code>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
{
    return self.interactionController;
}
</code></pre>

<p>注意，如果在一个不能交互的动画中，这里会返回nil。（译注：当不能交互时 self.interactionController 为 nil）</p>

<p>interactionController是UIPercentDrivenInteractionTransition的实例，没有必要更多的设置。我们通过创建拖动手势（UIPanGestureRecognizer）来实现：</p>

<pre><code>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
    }
} 
</code></pre>

<p>只有当用户在屏幕右边操作时，我们才设置动画是可以交互的（通过设置interactionController 属性）。然后我们调用performSegueWithIdentifier（或是不用storyboards，直接push view controller）
在这个手势变化中，我们调用interactionController 的一个方法 updateInteractiveTransition:</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
    [interactionController updateInteractiveTransition:d];
} 
</code></pre>

<p>这里根据拖动的距离设置百分比，非常cool的事情是交互控制器（interactionController）和 动画控制器（animation controller）相互协作。而且因为是普通的 UIView 动画，它控制着动画的进程。我们不需要处理他们之前的事情，
所有的事情都在背后默默的自动搞定了。</p>

<p>最后，当手势停止或是取消掉，我们需要调用interaction controller相应的方法</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
        [interactionController finishInteractiveTransition];
    } else {
        [interactionController cancelInteractiveTransition];
    }
    navigationControllerDelegate.interactionController = nil;
}
</code></pre>

<p>当切换动画完毕时，设定interactionController为nil非常重要。如果下一个动画是非交互的，我们不希望得到一个奇怪的 interactionController</p>

<p>现在我们已经有一个完整的自定义的可交互的过度变换（transition）了。通过普通的拖动手势和一个UIKit提供的实体对象，几行代码就搞定了。对于大多数的自定义交互过度变换，你可以在这里停下来，用上面提到的方法做任何你想做得动画
或是交互。</p>

<h1>GPUImage自定义动画</h1>

<p>我们现在已经能够实现一个完整的自定义动画了，可以不用UIView 甚至Core Animation，做自己喜欢的动画。一开始，我用Core Image实现了一个项目<a href="http://www.macstories.net/featured/a-conversation-with-loren-brichter/">Letterpress-style</a>。但是在我的旧iPhone4上面只能跑到大约9FPS，这个和我所期望的60FPS差距太大了。</p>

<p>但是当我使用<a href="https://github.com/BradLarson/GPUImage">GPUImage</a>后，实现一个非常漂亮的自定义动画效果变得非常简单。我们希望这个动画能够做到像素级的消融在2个view controller切换的时候。这个是通过分别对2个view controller 截屏，然后应用GPUImage的图片滤镜实现的。</p>

<p>首先，我们创建一个自定义类，实现animation 和 interactive transition 协议。</p>

<pre><code>@interface GPUImageAnimator : NSObject
  &lt;UIViewControllerAnimatedTransitioning,
   UIViewControllerInteractiveTransitioning&gt;

@property (nonatomic) BOOL interactive;
@property (nonatomic) CGFloat progress;

- (void)finishInteractiveTransition;
- (void)cancelInteractiveTransition;

@end
</code></pre>

<p>为了让这个动画跑的飞快，我们只把图片传给GPU一次，然后把所有的图像处理绘制交给GPU，而不是传给CPU（GPU和CPU之间的数据传输非常慢）。通过GPUImageView，我们可以用OpenGL绘制动画效果（不需要手动编写底层的OpenGL代码，我们可以继续编写上层代码）</p>

<p>创建这样的滤镜链非常方便。这里可以看一下下面的例子。有一点挑战的是实现动态的滤镜。GPUImage不能给我们直接提供动画效果。这里我们通过在每一帧的时候更新滤镜来实现动画的绘制。我们使用CADisplayLink类来做这个。</p>

<pre><code>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
</code></pre>

<p>在frame:方法中，我们根据时间更新动画进度，然后更新滤镜</p>

<pre><code>- (void)frame:(CADisplayLink*)link
{
    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
    self.blend.mix = self.progress;
    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
    [self triggerRenderOfNextFrame];
}
</code></pre>

<p>以上就是我们所有要讲得了。在交互变换中，我们需要确保我们的进度是根据手势识别设置的，而不是根据时间。但是剩下的代码几乎都一样了。</p>

<p>这个真的太强大了，你可以使用GPUImage提供的任何滤镜或是自己写的OpenGL代码来实现上面的效果。</p>

<h1>小结</h1>

<p>我们这里仅仅提到了导航控制器下面的2个 view controller 之间的动画，事实上你可以做相同的事情在tabbar controller 或是自定义的container view controller。而且 UICollectionViewController 现在已经可以在layout上面自动实现交互动画了。他们都是使用相同的机制。这个真的太强大了。</p>

<p>当我和<a href="https://twitter.com/orta">Orta</a>提到这个API时，他指出他已经使用这个功能创建了一些轻量级的view controller。不要在每一个view controller 保存管理动画的代码，而是创建一个新的view controller，然后实现2个view controlller视图切换时的自定义的动画效果。</p>

<h1>更多</h1>

<ul>
<li><a href="http://asciiwwdc.com/2013/sessions/218">WWDC: Custom Transitions using View Controllers</a></li>
<li><a href="http://www.teehanlax.com/blog/custom-uiviewcontroller-transitions/">Custom UIViewController transitions</a></li>
<li><a href="http://www.doubleencore.com/2013/09/ios-7-custom-transitions/">iOS 7: Custom Transitions</a></li>
<li><a href="http://whoisryannystrom.com/2013/10/01/View-Controller-Transition-Orientation/">Custom View Controller Transitions with Orientation
</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/17/sports-nov/">第一次马拉松，也是这段时间健身的总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-17T21:41:00+08:00" pubdate data-updated="true">Nov 17<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/11/17/sports-nov/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>第一次接力马拉松</h1>

<p>11月16日是个特别的日子，健身满16个月，更重要的是参加了人生第一次马拉松，香山接力赛，平均坡度35，一次往返3km，一个队伍4个人，每人4圈，每人总共12km。时间从上午11点，跑到下午4点。16个月前，当我开始准备减肥的时候，我从来没有想过可以一口气做6个引体向上，没有想过可以一口气600多个仰卧起坐，也没有想过我的胸围可以长5cm，没有想过我的腰围可以减少12cm，没有想到我可以减40斤，更没有想过，我居然有了参加山地马拉松的能力，虽然仅仅是接力赛。</p>

<p>说道马拉松，不得不多说几句，跑一次全程马拉松是我30岁前必须完成的人生目标之一。为了方便去香山，15日我暂住一个朋友家，在14日在家的时候，我开心的一晚上睡不着觉，弄得我不得不担心我会不会因为过于兴奋而导致体力消耗太大最后不能完赛。好在16日的时候，我已经完全调整过来，而且老天也特别配合，PM2.5出奇的低，给我一个风和日丽的早上。整个比赛还算轻松，或是对自己要求不够高吧，除了第一圈比较吃力以外，后面越来越好，特别是最后一圈，如果再给我一次机会，我会更努力的跑。</p>

<h1>16个月运动统计</h1>

<p>说了这么多虚的，这是我运动的统计，由于没有想到过自己能够坚持这么长时间，统计只是从2013年4月5日开始到今天。总共226天的时间其中健身160.73小时,下面是每个月的运动时间统计，纵坐标单位分钟。</p>

<p><img src="/images/sports-nov1.png" alt="image" /></p>

<p>一个月的维度已经很大了。这个充分说明，即便我已经有了这样大的运动效果，16个月，我的健身习惯还没有真正的养成，不管是计划制定，还是执行层面，因为一个习惯的正常曲线应该是这样子的。</p>

<p><img src="/images/sports-nov2.png" alt="image" /></p>

<p>这是我的英语听写计划时间统计，英语计划相对健身更简单可控。记得有一本书中写道，一个成熟的人制定的计划是稳步递增的，而那些年轻人的计划，往往都是大起大落。好吧，这里就不嘲笑自己了。</p>

<p>很多人都问我，坚持下来的原因是什么，这个真的很难说，在一开始的时候，想法总是很简单的，和很多人一样，希望更好看一点，更健壮一点。但是如果一直是这么简单的想法，必然不能长久，很多东西会在这个改变的过程中加入进来，甚至变成最重要的东西。反之也会有很多东西变得不那么重要最后离我而去。现在来说，最大的原因在于我的性格上的变化。这半年来，我性格上面最大的变化就是变得越来越goal oriented， 在健身的过程中，最能体现的就是一个个目标达成的幸福感，这个让我非常开心，因为就目前我能做的事情来看，像健身这种只要做，就比不做强的事情，而且还有不少附加价值的实在是少之又少。</p>

<h1>意志力</h1>

<p>健身的过程的确是很苦的，当然这个世界上被认为有价值的习惯都是很难达到，需要花费大量的时间，不仅是健身，还是英语我实际花费的时间都比上面统计的要多的多。比如你可能需要学习做饭，你可能需要控制饮食，我在减脂的3个月中，几乎不吃肉，把一切零食，甜食，饮料当成毒药。忌口对于我这种意志力薄弱的人来说，真的是相当的难。不管是再好吃的东西，要做到能够停下来，或是坚决不吃。一个朋友说过这样子的话“我常常把吃得放在一边，人必须学会控制自己的嘴巴，这是一种训练意志力的方式，因为很简单，如果自己的嘴巴都控制不了，还指望她能做点什么”。这个怎么说呢，话粗理不粗吧。我反正是不同意这个观点，但是喜欢这个做事态度。</p>

<p>说道意志力，让我想起了施瓦辛格说的一句话“健身的精髓在于力竭后的最后一个”，同样还有很多类似的话“马拉松比赛在20km之后才开始”。对现在的我来说，健身在跑完5km，或是300个仰卧起坐，或是300个深蹲又或是10组pull ups，俯卧撑，推胸之后才真正开始，之前做得一切运动都只是为了积累身体疲劳到一定程度,这样才能有意义，因为力竭之后的动作，才是给身体最好的信号“我要变得更强壮”。</p>

<p>讲锻炼意志力的书有很多很多，方法也很多很多，在健身的方面，我最喜欢的就是P90X里面教练提到的方法，另外我增加了最后面一条。</p>

<p>1、设定目标
2、达成目标
3、记录下来
4、忘掉它</p>

<h3>设定目标</h3>

<p><strong>设定目标</strong>的动机很明白，跑马拉松的时候，大家不会设定一个终点这样的目标，而是将这个过程分解成一个弯角，一段斜坡。同样力量训练也是分成25个一组的小重量，8-12个的大重量。设定目标最大得作用在于clear your mind and focus on the things。</p>

<h3>达成目标</h3>

<p><strong>达成目标</strong>，这个毋庸置疑，目标就是要被达成的。</p>

<h3>记录下来</h3>

<p>前2个一般人都可以做到，但是后面的2个才是真正的精髓。在任何过程中都会产生迷茫，哪怕是改变一个小小的习惯，因为不管怎样你都无法逃避掉一个问题“How to be better XXX”。<strong>记录下来</strong>就是为了这个准备的。我是那种容易消极的人，数据让我不会把一些局部失败看得太重，把局部成功看得太重。这一点对我帮助很大，我看到了我最近3个月器械力量增大一倍，但是整体时间依然波动很大等等这些都是帮助我抵抗不良情绪最好的良药。</p>

<h3>忘掉它</h3>

<p><strong>忘掉它</strong>是一个很神奇的东西，在跳出舒适区的过程中，特别有用。比如你已经做了500多个仰卧起坐，每一个都已经burning，如果你脑子里面想得是我已经做了500个了，一般人200个都做不了，那么就很难做到600+。忘掉它是一种归零的心态，每一组动作都是一个新的起点，新的开始。也是对抗懒惰最好的良药，特别是我这种对自己要求比较低，喜欢放纵自己的人。我是真的对自己要求低，特别是在健身上面。我见过非常多的人一起跑步的时候吐过，一起踢球的时候抽筋过，也亲眼见过跑步训练跑到眼底角膜充血的，也见过做yoga把腿都拉伤的，很多很多的例子。而我则是被教练说“你就是对自己要求太低”，“你之前炼过吧，额，你怎么不跑了？还有5圈呢？”，从小到大一直都是。</p>

<h1>后记</h1>

<p>健身已经从一开始的甩掉大肚子，变成了我生活的一部分或是他本身就是我生活的缩影。在香山认识了也见识了很多牛人，有骑行川藏的，海拔5000km，有跑戈壁滩的，一天30km，连续跑4天的。而他们有的甚至平均年龄高达45岁。除了这些已经几乎bt的人以外，也有30大几的已婚姐姐锻炼成“钢筋铁骨”的，相比而言我这25岁的“小娃娃”，记得当时我开始健身的时候，最大的原因就在于，我已经25岁了，老了，而且我之前2次减肥失败，这次再不减肥肯定就完蛋了的心态。呵呵，现在想起来还是蛮好笑的。虽然人的确在经过25岁之后，心肺，肌肉等等身体各项机能都会开始退化开始衰老，更容易产生脂肪，但是我很开心，在我25岁的时候，我所做的一切。身体和灵魂，至少有一个需要在路上。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/16/algo-class-02-scheduling/">Stanford 算法课 Part 2 Scheduling</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-16T20:46:00+08:00" pubdate data-updated="true">Sep 16<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/09/16/algo-class-02-scheduling/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当一个人每天都有做不完的事情时，不知道大家又没有这种感觉。各种各样的事情，各种deadline，甚至是一些无关紧要的琐碎事情也会不断的在大脑中被回想，而且还是反复的，没有任何理由的会冒出来。对像我这样非常懒惰的人来说，这就是一个非常致命的打击，因为我需要中断当前的事情，这会让我多消耗不少脑力。。。</p>

<p>这应该算是时间管理中的一部分，如何给自己安排任务。人的大脑和电脑的工作模式还是有一些类似的，比如如果一直不断的记录一大堆事情而不是执行，那么就会影响到他们的工作效率。同样，如果重要的事情不作，最后也会不断的在大脑里面被回想，而造成效率降低。</p>

<p>在我看来，解决这些回想问题最关键的事情就是把这些东西搞定，这样才能把大脑清空，然后去做那些更加有意义的事情。</p>

<p>最近再跟algorithm part2里面正好有一个scheduling application的东西，挺有意思的。这里记录一下。</p>

<h1>问题描述</h1>

<h2>Setup</h2>

<p>scheduling 的基本模型是有一个shared resource，比如CPU。但是有许多jobs，比如很多线程，需要使用CPU才能运行。</p>

<h2>Question</h2>

<p>我们应该如何调度这个jobs的顺序，哪一个job优先于其他job执行，从而让整个计划执行时间最少。</p>

<h2>Assume</h2>

<p>为了更清楚的定义数学模型，每一个job有2个维度。</p>

<ul>
<li>weight 重要性</li>
<li>length 时间</li>
</ul>


<h2>Defintion</h2>

<p>Completion time。 第J个任务的完成时间（Completion time）Cj 是 （任务J之前的等待时间 + 任务J的length）* 任务J的weight</p>

<h1>思路</h1>

<p>这里根据直觉可以很明显的知道 我们需要把重要的事情放在前面，把时间短的事情放置在前面，这样可以很快的打一个勾勾，清空大脑中的这个任务。也就是说Cj 和 Wj 正相关，和 Lj负相关。但是总是有一些事情让人欲罢不能，就是那些很重要，而且做起来还比较费劲，时间花费长的事情，和那些不重要但是时间花费短的事情。真实世界的事情太复杂，还是回到我们这个简单的模型中。</p>

<p>一种常见的思维是设法将问题转换成之前我们已经解决了的思路之中，所以很容易想到我们需要找到单位长度中最重要的事情先做。因为我们的这个模型的任务调度不是抢占式的么。</p>

<p>将上面的单位时间的含义翻译过来就是 wj / lj。 也就是我们的调度程序将按照w / l的值，从大到小排列
<img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_01.png" alt="scheduling 1" /></p>

<p>这里我们假定任务i > j。这个图则表示这2个任务相连在一起，stuff表示之前的任务，more stuff表示之后的任务。</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_02.png" alt="scheduling 2" /></p>

<p>而这里，我们做一次任务i、j的交换，就像这样</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_03.png" alt="image" /></p>

<p>那个这2个scheduling中，i,j之前的任务的完成时间不会变，之后的任务完成时间也不会变。那么受到影响的只是任务i，j。</p>

<p><img src="https://raw.github.com/studentdeng/studentdeng.github.com/master/images/algo_schema_04.png" alt="image" /></p>

<p>那么这里显然scheduling 2 也就是后面的那张图的顺序比第一个要小。</p>

<p>然后我们可以想象最后的任务流程，就如果冒泡排序一样，一次次的比较把相对重要的数据一次次的放置到前面。</p>

<p>而当所有相邻的任务都按照这样的规则排列完毕后，得到的就是一个 wj / lj 的从大到小的序列。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/15/calm-down/">Calm Down</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-15T23:03:00+08:00" pubdate data-updated="true">Sep 15<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/09/15/calm-down/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近已经发生了很多事情，将来也会发生一些事情，这里为了不让我负能量爆发，就不写这些细节了。昨天和老大聊到晚上3点半，这里我还很dt的查了一下，上一次聊这么晚也就是2个月前。刚刚突然发现有人赞了一下我的微博，哦，很好，长出一口气，终于不是强X的无脑赞了。微博的内容是一篇关于《女人明白要趁早》的读书笔记，书里写过一句这样的话“这世上只有快乐的猪和悲伤的哲学家”，但在我看来，还有另一类人是悲伤的猪，而我显然属于后者。当然这不是我想说的，书中有一些这样的话。</p>

<p>“当你一无所知、一无所有、一无所成的时候,没事不要去想“个人尊严”和“个人价值”这 类虚词儿。一、做好眼前事。二、假以时日。 有完美榜样是好的,能让我们矢志不渝地去为追求完美努力;知道榜样其实不完美也是好的, 避免我们成为偏执狂,或者因为目标难以企及而自暴自弃。”</p>

<p>这个世界上面充斥这这样子的言论，你没有办法去反驳它，因为他本身说的就是事实，是正确的，而且是毫无疑问正确的，但是如果只是做到这些是不可能成功，或是更严格讲，这些都不是成功的关键因素，从心理学角度来看，这些话没有办法被证伪。这些话就是一个个成功人士为了安慰屌丝们的心灵鸡汤而已。</p>

<p>对于年轻的人们来说，经历的苦难和挫折大概都是因为阅历，资历不足，内心却比地球还大，一开始就像构建一艘航空母舰。但最后发现这样的航母根本做不出来，或是做出来随便小小的浪头就能把它拍的粉碎。而也有不少人意识到了这一点，做出了一艘艘驱逐舰，潜艇。但最后发现，光这艘船，根本不可能带你穿过那些暴风雨频发的海域。</p>

<p>我们害怕跌入日复一日平淡庸碌的结婚、生子、还房贷、终老一生的生活中去。但是现实就是这个社会最不缺的就是空想家，社会不仅不看你的想法，不在意你的未来，更不在意你的过去，只是看你的现在，你的所作所为。你所能掌握的资源，你能做出多少选择的能力。</p>

<p>大家都会成长，会慢慢看淡这些ups and downs，大家都在说，现在社会多么浮躁，年轻人要学会等待，假以时日，每天坚持，就会变好的。我只想说“呵呵”。平静会很容易的掩饰内心的平庸，诚然平静很重要，但绝对不是逃避，需要cope，而这需要一个强大的内心。只有内心足够强大才能做出抵挡风浪的船，而不是随流漂动的木板，虽然他们都是在水上浮着，当然木板也有好处，船会翻。木板不会。</p>

<p>一个朋友曾今问过我为什么给自己设定一个30岁的目标，因为有太多的东西我们不能左右，在到一定年纪就不得不考虑，作为一个男孩子，不得不去承担一些该来的责任，那么自由时间必定要被压缩，而且有一些事情，年纪大了，也就错过机会了，或是需要付出比年轻时候更多的投入。所以必须趁年轻，因为在再不疯狂就来不及了。</p>

<p>Tal在幸福课中提到一句，平庸和卓越在表面都很平静时是如何区分出来。卓越的人更会相信自己会做到。</p>

<p>额，本来还是想写下去，发现自己已经不知不觉开始写心灵鸡汤了，看来我已经被毒害不少了，再删掉一大段之后，思路瞬间被阻塞了。一阵阵困意袭来，呼~，昨天睡得有一点少了。今天最开心的就是，去东直门上了一节跳舞课，按照我以往对我自己的了解，我应该死宅在家里才对，绝对不会出门，更别说走这么远。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/13/cocoapods-tutorial/">Cocoapods 入门</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-13T23:48:00+08:00" pubdate data-updated="true">Sep 13<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/09/13/cocoapods-tutorial/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>介绍</h1>

<p>最近一直在搞<a href="https://github.com/CocoaPods/CocoaPods">cocoapods</a>。 ios 这么多年终于有一个好使的包管理了。真的好激动好激动。。。
之前开发一些App的时候，在一开始的时候，总是需要手动添加framework， library，设置一些 search path，有时候还会忘记那么几个，然后出来一大堆的link error。当一些library更新的时候，还需要自己手动去更换。3句话说就是</p>

<ol>
<li>手动增加framework，library</li>
<li>手动增加编译参数</li>
<li>手动维护代码更新</li>
</ol>


<p>完全是一大堆的体力活，当然，这些简单的配置和复制并不会花费太多的时间，但是，还是觉得在浪费生命，而这时候CocoaPods就出来了。我们只需要设置一个Podfile文件，执行</p>

<pre><code>$ pod install 
</code></pre>

<p>CocoaPods会帮我们下载好代码，设置好编译参数，配置好framework， library。</p>

<h1>安装和更新</h1>

<pre><code>$ sudo gem install cocoapods
</code></pre>

<h1>使用</h1>

<p>在project根目录下，create Podfile文件，下面一个例子</p>

<pre><code>platform :ios, '5.0'
pod 'CURestKit', '~&gt;1.0.1' 
pod 'SDWebImage','~&gt;3.4'
pod 'MBProgressHUD', '~&gt; 0.7'
pod 'UALogger', '~&gt; 0.2.3'
</code></pre>

<p>CocoaPods 会帮我们从git clone下来配置好的这些代码。后面的部分表示代码的版本号，一般来说和tag挂钩。</p>

<p>配置好Podfile之后，执行</p>

<pre><code>$ pod install
</code></pre>

<p>则会帮我们配置好这些项目。并生成一个XXXX.xcworkspace。 以后project使用这个文件就可以了。CocoaPods其实就是帮我们配置一个静态库作为项目的依赖。</p>

<p>CocoaPods里面有大量的代码，现在最新的版本安装后是在这里</p>

<pre><code>~/.cocoapods/repo/master/ 
</code></pre>

<h1>制作自己的项目配置</h1>

<p>实际开发过程中，我们还有不少代码需要被改动，而CocoaPods上面的代码，大部分都比较旧，都是很稳定的代码，当然也有一些不能用的（大部分是国内的公司做的，大家都懂的）。另外还有一些我们自己写的一些其他代码，暂时还么有被CocoaPods收录的。这时候我们就需要配置自己的项目啦。</p>

<p>这里是我的一个项目配置例子。cocoapods的配置文件就是一个 *.podspec的文件，这是一个例子文件名ShareCenter.podspec。这是一个典型的ruby，</p>

<pre><code>Pod::Spec.new do |s|
s.name         = "ShareCenter"
s.version      = "2.0"
s.summary      = "share client include sina weibo ,tencent weibo, renren"

s.description  = &lt;&lt;-DESC
               share client include sina weibo ,tencent weibo, renren
               DESC

s.homepage     = "https://github.com/studentdeng/ShareCenterExample"
s.license      = 'MIT'
s.author       = { "curer" =&gt; "studentdeng@hotmail.com" }
s.platform     = :ios, '5.0'

s.source       = { :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git", :tag =&gt; s.version.to_s }
s.source_files  = 'ShareCenter', 'ShareCenter/**/*.{h,m}'

s.frameworks   = 'QuartzCore', 'Security', 'CoreGraphics', 'AudioToolbox'
s.library = 'sqlite3.0'
s.vendored_libraries = 'ShareCenter/Vender/sina/libWeiboSDK/libWeiboSDK.a'

s.prefix_header_contents = &lt;&lt;-EOS
#ifdef __OBJC__
#import "ROConnect.h"
#endif /* __OBJC__*/
EOS
end
</code></pre>

<p>这个基本上都是自解释的，这里有几个需要说明一下</p>

<h2>s.source s.source_files</h2>

<p>这里的 <em>source</em> 我们看出是一个git 的地址，这里我们调试的时候，可以先暂时设置成本地git，调试完毕之后就可以发布 增加tag。想要最新的代码只需要这样设置就好</p>

<pre><code>{ :git =&gt; "https://github.com/studentdeng/ShareCenterExample.git"}
</code></pre>

<p>我们的git项目中，并不是所有的代码都需要被引用到我们的代码中，通常project还会包括一些example，test cases等，这里的 <em>source_files</em> 就是用来指定一些文件夹，或是文件。我这里的设置也很容易理解，就是ShareCenter下面的递归后的所有后缀是h、m的子文件。</p>

<h2>s.frameworks s.library</h2>

<p>这里配置的就是我们的framework 和 library，这里注意一下library的名字规则就好。</p>

<h2>vendored_libraries</h2>

<p>这里用来指定外部的静态库。这里我们指定了sina sso认证的SDK</p>

<h2>s.prefix_header_contents</h2>

<p>这里用来指定预编译的配置，这里一定要鄙视一下renren的超级渣渣SDK。这里提供一种解决方法。</p>

<h2>部署我们的配置到cocoapods中</h2>

<p>cocoapods的代码配置文件是在这里<a href="https://github.com/CocoaPods/Specs">Specs</a></p>

<p>这里最好是去fork一个自己的project，然后保存一个自己或是团队的配置，这样不会在更新cocoapods的时候，丢掉自己的配置。当然，如果觉得自己搞的还不错，也可以去pull requests。</p>

<p>在之前提到的目录<em>~/.cocoapods/repo/master/</em> 下面，我们可以看到已经有超级多的项目了，我们可以也可以通过</p>

<pre><code>$ pod search XXX
</code></pre>

<p>来查找项目，或是直接在这个文件夹下面找，可以学习不少project的配置技巧，我这里也是从他们学到的。</p>

<p>最后添加一个project的配置是这样子的。</p>

<p>例如上面的例子，
在<em>~/.cocoapods/repo/master/</em> 下面创建一个文件夹ShareCenter，然后在创建一个2.0的文件夹表示这是version2.0的配置。
然后在把之前的ShareCenter.podspec复制到2.0目录下面。</p>

<p>也就是最后的目录是这样子的</p>

<pre><code>~/.cocoapods/repo/master/ShareCenter/2.0/ShareCenter.podspec
</code></pre>

<p>如果希望更多的了解cocoapods，还是需要去<a href="https://github.com/CocoaPods/CocoaPods">Github</a>上面 :D</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'studentdeng';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>








</body>
</html>
