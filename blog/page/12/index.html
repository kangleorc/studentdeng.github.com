
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不会开机的男孩</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="从搬到新办公室到现在差不多半年了,有些东西,本来是想,在年终总结的时候写,但想想,还是现在记录最合适,毕竟那些只是一个形式.重要的还是自己最近的思考,或是看过一些书后的感想吧. 每天花半个小时健身或游泳,体重成功减少10斤,稳定150,把肚子上的肉,部分转移到肩膀和胳膊,有人说我瘦了,而且, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com/blog/page/12">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="不会开机的男孩" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/jquery.min1.9.1.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">不会开机的男孩</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  	<li><a href="/">Blog</a></li>
  	<li><a href="/blog/archives">Archives</a></li>
	 <li><a href="/tags/index.html">Tags</a></li>
	<li><a href="/favorite/index.html">Favorite</a></li>
	<li><a href="/about/index.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/25/growth-2012/">又是一轮成长</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-25T05:47:26+08:00" pubdate data-updated="true">Oct 25<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/10/25/growth-2012/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从搬到新办公室到现在差不多半年了,有些东西,本来是想,在年终总结的时候写,但想想,还是现在记录最合适,毕竟那些只是一个形式.重要的还是自己最近的思考,或是看过一些书后的感想吧.</p>

<p>每天花半个小时健身或游泳,体重成功减少10斤,稳定150,把肚子上的肉,部分转移到肩膀和胳膊,有人说我瘦了,而且,肩膀比之前展了,自然了 : ) 开心.</p>

<p>每周花4个小时上英语课,6-8个小时做英语题和复习,每天听写半个小时到1个小时.</p>

<p>每天注意饮食,少吃肉,多吃菜.多喝汤的生活,加上一个学习英语的好习惯,使自己从之前对英文的厌倦,到可以比较轻松的阅读计算机专业书籍,Apple产品发布会,WWDC dev video, 公开课.</p>

<p>当然,也干砸过事情,第一次创业的公司被我们搞砸了.经过2次融资后,还是和大部分创业公司一样最后不得不结束.但,不同的,就是我们team还没有散伙,也不能算是干砸,算是一个新的开始吧.</p>

<p>但我觉得最重要的收获不是这些技能.或是习惯.而是我第一次真正的能够面对自己的内心.意识到了心智成熟的重要,感觉到了长大的烦恼.</p>

<p>我忘记了是那本书上写的这样类似的内容.来形容人的成长.</p>

<p>在人还是婴儿的时候,人认为整个世界就是他自己或没有自己的概念但随着成长,慢慢有了我的概念,知道了,这是我的胳膊,我的眼睛,我的鼻子.我的妈妈. 再长大一点.开始更清楚的认识到自己,我的妈妈不是自己所能控制,人们通过哭闹来得到妈妈的照顾.再长大一点,认识到自己需要自己照顾自己.再长大了,我们发现我们周围的人和你的想法也不一样,他们都是不同的个体.等等</p>

<p>如果把自己的所能控制的范围,成为自我界限吧,个人成长似乎就是一个慢慢缩小,更清晰的一个过程.似乎是更倾向于科幻小说中,人类最后都会走向孤独.</p>

<p>但事实上,还有一种成长,就是爱.能够穿越这些自我界限,一开始人们只是知道对自己好,本能的逃避危险,有些时候,伤害别人也并不在意.再长大一点,我们会考虑到父母,再长大一点,会慢慢考虑更多的人.</p>

<p>就像太阳系诞生之初,各个天体随着引力作用下,不断坍缩,但最后都在彼此作用下,维持一个完美的平衡.互补侵犯.但谁都离不开谁的状态.</p>

<p>想想1年前的我的总结.http://www.cnblogs.com/studentdeng/archive/2012/01/13/2321813.html</p>

<p>很清楚的感觉出,当时我只是考虑到自己.意识到自己的发展,而没有或是几乎没有考虑到别人的感受,整个文章中,充满了&#8217;我&#8217;, &#8216;我的想法&#8217;, &#8216;我觉得&#8217;. 恩,当时的自己,还是挺自恋的 : ) 现在也是.呵呵, 记得,在创业的时候,算是我的一个大哥兼同事, 他对我说过, &#8216;我没有过多的考虑自己的发展和提高,而是在团队的角度去看,我需要做什么,如何才能让大家调动起来,而当大家都有很大收获,就是我的收获&#8217;,恩,当时在1年前,我真的没有当回事,觉不出来这里面的意思.现在看来,这个应该就是我所想的更大的爱,能够穿过自己的界限,来让自己得到成长.</p>

<p>其实,不仅仅是创业的过程, 玩游戏也一样, 在开始的时候,我们只能控制自己,做好自己.而当玩的越来越好时,我们需要更多的和队友配合,而到更高级,我们需要去思考对手最什么, 如何去欺骗对手,落入我们的圈套,落入我们的节奏,不知不觉中慢慢积累优势,最后成为不可逆转的胜势.</p>

<p>从本质来看,都是,自己的思维方式,思维角度,不能仅仅局限在自己的界限内,还需要拓展到更大的空间中,才能更好的把握自己,把握团队.因为现在的社会,不是小农经济的自给自足,需要更多的人协作,配合才能更高效的实现自己的梦想. 是的. 更高效, 因为现在小步慢跑已经是落后的.</p>

<p>现在来看,我真的要感谢那个我第一次喜欢上的女孩吧.要知道,如果你在人生的低潮,公司运营难度极大,大家每天都在煎熬,感觉什么事情都推动不下去, 但却侥幸拿到融资, 万事俱备,但却又失去发展方向,第一次非常严重的质疑自己能力时, 有一个女孩很有耐心的开导你,再呆的家伙也会对那个女孩动心.</p>

<p>虽然从心理学来讲,得不到的总是会觉得好,但这个过程让我真正的明白了,世界上的,每个人都有自己的想法,都是不同的个体,有自己不同的想法.很多时候,并不是你想怎么样,就可以怎么样.也第一次真正的意识到自己的心理问题或是思维习惯,虽然在过去的时光,我在这种习惯下,收获非常多.</p>

<p>怎么形容过去的习惯呢?
其实,每天坚持健身,跑步,游泳,同事还要保证满负荷工作,学习,真心的很累,很多时候,都希望躺在床上休息, 但最后都会坚持,因为只要想到有人也在坚持, 而自己没有做到,就觉得有严重的负罪感,当走到健身房,看到有人在运动,全身在疲倦都会像打了鸡血一样.而且,越是疲劳,做的越多.游泳的时候, 只要有人一起游泳,那么就要比他游的远,如果没有人,就心里构思一个人</p>

<p>长期的这种思维下,虽然会使得执行力非常高,但是对周围其他人的感受却是越来越少,同时又因为受到他人影响小,所以决断力又会凸显的很高.但这其实不是真正的执行力高,也不是决断力高,只是一个自私自利的表现,或至少是自己的效率极高,而不管他人.在前期的提升来说,的确是非常的高效.但当真正的需要和多人配合,甚至是去喜欢一个人时,就显得发育不平衡了. 就像锻炼肌肉, 不平衡,导致身体不协调一样,同样跑不快.因为大家都知道的木桶原理.</p>

<p>其实,我老早就有人说过我,但我的性格却是非常的固执,那种不撞南墙不会头的那种. 而那个女孩,算是第一堵墙,撞的我头破血流, 几个月无法全心工作,有大半个月甚至几乎不工作,只是抱着一本物理书看.因为我自己的一直赖以骄傲的价值观和思维方式被判了死刑,我感觉到了无与伦比的沦陷,而那本书,正好讲的是传统物理学在量子物理的冲击下,而摇摇欲坠, 这种沦陷,让我感到了放松,所以,真真正正的体会到了爱因斯坦在面对量子物理的无奈,甚至说出了&#8221;难道上帝也仍色子么?&#8221;这样无力的问题.因为我内心也有这样一个问题,我自己该怎么办,难道只能人云亦云,走那些很多人走的老路子么</p>

<p>我没有办法想清楚,但我唯一能清楚的是,我又要长大了. 如果说,创业的第一年主要是技术,工作经验的积累,那么,第二年,真的,没有太多技术的积累,更多的就是心智的成熟.如何能够不让你的消极心里,影响到自己和团队的其他人,如何做事情更靠谱等等.</p>

<p>这段时间,遇到了真的是,人生中的第一次重大的问题,人生观的修正.需要放弃之前已经根深蒂固的想法.真的是很难受,很难受.我的运气真的很好,整个创业的team给了我很多的时间去调整并开导我,而我也在豆瓣上认识了另一个女孩,一个非常博学的笔友,虽然比我还要小,但是却很睿智,看了非常多非常多的书,也给了我很多帮助,当然,最关键的还是自己.也许正是因为这个很难,很难,我的鸡血又开始打上了.开始正视自己的不足, 肯定自己的优点,开始学如何更好的控制自己的情绪,如何更好的思考周围的人.等等.</p>

<p>这是每一个低情商男孩们都会遇到的问题.特别是对geek们来说.</p>

<p>所以也就从这里开始吧,自己开始注意了解自己. 有时候,古人的话,还是很有道理的, &#8220;齐家治国平天下&#8221;,当然,这里并不是必须首先结婚,而是,要想成功,需要能够更了解自己,控制自己.更了解别人.自己的朋友, 甚至的你的对手.</p>

<p>说到这次创业,又不得不多扯几句, 前几个月,哥几个谈的时候,还说, 我们又要到一个关键时候了. 是啊, 每到一段时间都要做个困难的抉择.让我不禁想起当时家长们长长说的, 考上一个好的初中是人生转折点,好的高中是人生转折点,好的大学是人生转折点. 当时的想法是,这么多转折点也该回到原点了吧. 哈哈</p>

<p>现在不这么想了,每个这样的时候,都是成长的机会.</p>

<p>真的非常庆幸,自己在毕业时,选择创业这条路子.第一年磨练技术,第二年磨练心志,没有比这更完美的了,不是么 : )</p>

<p>想想去年定的目标,恩,今年算是达到了.无论从App Store的rank 还是推荐次数,都已经是翘楚了.第三年,不像第二年有投资人, 也不像第一年有备用金.但却是真正了解自己的开始.</p>

<p>也许真正的创业,才刚刚开始,同时,心智成熟的路也刚刚起步.</p>

<p>目标么,很简单,养活自己.养活团队,大家过的更好一点,认识更多朋友.好空泛啊, 来一点实际的吧, 雅思过7,月薪过万.</p>

<p>正好说到钱这个问题.虽然很沉重,但的确是一个问题,我还年轻,无所谓,但是对团队里的一些大哥们,快30 要不已经30了,本来年薪都是2,30W妥妥的安稳轻松的工作,而现在在这里苦逼,其实过程中,暗中,恩,包括我都放弃了很多很多次.
但最后都坚持下来,为啥呢, 也许都是一路人吧, 都是一些习惯打鸡血, 幼稚,固执的一帮人.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/02/16/selfos/">Orange‘s 一个操作系统的实现 配置问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-16T23:57:00+08:00" pubdate data-updated="true">Feb 16<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/02/16/selfos/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在瞅《Orange‘s 一个操作系统的实现》，个人认为相当好的OS入门实践书籍，配合之前看过的大部分的理论书，容易理解那些抽象的概念（无代码无真相），</p>

<p>和《Linux内核完全注释》都是相当不错的入门书籍。</p>

<p>这里记录一下可能遇到的问题，主要是配置问题，实现逻辑书里面很详细，代码注释也很详细，仔细多想应该没啥问题。</p>

<p>我这里环境是ubuntu 10 64bit， 而书中代码是32bit的。这里在编译链接的时候出了一点小问题。这里记录下。</p>

<p>错误：</p>

<pre><code>ld: i386 architecture of input file `kernel/kernel.o' is incompatible with i386:x86-64 output
</code></pre>

<p>需要修改makefile</p>

<pre><code>CFLAGS          = -I include/ -c -fno-builtin -m32
LDFLAGS         = -m elf_i386 -s -Ttext $(ENTRYPOINT)
</code></pre>

<p>错误：</p>

<pre><code>klib.c:(.text+0xe5): undefined reference to `__stack_chk_fail'
</code></pre>

<p> 这里应该是少了c的标准库，还是需要修改makefile文件</p>

<pre><code>LDFLAGS         = -m elf_i386 -s -Ttext $(ENTRYPOINT) -lc
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/02/14/bochs-configure/">Bochs-configure</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-14T23:55:00+08:00" pubdate data-updated="true">Feb 14<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/02/14/bochs-configure/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Bochs + freedos安装配置</h1>

<pre><code>sudo apt-get install build-essential

sudo apt-get install xorg-dev

sudo apt-get install libgtk2.0-dev
</code></pre>

<p>下载</p>

<pre><code>bochshttp://bochs.sourceforge.net/cgi-bin/topper.pl?name=See+All+Releases&amp;url=http://sourceforge.net/projects/bochs/files

$ tar vxaf bochs-2.5.1.tar.gz

$ cd bochs-2.5.1

$ ./configure –enable-debugger-enable-disasm

$ make

$ sudo make install
</code></pre>

<p>下载freedoshttp://bochs.sourceforge.net/diskimages.html 复制到工作目录下</p>

<h1>Bochs 配置 先通过dos引导，我们的软件复制在B盘下</h1>

<pre><code>############################################################### 
# Configuration file for Bochs 
###############################################################

# how much memory the emulated machine will have 
megs: 32

# filename of ROM images 
romimage: file=/usr/share/bochs/BIOS-bochs-latest 
vgaromimage: file=/usr/share/vgabios/vgabios.bin

# what disk images will be used 
floppya: 1_44=freedos.img, status=inserted 
floppyb: 1_44=pm.img, status=inserted

# choose the boot disk. 
boot: a

# where do we send log messages? 
# log: bochsout.txt

# disable the mouse 
mouse: enabled=0

# enable key mapping, using US layout as default. 
keyboard_mapping: enabled=1, map=/usr/share/bochs/keymaps/x11-pc-us.map

#enabled debug using xchg bx, bx

magic_break:enabled=1

可以通过下面方式来部署程序，当然，写成makefile最省事

$ sudo mount –o loop pm.img /mnt/floppy

$ sudo cp test.com /mnt/floppy

$ sudo umount /mnt/floppy
</code></pre>

<h1>bochs 调试</h1>

<p>调试方法很多，这里介绍最简单的方式之一。bochs 配置中增加 magic_break:enabled=1</p>

<p>代码中增加xchg bx, bx，bochs会停在代码出。当然，前提是bochs需要支持debug</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/02/03/objblock/">Objective-C Block</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-03T23:47:00+08:00" pubdate data-updated="true">Feb 3<span>rd</span>, 2012</time>
        
         | <a href="/blog/2012/02/03/objblock/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>block 有什么意义，特点等等，这些东西，实在是太复杂了，这里只是简单的总结一下block的内存管理。而且也仅仅限于objective-C的部分</p>

<h1>Block memory</h1>

<p>block 的内存管理，应该是最头疼的地方,就用这个来自WWDC的例子来解释一下吧。</p>

<p><img src="/images/objblock-1.png" alt="alt text" /></p>

<p>当程序运行到这里时，stack 空间中有 shared 变量和 captured 变量。</p>

<p>这里可以看出，__block 变量开始是处于stack上的。</p>

<p><img src="/images/objblock-2.png" alt="alt text" /></p>

<p>当程序运行到这里时，stack 空间中有 shared 变量，captured 变量和block1。</p>

<p>这里可以看出，block 类型的变量开始时也是处在stack上的。</p>

<p><img src="/images/objblock-3.png" alt="alt text" /></p>

<p>当程序运行到这里时，stack 空间中有 shared 变量，captured 变量和block1。</p>

<p>这里值得注意的就是当我们直接修改stack 上的captured变量时，block1中的captured变量仍然是原来的数值10。事实上，从const 我们就可以看出，block1中的captured变量是不能被修改的而且是从stack原有变量的一个const 拷贝。在block1中访问的captured变量是const拷贝的，也就是说block1中captured = 10，而不是原有的stack上的值 20。当然，在block1中，我们也不能修改captured变量。</p>

<h1>Copy block</h1>

<p>block在一开始是处在stack上的，这是为了考虑到效率的原因，但是，有时候是需要block的生命周期长于一开始的stack，这时，我们就通过copy block 来将block复制到heap。</p>

<p><img src="/images/objblock-4.png" alt="alt text" /></p>

<p>当程序执行完 block2 = [block1 copy];时，__block 类型变量shared，被复制到了heap中，很显然，shared变量需要被block和block2共享(当然还有stack也要共享)，而block2被移动到heap中，很可能生命周期会长于stack，所以，shared也被复制到了heap中。而block2中的captured 也被复制到了heap中。</p>

<p><img src="/images/objblock-5.png" alt="alt text" /></p>

<p>当程序执行完 block3 = [block2 copy];时, 我们看到的是，block2 和block3 其实指向的是同一片内存空间。事实上，block的数据结构中，保存了引用计数，而对于copy到heap中的block 再copy时，行为同普通对象retain一样，会使引用计数+1。那么如果我们对[block retain]会如何呢？ 实际上什么都没有发生，至少在现在的runtime版本下。因为retain中，不仅有引用计数+1在，而且retain的返回值，必须同返回调用对象的地址一样，而block的地址是可能变化的（stack or heap），所以，这里retain的行为几乎是被忽略掉的。</p>

<p>当heap中的block变量先于stack被销毁时，如调用 [block2 release]; [block3 release];，heap中的block2，block3 由于引用计数为0 而被销毁，而 __block 变量shared则还在heap中，因为stack还要使用，block1 也要使用。</p>

<p><img src="/images/objblock-6.png" alt="alt text" /></p>

<p>当heap中的block变量晚于stack时，显然，stack 被清除，function中也啥都没了。</p>

<p><img src="/images/objblock-7.png" alt="alt text" /></p>

<p>最后，当block2 和block3 都被release之后。则恢复到最初状态</p>

<p><img src="/images/objblock-8.png" alt="alt text" /></p>

<h1>block details</h1>

<p>当我们写出一个Block literal expression</p>

<pre><code>^ { printf("hello world\n"); }
</code></pre>

<p>事实上，编译器为我们生成了如下结构</p>

<pre><code>struct __block_literal_1 {
    void *isa;
    int flags;
    int reserved; 
    void (*invoke)(struct __block_literal_1 *);
    struct __block_descriptor_1 *descriptor;
};void __block_invoke_1(struct __block_literal_1 *_block) {
    printf("hello world\n");
}static struct __block_descriptor_1 {
    unsigned long int reserved;
    unsigned long int Block_size;
} __block_descriptor_1 = { 0, sizeof(struct __block_literal_1)}; 当Block literal expression 使用时 __block_literal_1 则会被初始化为：struct __block_literal_1 _block_literal = {
    &amp;_NSConcreteStackBlock,
    (1&lt;&lt;29), &lt;uninitialized&gt;,
    __block_invoke_1,
    &amp;__block_descriptor_1
   };
</code></pre>

<p>下一个例子</p>

<pre><code>int x = 10;
void (^vv)(void) = ^{printf("x is %d\n", x);};
x = 11;
vv();
编译器会生成如下结构
struct __block_literal_2{
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(struct __block_literal_2 *);
    struct __block_descriptor_2 *descriptor;
    const int x;
};
void __block_invoke_2(struct __block_literal_2 *_block){
    printf("x is %d\n", _block-&gt;x);
}
void struct __block_descriptor_2{
    unsigned long int reserved;
    unsigned long int block_size;
}__block_descriptor_2 = {0, sizeof(struct __block_literal_2)};
struct __block_literal_2 __block_literal_2 = {
    &amp;NSConcreteStackBlock,
    (1&lt;&lt;29),
    __block_invoke_2,
    &amp;__block_descriptor_2,
    x
};
</code></pre>

<p>block中使用的普通变量（int， char *）导入是const copy。普通对象则会retain。__block 类型变量则什么不做，只是保存一个指针，全局变量也只是保存一个简单的指针。</p>

<p>当然，block 可能也会嵌套block，那么又会是什么样子？其实不复杂，复杂的只是增加了复制函数，和释放函数，这一点很像C++的拷贝构造函数，在必要时生成。</p>

<pre><code>void (^existingBlock)(void) = …;
void (^vv)(void) = ^{existingBlock();};
vv();
struct __block_literal_3{
    ...;//esisting block
};
struct __block_literal_4{
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(struct __block_literal_4 *);
    struct __block_literal_3 *const existingBlock;
};
void __block_invoke_4(struct __block_literal_3 *__block) {
   __block-&gt;existingBlock-&gt;invoke(__block-&gt;existingBlock);
}
void __block_copy_4(struct __block_literal_4 *dst, struct __block_literal_4 *src) {
     //_Block_copy_assign(&amp;dst-&gt;existingBlock, src-&gt;existingBlock, 0);
     _Block_object_assign(&amp;dst-&gt;existingBlock, src-&gt;existingBlock, BLOCK_FIELD_IS_BLOCK);
}
void __block_dispose_4(struct __block_literal_4 *src) {
     // was _Block_destroy
     _Block_object_dispose(src-&gt;existingBlock, BLOCK_FIELD_IS_BLOCK);
}
static struct __block_descriptor_4 {
    unsigned long int reserved;
    unsigned long int Block_size;
    void (*copy_helper)(struct __block_literal_4 *dst, struct __block_literal_4 *src);
    void (*dispose_helper)(struct __block_literal_4 *);
} __block_descriptor_4 = {
    0,
    sizeof(struct __block_literal_4),
    __block_copy_4,
    __block_dispose_4,
};
</code></pre>

<p>初始化</p>

<pre><code>  struct __block_literal_4 _block_literal = {
    &amp;_NSConcreteStackBlock,
    (1&lt;&lt;25)|(1&lt;&lt;29), &lt;uninitialized&gt;
    __block_invoke_4,
    &amp; __block_descriptor_4
        existingBlock,
   };


__block storage variables

__block  变量是一种很特殊的数据类型，有自己的特有的数据结构

struct _block_byref_xxxx {
    void *isa;
    struct _block_byref_xxxx *forwarding;
    int flags;   //refcount;
    int size;
    // helper functions called via Block_copy() and Block_release()
    void (*byref_keep)(void  *dst, void *src); //需要时被生成
    void (*byref_dispose)(void *);//需要时被生成
    typeof(marked_variable) marked_variable;
};
</code></pre>

<p>看看__block 类型变量的使用</p>

<pre><code>int __block i = 10;
i = 11;
struct _block_byref_i {
    void *isa;
    struct _block_byref_i *forwarding;
    int flags;   //refcount;
    int size;
    int captured_i;
} i = { NULL, &amp;i, 0, sizeof(struct _block_byref_i), 10 };
i.forwarding-&gt;captured_i = 11;
</code></pre>

<p>显然，当block中增加了<strong>block 类型变量之后，嵌套block 的拷贝函数也会增加对</strong>block 变量的复制。</p>

<pre><code>__block void (voidBlock)(void) = blockA;
voidBlock = blockB;
struct _block_byref_voidBlock {
    void *isa;
    struct _block_byref_voidBlock *forwarding;
    int flags;   //refcount;
    int size;
    void (*byref_keep)(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src);
    void (*byref_dispose)(struct _block_byref_voidBlock *);
    void (^captured_voidBlock)(void);
};
void _block_byref_keep_helper(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src) {
    //_Block_copy_assign(&amp;dst-&gt;captured_voidBlock, src-&gt;captured_voidBlock, 0);
    _Block_object_assign(&amp;dst-&gt;captured_voidBlock, src-&gt;captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);
}
void _block_byref_dispose_helper(struct _block_byref_voidBlock *param) {
    //_Block_destroy(param-&gt;captured_voidBlock, 0);
    _Block_object_dispose(param-&gt;captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER)}
struct _block_byref_voidBlock voidBlock = {( .forwarding=&amp;voidBlock, .flags=(1&lt;&lt;25), .size=sizeof(struct _block_byref_voidBlock *),
      .byref_keep=_block_byref_keep_helper, .byref_dispose=_block_byref_dispose_helper,
      .captured_voidBlock=blockA )};
voidBlock.forwarding-&gt;captured_voidBlock = blockB;
</code></pre>

<p>block中，引入了__block 会是什么情况</p>

<pre><code>int __block i = 2;
functioncall(^{ i = 10; });
struct _block_byref_i {
    void *isa;  // set to NULL
    struct _block_byref_voidBlock *forwarding;
    int flags;   //refcount;
    int size;
    void (*byref_keep)(struct _block_byref_i *dst, struct _block_byref_i *src);
    void (*byref_dispose)(struct _block_byref_i *);
    int captured_i;
};
struct __block_literal_5 {
    void *isa;
    int flags;
    int reserved; 
    void (*invoke)(struct __block_literal_5 *);
    struct __block_descriptor_5 *descriptor;
    struct _block_byref_i *i_holder;
};
void __block_invoke_5(struct __block_literal_5 *_block) {
   _block-&gt;i_holder-&gt;forwarding-&gt;captured_i = 10;
}
void __block_copy_5(struct __block_literal_5 *dst, struct __block_literal_5 *src) {
     _Block_object_assign(&amp;dst-&gt;i_holder, src-&gt;i_holder, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);
}
void __block_dispose_5(struct __block_literal_5 *src) {
     _Block_object_dispose(src-&gt;i_holder, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);
}
static struct __block_descriptor_5 {
    unsigned long int reserved;
    unsigned long int Block_size;
    void (*copy_helper)(struct __block_literal_5 *dst, struct __block_literal_5 *src);
    void (*dispose_helper)(struct __block_literal_5 *);
} __block_descriptor_5 = { 0, sizeof(struct __block_literal_5) __block_copy_5, __block_dispose_5 };
struct _block_byref_i i = {( .forwarding=&amp;i, .flags=0, .size=sizeof(struct _block_byref_i) )};
struct __block_literal_5 _block_literal = {
    &amp;_NSConcreteStackBlock,
    (1&lt;&lt;25)|(1&lt;&lt;29), &lt;uninitialized&gt;,
    __block_invoke_5,
    &amp;__block_descriptor_5,
        2,
   };
</code></pre>

<p>block 中的太多细节这里不做赘述，有兴趣的可以参考Block—ABI-Apple，也可以直接<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/runtime.c">这里</a>去看。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/01/13/plan/">Plan</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-13T23:46:00+08:00" pubdate data-updated="true">Jan 13<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/01/13/plan/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>不知不觉又是一年，又大了一岁，呵呵，说的很假，因为自己并没有真正的意识到自己又大了一岁，甚至自己现在的年龄都不能一口说出来，过去的一年，甚至之前，我都不能准确的说出我自己到底做了什么，混沌，浑浑噩噩的一生，没有目标，一切都是随心，一切都是随心而发，没有目的，达成不达成，似乎都不重要。那么自己心里到底有什么在乎的了？不知道，那么还有什么感兴趣的呢？</p>

<p>庄子是我最佩服的人，千年前的古人，都可以去猜测天道，追逐天地之本，而做为现代人的我，从小都希望自己能够成为其中的一员，哪怕只是能够感知到一点，为此沉沦数学，物理。</p>

<p>什么是天道，天道不以人类意志左右，甚至和普通人意志相反。而这也就造就了普通人永远无法理解天道。所以，我从来没有觉得自己是普通人，甚至乐于反着做。而今天，我觉得，我错了，因为我现在自己都不了解，原来追求的东西，随着时间的打磨，已经逐渐淡去。现在做的，只是随心而动，追求自己内心的想法——每件事情，比别人多做一点，多深入一点，至于是什么事情，别人的看法，已经不重要了，我发现，我这个理科生，居然是一个彻头彻尾的唯心主义者。</p>

<p>人的一生是要不断学习的。这里面的动力很简单：因为我们在有些方面还“无知”， 无知是做事情的一个障碍。我们如果想做好事情，就要求知，要改变这种无知的状况。而对于创业这件事情，也是我这20多年来，做的最大的一件事情，1年前，对于创业，我还是处在，拿着无知当无畏的状态，而且，现在也没有好多少，但是，我很感谢我们这个Team，包容了我很多缺点，替我遮挡了许多细枝末节，使得我还有时间有精力追求自己内心的想法，而且我相信，我最终一定能够成功，但是这里面的代价实在是太大了，我甚至不能确定，而且害怕，这个时间太长，而那些身边默默支持我的人已经离去，甚至永远看不到了。</p>

<p>我最讨厌的人，就是浪费时间的人，因为，我自己已经浪费了自己20多年的青春。所以，当我在大三的时候，我就已经意识到，自己需要改变这一点——痛恨那些走在我前面档我走路的人，浪费我时间的人。</p>

<p>而现在，我发现，挡在我前面的那个人，不是别人，就是自己。自己的惰性，侥幸心里，成功考验的不仅是智力，更是意志。就像处在激发态的原子，时间会不断地侵蚀他的能量，而如果想要挣脱枷锁，只能是不断地更快地吸取更多的能量。就像鲲鹏，如果沉迷于大海，永远不可能越出水面，飞翔在空中。</p>

<p>呼呼，扯了好多，看看我这一年做了什么，1年前是离毕业还有半年时。</p>

<p>我很庆幸，因为，在很多人不知道自己以后应该做什么时，我知道了我该做什么，计算机就是为我而生的科学，我也很庆幸，我在离开大学的最后半年里，我能够把大学中学到的和没有学到的东西，捏合到了一起，明白了大学这些课程讲述的意义，汇编程序设计，计算机体系结构，编译原理等等耳熟能详的课程捏到一起，虽然不能融会贯通，但是计算机知识体系已经能够较为清晰的展现在脑海里，而这，也就是为什么我放弃考研的原因之一，不需要再学太多的理论来夯实基础，因为我不是要成为科学家，这些理论知识对现在的我来说已经足够，贪多嚼不烂。而更为重要的是，移动互联网，这一波已经滚滚而来，已经不可能在等我3年，就像我大二时，第一次用到智能手机时（Symbian不算）的感触，传统的PC应用已经不可能吸引我，除了mobile。</p>

<p>大学最后的半年，是在创业公司渡过的，第一次自己独立做项目（自己的毕设），而且是一个会正式发布的产品，对于我这样的一个二流大学毕业生来说已经不易。而后的毕业答辩，更是验证了我对学校的不屑，只能挑挑排版错误的导师，充满各种潜规则的评分，对我来说已经没有任何意义，90分和60分，同样没有区别。我唯一在意的是，最后半年，C++的基础打的更扎实了一点，windows消息机制的了解也更深入了一点。也不枉我在这里学习了将近1年的时间。</p>

<p>后半年，风雨突变，windows mobile 已经死在了IOS 和android 的车轮之下，顺应天意，转战IOS。</p>

<p>从0开始学习一个新的语言，新的平台，到产品上线，呵呵，虽然在Appstore 很惨淡，但是，我们并没有放弃，不说了，来年新产品上线再说，不信这个邪了。</p>

<p>总结之后，就要规划，虽然我实在是不想做这个规划，因为实在是不靠谱。1年的时间，说长不长，说短不短。不求别的，只求不浪费时间，全力学习，深入IOS 一点。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/13/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/11/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'studentdeng';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>








</body>
</html>
