
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不会开机的男孩</title>
  <meta name="author" content="studentdeng">

  
  <meta name="description" content="学习 Objective-C大概4个月了，居然给一个还没毕业的家伙吹了吹，呼，希望不要误人子弟。这里总结一下，毕竟这是第一次完整的讲一个东西。 附上PPTObjective-C Primary 。资源99%来自WWDC 2010 session 113。 Common Concepts &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://studentdeng.github.com/blog/page/11">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="不会开机的男孩" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">不会开机的男孩</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:studentdeng.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  	<li><a href="/">Blog</a></li>
  	<li><a href="/blog/archives">Archives</a></li>
	 <li><a href="/tags/index.html">Tags</a></li>
	<li><a href="/favorite/index.html">Favorite</a></li>
	<li><a href="/about/index.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/01/12/objcbase/">Objective-C 一些很基础的总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-12T23:39:00+08:00" pubdate data-updated="true">Jan 12<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/01/12/objcbase/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>学习 Objective-C大概4个月了，居然给一个还没毕业的家伙吹了吹，呼，希望不要误人子弟。这里总结一下，毕竟这是第一次完整的讲一个东西。</p>

<p>附上PPT<a href="http://files.cnblogs.com/studentdeng/Objective-CPrimary.pptx">Objective-C Primary</a> 。资源99%来自WWDC 2010 session 113。</p>

<p>Common Concepts</p>

<p>Objective-C 相对其他更了解的C++语言来说，还是有些不同的。如下表</p>

<p><img src="/images/objbase-1.png" alt="alt text" /></p>

<p>这里面有几点比较重要</p>

<p>Objective-C 中所有的类，其实是另一种“类”的对象，所以Objective-C 中的类方法，其实是另一种类的实例方法。 Objective-C Message
Objective-C 中没有静态变量，都是用全局变量实现的。
Category
如何给一个类增加一个函数方法，在C++中是不可能的（或是很难）但是在Objective-C中确实很简单的事情，category 做的就是这件事情。</p>

<p>当第一次看到category 时，我几乎肯定这是一个非常坑爹的设计，因为这个可以完美的覆盖原有类的方法，如果使用不当，绝对是灾难性的错误。但是，随着使用时间变长category 的好处也慢慢体会出来。</p>

<p>给系统原有的类或是第三方的类增加函数，而不用使用一个新的类，这样使用会更加方便，特别是使用IB时，不需要将系统的类换成自己定义的类，这样减少了非常多的移植问题和同步工作。
当然，如果使用不当，也会遇到问题</p>

<p>函数覆盖问题，之前提到过
增加大量的category 会降低系统性能，特别是如果大量的加到一些基础类上，如NSObject 等，因为，几乎整个系统都在使用这些类，而过多的category，不仅降低自己代码的效率，也会降低framework代码的效率，这里的效率，应该主要在类初始化上，和消息发送上面。
SEL</p>

<p>相关的内容在Objective C SEL
Memory Management
语言是离不开平台的，而内存管理，则是了解平台中最基础的部分。而cocoa touch 的内存设计也就是基于引用计数的设计，是针对很早以前的设备设计，显然不适合现在的硬件设备。但是，现在我们似乎没有其他的选择，在一开始学习时。</p>

<p>基于引用计数的内存管理，设计的本质其实就是一个Directed Acyclic Graph（有向无回图）</p>

<p><img src="/images/objbase-2.png" alt="alt text" /></p>

<p>对于引用计数的内存管理，这一点实在是不陌生，不管是什么语言，都会遇到一个问题，循环引用</p>

<p><img src="/images/objbase-3.png" alt="alt text" /></p>

<p>当形成回路时，循环引用发生，导致内存泄露。而对应的方法，不管是什么语言，都需要把引用分为强引用和弱引用</p>

<p><img src="/images/objbase-4.png" alt="alt text" /></p>

<p>解决引用循环的方法很多，但是实质上，都是通过抽象成父子关系来做，一个强引用，一个弱引用，图形下方的节点通过弱引用连接上面的节点，图形上方的节点，通过强引用连接下方节点。实例就是delegate，属性被声明为assign</p>

<p>Autorelease Pools
autorelease 应该是初学者最容易糊涂的地方，一开始我也非常害怕使用Autorelease 变量，因为，这些变量不仅会增大内存开销，而且使用不当，crash的位置就是main函数，调试器几乎没有任何帮助，但是仍然有非常多的framework是基于autorelease 变量的，所以还是需要屡屡。</p>

<p>cocoa touch 是事件驱动的，我们通过接受一个个的event来跑我们的程序，那么简单的讲，就是一个while的死循环，不断地获取一个event，处理一个event。</p>

<p><img src="/images/objbase-5.png" alt="alt text" /></p>

<p>处理event的时候，framework 帮我们建立了一个autorelease pool。</p>

<p><img src="/images/objbase-6.png" alt="alt text" /></p>

<p>当我们处理或是叫响应一个event时，比如调用了[NSDate date] 函数，这个函数，返回了一个autorelease 变量d</p>

<p>而这个变量，事实上是被autorelease pool 所引用。</p>

<p><img src="/images/objbase-7.png" alt="alt text" /></p>

<p>当一层层stack pop 之后，我们可以看到 autorelease 变量的生命周期</p>

<p><img src="/images/objbase-8.png" alt="alt text" /></p>

<p><img src="/images/objbase-9.png" alt="alt text" /></p>

<p>当调用[pool drain]后，autorelease pool 随之消失，伴随着还有那个var d，回到原点，在下一个event cycle</p>

<p><img src="/images/objbase-10.png" alt="alt text" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/16/objcsel/">Objective C SEL</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-16T23:37:00+08:00" pubdate data-updated="true">Oct 16<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/10/16/objcsel/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上一篇http://www.cnblogs.com/studentdeng/archive/2011/10/06/2199873.html，总结了一点关于Objective C message send 的有意思的东西，中间穿插了一点关于SEL有趣的东西，之前，我们知道Objective-C runtime 在处理selector时，是做一个unique hash set， 那么今天，我们看看这个set 是如何产生的。这篇文章参考了<a href="http://www.sealiesoftware.com/blog/archive/2009/09/01/objc_explain_Selector_uniquing_in_the_dyld_shared_cache.html">link</a></p>

<p>unique set的好处是，字符串的比较可以非常迅速，但是也带来一个棘手的问题，创建一个这样的集合，真的不容易。虽然我们能够在compiler和 link的时候保证我们程序中唯一，但是这还远远不够，因为我们并不是生活在真空中，我们的程序需要和各种各样的其他程序协同工作，那么如何能够在这种繁杂的各种情况下，保证唯一呢？</p>

<p>简单说，就是在程序A中，有一个@selector（customInit），但在程序A中引入了程序B，而B中也有一个@selector（customInit），那么，显然，我们需要修正这2个selector，使他们指向同一个内存地址，这样才能保证消息发送正确。</p>

<p>好吧，我们程序员又要惊呼了，这是一个非常非常大的开销，因为</p>

<p>1、我们只能在运行时做这些工作。</p>

<p>2、这些工作是不可能不绕过strcmp（创建hash表时，如果发生了冲突，我们为了保证绝对正确，只能strcmp）。</p>

<p>3、当我们修正之后，也意味着，我们浪费了空间，而实际上就是我们创建了一个更大的hashtable（元素越多，发生碰撞的概率越大，空间的开销越大），</p>

<p>4、代码段在被映射到内存地址空间时，都在可读地址空间上，那么修正，意味着我们又多做了copy-on-write，同样意味着更多的空间开销</p>

<p>5、事实上，这样的函数还非常多，那些界面库函数等等，几乎被所有app引用 e.g. init，initWithFrame:。</p>

<p>更多的空间，更多的比较，导致了性能下降，特别是在程序载入时。事实上，runtime 和os 为我们的selector unique 做了下面的优化，大体可以理解成2个部分</p>

<h2>1、减少需要修正的selector 集合</h2>

<p>之前，我们看到的只有一个hash set，在runtime 载入时创建，但是，现在我们有了2个set（这个set是在Snow Leopard被加入的）。</p>

<p>一个是之前我们知道的，另一个也是一个hash set 当然，特别的是，这是一个perfect hash set。</p>

<p>从之前的5条件中，我们知道了，这些常用的如系统库函数，cocoa.framework中的selector 几乎被所有app引用，而且，我们非常开心的看到了，这些函数，都是可以确定的固定集合。事实上，dyld（dynamic loader and linker），给我们build了一个dyld shared cache，而且是一个perfect hash。而这个被映射到了各种app内存地址空间，并被共享。当我们创建unique selector set 时，我们可以先查找这个perfect hash set，来判断，我们是不是需要动态扩展我们的程序自己的selector hash set。而且，由于是perfect hash，使我们能够拥有在最坏情况下常数时间的开销。</p>

<h2>2、延迟加载</h2>

<p>对于这个，我们已经不陌生了，不管是windows dll 中的延时加载，还是各种在linux中的动态模块的延时载入，原理都是一样的。这些工作，只有在认为是必要条件时，才被真正的加载并初始化。</p>

<p>说的实在是太空了，让我们来看代码吧。</p>

<p>当类被调用或是说在被发送消息之前，类，需要被初始化一下，做的工作就是一些，运行时必要的空间分配，初始化，修正selector，methodlist， propertylist，categorylist等等的工作，我们这里，只是关注selector部分。</p>

<p>prepareForMethodLookup->realizeClass –> methodizeClass->attachMethodLists->fixupMethodList.</p>

<p>经过一系列的东东，修正我们的methodlist时，我们需要将methodlist中的SEL 修正，而这个过程就是我们关注的select unique。</p>

<p>不知道，大家还记得不记得，上一篇讲的 method结构</p>

<pre><code>typedef struct method_list_t {

uint32_t entsize_NEVER_USE;  // low 2 bits used for fixup markers

uint32_t count;

struct method_t first;

} method_list_t;

typedef struct method_t {

SEL name;

const char *types;

IMP imp;

} method_t




static void 
fixupMethodList(method_list_t *mlist, BOOL bundleCopy) 
{ 
    assert(!isMethodListFixedUp(mlist));

    // fixme lock less in attachMethodLists ? 
    sel_lock();

    uint32_t m; 
    for (m = 0; m &lt; mlist-&gt;count; m++) {

        //studentdeng note：fixup selector and make sure selector unique 
        method_t *meth = method_list_nth(mlist, m); 
        SEL sel = sel_registerNameNoLock((const char *)meth-&gt;name, bundleCopy); 
        meth-&gt;name = sel;

        if (sel == (SEL)kIgnore) { 
            meth-&gt;imp = (IMP)&amp;_objc_ignored_method; 
        } 
    }

    sel_unlock();

    setMethodListFixedUp(mlist); 
}






sel_registerNameNoLock-&gt;__sel_registerName


static SEL __sel_registerName(const char *name, int lock, int copy) 
{ 
    SEL result = 0;

    if (lock) rwlock_assert_unlocked(&amp;selLock); 
    else rwlock_assert_writing(&amp;selLock);

    if (!name) return (SEL)0; 
    result = _objc_search_builtins(name); //studentdeng note:这里就是查找perfect hash set build by dyld cache 
    if (result) return result; 

    if (lock) rwlock_read(&amp;selLock); 
    if (_objc_selectors) { 
        result = __objc_sel_set_get(_objc_selectors, (SEL)name); //studentdeng note: 这里就是查找我们程序自己的hash set 
    } 
    if (lock) rwlock_unlock_read(&amp;selLock); 
    if (result) return result;

    // No match. Insert.

    if (lock) rwlock_write(&amp;selLock);

    if (!_objc_selectors) { 
        _objc_selectors = __objc_sel_set_create(NUM_NONBUILTIN_SELS); 
    } 
    if (lock) { 
        // Rescan in case it was added while we dropped the lock 
        result = __objc_sel_set_get(_objc_selectors, (SEL)name); 
    } 
    if (!result) { 
        result = (SEL)(copy ? _strdup_internal(name) : name); 
        __objc_sel_set_add(_objc_selectors, result); 
#if defined(DUMP_UNKNOWN_SELECTORS) 
        printf("\t\"%s\",\n", name); 
#endif 
    }

    if (lock) rwlock_unlock_write(&amp;selLock); 
    return result; 
}
</code></pre>

<p>牛b的代码，从来都是自解释的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/06/objcmessage/">Objective-C Message</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-06T23:35:00+08:00" pubdate data-updated="true">Oct 6<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/10/06/objcmessage/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>object c 里面有一个非常有趣的设计，如果之前了解过c++的家伙们，对object c 中的把传统的调用函数变成了向这个类发送消息，这个过程总是令人琢磨不透，在实际过程中遇到的crash也很难调试清楚。这篇就要详细的解释消息这个家伙。当然，消息这个涉及的东西实在是太多了。这篇先简单介绍一下。</p>

<p>上一篇，我们了解了什么是类http://www.cnblogs.com/studentdeng/archive/2011/10/01/2197194.html。同理这一篇，我们首先需要了解什么是message。</p>

<p>message（消息）：message的具体定义很难说，因为并没有真正的代码描述，简单的讲message 是一种抽象，包括了函数名+参数列表，他并没有实际的实体存在。</p>

<p>method（方法）：method是真正的存在的代码。如：- (int)meaning { return 42; }</p>

<p>selector: selector 通过SEL类型存在，描述一个特定的method or message。在实际编程中，可以通过selector来检索函数等操作。</p>

<p>我不知道上面这种描述有多少人可以明白，因为我觉得这3个每个人都可以有自己的看法，在了解object c message 的整个过程之后。</p>

<p>让我们从一个简单的例子开始。当我们写好如下的代码时</p>

<pre><code>- (int)foo:(NSString *)str { ...}
</code></pre>

<p>　　</p>

<p>编译器事实上转成了下面的样子</p>

<pre><code>int XXXX_XXXX_foo_(SomeClass *self, SEL _cmd, NSString *str) { ...}
</code></pre>

<p>　　</p>

<p>当我们写下发送消息的代码如</p>

<pre><code>int result = [obj foo:@"hello"];
</code></pre>

<p>　　</p>

<p>实际上变成了</p>

<pre><code>int result = ((int (*)(id, SEL, NSString *))objc_msgSend)(obj, @selector(foo:), @"hello");
</code></pre>

<p>　　</p>

<p>而 objc_msgSend 是一个我们非常熟悉的C函数定义 id objc_msgSend(id self, SEL    _cmd,&#8230;);
那么，object c 发送消息就变成了一个表面上看似容易理解的C函数调用了，这里有必要解释一下几个名词</p>

<pre><code>id：很多地方说id是一个void *的指针。事实上，id 其实是这样子的
typedef struct objc_object {
    Class isa;
} *id;
</code></pre>

<p>　　</p>

<p>也就是说。id其实是一个可以指向任何一个object指针（只要结构体中包含isa 指针） 。</p>

<pre><code>SEL：SEL 如果很粗鲁（我不知道改用什么其他词汇更容易描述）的讲，就是一个char * 的指针。因为你可以这样简单粗暴的测试

SEL selector = @selector(message); //@selector不是函数调用，只是给这个坑爹的编译器的一个提示
NSLog (@"%s", (char *)selector);  //print message 
</code></pre>

<p>　　</p>

<p>注：这里之所以说粗鲁，是因为，这个的定义和object runtime 的具体实现息息相关，未来很可能改变，而这些定义也是没有文档化的，后面还会详细介绍SEL的具体实现。因为这里有不少为了提高效率而做的优化。</p>

<p>不知道有没有人惊呼这个问题。特别是如果之前从事C++的家伙们。传统的C++ 编译器在处理函数上，为了支持函数重载。使用了一种函数别名的方式如</p>

<pre><code>int foo（int a）；
</code></pre>

<p>　　</p>

<p>变成了 XXX_1_foo_int （具体的形式没有意义，核心在于，编译器生成的函数签名包括函数名，参数类型，参数个数）。</p>

<p>但我们的SEL 仅仅是函数名而已。</p>

<p>有了这些知识做铺垫，原谅我在把这个东东再搬出来</p>

<pre><code>int result = ((int (*)(id, SEL, NSString *))objc_msgSend)(obj, @selector(foo:), @"hello");
</code></pre>

<p>　　</p>

<p>那么，作为程序员，我们就为这个而疯狂了，因为编译器无法根据id 和SEL 获得完整的函数签名，编译器对参数个数和类型，完全不知道。那么他如何能过做到识别这些并找到正确的代码呢？</p>

<p>事实上这个头痛的问题，编译器做了一个非常坑爹的事情，就是“ it cheats” ，他假装能够通过函数名，就能确定正确的代码。通过扫描之前的函数声明来做，如果没有找到，编译器就认为这是一个运行时（runtime）的函数而直接略过。而这也就导致了object c 在处理有相同函数名和参数个数但类型不同的函数时，非常的弱。如</p>

<pre><code>-(void)setWidth:(int)width；

-(void)setWidth:(double)width；
</code></pre>

<p>　　</p>

<p>这样的函数则被认为是一种编译错误，而这最终导致了一个非常非常奇怪的object c 特色的函数命名</p>

<pre><code>-(void)setWidthIntValue:(int)width；

-(void)setWidthDoubleValue:(double)width；
</code></pre>

<p>　　</p>

<p>注：这样的函数命名的好坏，只能说是因人而异的，站在我的角度来讲。object c 的这种命名实在是太臃肿了，这种冗长的名字让人感到作呕而没有任何美感。当然，这样的命名的确可以避免很多的错误，比如因C++ 函数重载而引起的人为上的小失误，而且减少了理解函数的负担。总有利弊，需要平衡：P，不过，我还是不喜欢object c 编译器，因为他彻底阻挡了你的想法，至于为什么这样设计，我的理解是为了runtime，在这里为了性能而做了妥协，具体原因，后面再讲。</p>

<pre><code>popup our brain stack
</code></pre>

<p>objc_msgSend 这里传入了 class 指针 self  函数名SEL 已经后面通过C的不定参数传入的参数。通过这些条件。就像之前的C++函数那样，需要查表，并找到相应函数的位置，然后call xxxxx。那么。object c 是如何找到这些函数的真实地址呢？ 之前有篇简单描述C++类函数布局的，有兴趣的可以对比的看。</p>

<p>为了解释这些这个过程，我们有需要介入一些名词了。</p>

<pre><code>object c 2 的

typedef struct method_list_t {
    uint32_t entsize_NEVER_USE;  // low 2 bits used for fixup markers
    uint32_t count;
    struct method_t first;
} method_list_t;

typedef struct method_t {
    SEL name;
    const char *types;
    IMP imp;
} method_t;
</code></pre>

<p>　　</p>

<p>method就是这么简单， 一个函数名SEL 一个包括的参数类型和返回类型的type 最后加一个IMP 而IMP 就是一个函数指针，指向我们真正的代码位置</p>

<pre><code>typedef id             (*IMP)(id, SEL, ...); 
</code></pre>

<p>　　</p>

<p>那么objc_msgSend 做的事情，就是通过我们传入的self 指针，找到class 的method_list 然后根据SEL 做比较，没有的话，就在super class 找，如此往复。直到找到匹配的SEL，然后，call imp。</p>

<p>那么，我们就发现了。如果object c 这样设计，调用函数的成本实在是太高了，相对传统的C函数调用。那么编译器和runtime又做了那些优化呢？有意思的事情开始了。</p>

<p>1、字符串比较
我们发现了SEL 就是简单的一个char* 字符串。那么，光是比较这一串字符，就可以让object c 慢的让人作呕了。那么我们就需要再认识一下我们的SEL了。</p>

<p>runtime 在实现selector是，实现了一个很大的Set，简单的说就是一个经过了杠杠优化过的hash表。而Set的特点就是唯一，也就是SEL是唯一的。那么对于字符串的比较仅仅需要比较他们的地址就可以了。犀利，速度上无语伦比，但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少，那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。这样如</p>

<p>class A 有一个这样的method  -(void)setWidth:(int)width；</p>

<p>而 classB 有一个这样的method -(void)setWidth:(double)width；</p>

<p>那么的selector 将指向同一个地方，使用同一个selector，如果真的需要在类中定义类似重载时，只能使用不同的函数名了。</p>

<p>但是，这样的优化，依然不能让人满意，因为，根据二八原则，我们真正执行的只是少数代码。那么。就有</p>

<p>2、cache
cache的原则就是缓存那些可能要执行的函数地址，那么下次调用的时候，速度就可以快速很多。这个和CPU的各种缓存原理相通。好吧，说了这么多了，再来认识几个名词</p>

<pre><code>struct objc_cache {
    uintptr_t mask;            /* total = mask + 1 */
    uintptr_t occupied;        
    cache_entry *buckets[1];
};

typedef struct {
    SEL name;     // same layout as struct old_method
    void *unused;
    IMP imp;  // same layout as struct old_method
} cache_entry;
</code></pre>

<p>　　</p>

<p>看这个结构，有没有搞错又是hash table。</p>

<p>objc_msgSend 首先在cache list 中找SEL 没有找到就在class 找，super class 找（当然super class 也有cache list）。</p>

<p>而cache的机制则非常复杂了，由于object c 是动态语言。所以，这里面还有很多的多线程同步问题，而这些锁又是效率的大敌，相关的内容已经远远超过本文讨论的范围。</p>

<p>popup our brain stack</p>

<p>有了上面的粗略的介绍，是时候让我们看看objc_msgSend 的真面目了，当然，对于这个家伙是和性能息息相关的东西，没有任何缘由的是用汇编来写的。这里面贴出x86的，原谅我已经把arm汇编忘记了（主要原因是arm汇编是老师教得，x86是自学的，没有听学校老师的 ：P）。</p>

<pre><code>/********************************************************************
 *
 * id objc_msgSend(id self, SEL    _cmd,...);
 *
 ********************************************************************/

    ENTRY    _objc_msgSend
    CALL_MCOUNTER    LP0

    movl    self(%esp), %eax

// check whether receiver is nil 
    testl    %eax, %eax
    je    LMsgSendNilSelf

// receiver is non-nil: search the cache
    CacheLookup WORD_RETURN, MSG_SEND, LMsgSendCacheMiss
    movl    $kFwdMsgSend, %edx    // flag word-return for _objc_msgForward
    jmp    *%eax            // goto *imp

// cache miss: go search the method lists
LMsgSendCacheMiss:
    MethodTableLookup WORD_RETURN, MSG_SEND
    movl    $kFwdMsgSend, %edx    // flag word-return for _objc_msgForward
    jmp    *%eax            // goto *imp

// message sent to nil object: call optional handler and return nil
LMsgSendNilSelf:
    EXTERN_TO_REG(__objc_msgNil,%eax)
    movl    0(%eax), %eax        // load nil message handler
    testl    %eax, %eax
    je    LMsgSendDone        // if NULL just return and don't do anything
    call    *%eax            // call __objc_msgNil
    xorl    %eax, %eax        // Rezero $eax just in case
LMsgSendDone:
    ret

LMsgSendExit:
    END_ENTRY    _objc_msgSend
</code></pre>

<p>　　</p>

<p>注释非常的详细+代码本身自解释，不做赘述，汇编的可读性都比我写的强，牛到不需要解释的代码。</p>

<p>MethodTableLookup 跳到__class_lookupMethodAndLoadCache</p>

<pre><code>/***********************************************************************
* lookUpMethod.
* The standard method lookup. 
* initialize==NO tries to avoid +initialize (but sometimes fails)
* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
* Most callers should use initialize==YES and cache==YES.
* May return _objc_msgForward_internal. IMPs destined for external use 
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
**********************************************************************/
__private_extern__ IMP lookUpMethod(Class cls, SEL sel, 
                                    BOOL initialize, BOOL cache)
{
    Class curClass;
    IMP methodPC = NULL;
    Method meth;
    BOOL triedResolver = NO;

    // Optimistic cache lookup
    if (cache) {
        methodPC = _cache_getImp(cls, sel);
        if (methodPC) return methodPC;    
    }

    // realize, +initialize, and any special early exit
    methodPC = prepareForMethodLookup(cls, sel, initialize);
    if (methodPC) return methodPC;


    // The lock is held to make method-lookup + cache-fill atomic 
    // with respect to method addition. Otherwise, a category could 
    // be added but ignored indefinitely because the cache was re-filled 
    // with the old value after the cache flush on behalf of the category.
 retry:
    lockForMethodLookup();

    // Try this class's cache.

    //// self note 这里再次查找cache 是因为有可能cache真的又有了，因为锁的原因
    methodPC = _cache_getImp(cls, sel);
    if (methodPC) goto done;

    // Try this class's method lists.

     //self note 这个就是简单的在method 一个线性查找，因为我们仅仅是一个地址比较
    meth = _class_getMethodNoSuper_nolock(cls, sel); 
    if (meth) {
        //我们找到了函数地址，那么添加到cachelist中
        log_and_fill_cache(cls, cls, meth, sel);
        methodPC = method_getImplementation(meth);
        goto done;
    }

    // Try superclass caches and method lists.

    curClass = cls;
    while ((curClass = _class_getSuperclass(curClass))) {
        // Superclass cache.
        meth = _cache_getMethod(curClass, sel, &amp;_objc_msgForward_internal);
        if (meth) {
            if (meth != (Method)1) {
                // Found the method in a superclass. Cache it in this class.
                log_and_fill_cache(cls, curClass, meth, sel);
                methodPC = method_getImplementation(meth);
                goto done;
            }
            else {
                // Found a forward:: entry in a superclass.
                // Stop searching, but don't cache yet; call method 
                // resolver for this class first.
                break;
            }
        }

        // Superclass method list.
        meth = _class_getMethodNoSuper_nolock(curClass, sel);
        if (meth) {
            log_and_fill_cache(cls, curClass, meth, sel);
            methodPC = method_getImplementation(meth);
            goto done;
        }
    }

    // No implementation found. Try method resolver once.

    if (!triedResolver) {
        unlockForMethodLookup();
        _class_resolveMethod(cls, sel);
        // Don't cache the result; we don't hold the lock so it may have 
        // changed already. Re-do the search from scratch instead.
        triedResolver = YES;
        goto retry;
    }

    // No implementation found, and method resolver didn't help. 
    // Use forwarding.

    _cache_addForwardEntry(cls, sel);
    methodPC = &amp;_objc_msgForward_internal;

 done:
    unlockForMethodLookup();

    // paranoia: look for ignored selectors with non-ignored implementations
    assert(!(sel == (SEL)kIgnore  &amp;&amp;  methodPC != (IMP)&amp;_objc_ignored_method));

    return methodPC;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/05/objcclass/">Objcclass</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-05T23:31:00+08:00" pubdate data-updated="true">Oct 5<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/10/05/objcclass/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>之前一直做C++开发，最近2个多月转 Objective-C， 入门的时候，遇到了很多的困惑。现在过节，正是解决他们的好时机。</p>

<p>主要参考来自http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</p>

<p> Objective-C 也是面向对象的语言，那么，首先需要知道的就是什么是class。</p>

<p>C++ 的class相对 Objective-C 中的class，就简单明了很多了。C++ 中class简单的说，就是一个大的struct， 绝大部分的class可以在编译时决定好class的布局（通过虚继承来的class成员变量只能动态确定）。当然，最关键的是，你不可能在运行时创建一个class，因为所有的class在运行之前已经确定下来，并保存在二进制文件中。</p>

<p>但是， Objective-C 确不同， Objective-C 可以在运行中创建class，修改class等等。那么，改如何定义 Objective-C 中的class呢。</p>

<p>在这之前，我们先看一个简单的，class的实例对象。</p>

<pre><code>@interface Object 
{

    //typedef struct objc_class *Class; 
    Class isa;    /* A pointer to the instance's class structure */ 
}
</code></pre>

<p>对象包含一个指向class的指针，而这也就意味着，任何包含class 的指针都可以被看做是对象（object）。</p>

<pre><code>struct objc_class {            
    struct objc_class *isa;    //这里也有isa指针 
    struct objc_class *super_class;    //这里还有一个指向基类的指针 
    const char *name;        
    long version; 
    long info; 
    long instance_size; 
    struct objc_ivar_list *ivars;

    struct objc_method_list **methodLists;

    struct objc_cache *cache; 
     struct objc_protocol_list *protocols; 
};

//新的定义
typedef struct class_t {

    struct class_t *isa;

    struct class_t *superclass;

    Cache cache;

    IMP *vtable;

    class_rw_t *data;

} class_t;
</code></pre>

<p>显然，在 Objective-C 眼中，一切都是对象，甚至包括我们的class。而对象就是class的实例，那么，class是什么的实例呢，metaclass。</p>

<p>事实上，我们并没有解决问题。metaclass 事实上又是root metaclass 的实例，而root metaclass 自己又是 root metaclass 的实例，一图胜千言，不做赘述。</p>

<p><img src="/images/objc.png" alt="alt text" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/26/hash/">Hash</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-26T23:28:00+08:00" pubdate data-updated="true">Aug 26<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/08/26/hash/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在应用程序中，常常需要将一个集合U（键值集合）和另一个集合T（数据集合）建立关系构造dictionary结构，来达到增删查改的需求。如果键值集合很小，那么可以直接采用Direct-address tables的方式实现。</p>

<p>假如我们的集合 U = {0, 1, &#8230;, m - 1}, 而且m并不大。如果我们的键和值对应唯一，那么我们可以通过构造一个大的数组来保存集合U，如下结构。</p>

<p><img src="/images/hash-1.png" alt="alt text" /></p>

<p>显然，当集合U增大，那么直接存储集合U变的不那么明智起来，而且，如果使用键的集合K变小是，我们浪费的空间也越来越大。当集合K比集合U小很多的时候，就是hash粉墨登场的时候了。hash将保存空间压缩到集合K的大小，并且控制查找元素的时间仍在O(1) 在平均情况下。</p>

<p>hash 通过hash函数h，将集合U 映射到hash表T[0,…, m-1]中， 即 h : U → {0, 1, &#8230;, m - 1}。显然，由于集合大小的限制，很可能造成有相同的key 指向了hash表中的同一项，如图。</p>

<p><img src="/images/hash-2.png" alt="alt text" /></p>

<p>我们将这一情况称为碰撞（Collision），解决碰撞的方法很多，最容易想到的是通过链表来保存碰撞的key。</p>

<p><img src="/images/hash-3.png" alt="alt text" /></p>

<p>一个简单的例子，linux2.4 在处理进程中，需要一个通过pid找到进程的要求，而具体实现则是利用了hash。在处理冲突时，采用的是链表的方法。不过由于是操作系统的代码，所以这里并不是通常意义的双向链表，pidhash_next 指向后一个进程，但是pidhash_pprev指向的是前一个进程的pidhash_next的地址。虽然不长，但是理解这段还是需要稍微动下脑筋，系统之所以这么实现，似乎是能够提高增加和删除时链表的效率。</p>

<pre><code>/* PID hashing. (shouldnt this be dynamic?) */ 
#define PIDHASH_SZ (4096 &gt;&gt; 2) 
extern struct task_struct *pidhash[PIDHASH_SZ]; 
#define pid_hashfn(x) ((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1)) 

static inline void hash_pid(struct task_struct *p) 
{ 
    struct task_struct **htable = &amp;pidhash[pid_hashfn(p-&gt;pid)]; 
    if((p-&gt;pidhash_next = *htable) != NULL)//如果发生的冲突 
        (*htable)-&gt;pidhash_pprev = &amp;p-&gt;pidhash_next;//这里可以看出，pprev是上一个进程的next指针的地址 
    *htable = p; 
    p-&gt;pidhash_pprev = htable;//新的进程的pprev是指向了hash表项中的自己的地址 
} 
static inline void unhash_pid(struct task_struct *p) 
{ 
    if(p-&gt;pidhash_next)//如果有冲突 
        p-&gt;pidhash_next-&gt;pidhash_pprev = p-&gt;pidhash_pprev; 
    *p-&gt;pidhash_pprev = p-&gt;pidhash_next;//当没有冲突时，就会置NULL 
} 
static inline struct task_struct *find_task_by_pid(int pid) 
{ 
    struct task_struct *p, **htable = &amp;pidhash[pid_hashfn(pid)]; 
    for(p = *htable; p &amp;&amp; p-&gt;pid != pid; p = p-&gt;pidhash_next); 
    return p; 
}
</code></pre>

<p>SGI STL的例子 hash</p>

<p>SGI STL中的hashtable 同样采用的是开链法设计，这里就是hashtable中节点的样子</p>

<pre><code>template &lt;class _Val&gt; 
struct _Hashtable_node 
{ 
    _Hashtable_node* _M_next; 
    _Val _M_val; 
};
</code></pre>

<p>这里可以看出，hashtable并没有利用现有的list等容器，而是自己简单的创建一个单向链表并维护。由于hashtable中的每一项元素都是一连串的数据（处理冲突而在一个链表中），所以将hashtable中的元素成为bucket，表示这个元素其实可能有“一桶子”东西，最后hashtable通过vector管理bucket，实现动态增长。</p>

<p>同之前一样，首先从iterator开始了解。下面是hashtable的iterator实现。</p>

<pre><code>template &lt;class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc&gt;
struct _Hashtable_iterator {
  typedef hashtable&lt;_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc&gt;
          _Hashtable;
  typedef _Hashtable_iterator&lt;_Val, _Key, _HashFcn, 
                              _ExtractKey, _EqualKey, _Alloc&gt;
          iterator;
  typedef _Hashtable_const_iterator&lt;_Val, _Key, _HashFcn, 
                                    _ExtractKey, _EqualKey, _Alloc&gt;
          const_iterator;
  typedef _Hashtable_node&lt;_Val&gt; _Node;
  typedef forward_iterator_tag iterator_category; 
  typedef _Val value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef _Val&amp; reference;
  typedef _Val* pointer;
  _Node* _M_cur;         //指向当前的节点
  _Hashtable* _M_ht;     //指向hashtable容器
  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) 
    : _M_cur(__n), _M_ht(__tab) {}
  _Hashtable_iterator() {}
  reference operator*() const { return _M_cur-&gt;_M_val; }
#ifndef __SGI_STL_NO_ARROW_OPERATOR
  pointer operator-&gt;() const { return &amp;(operator*()); }
#endif /* __SGI_STL_NO_ARROW_OPERATOR */
  iterator&amp; operator++();
  iterator operator++(int);
  bool operator==(const iterator&amp; __it) const
    { return _M_cur == __it._M_cur; }
  bool operator!=(const iterator&amp; __it) const
    { return _M_cur != __it._M_cur; }
};
</code></pre>

<p>可以看出，这里的迭代器设计成只能向后移动，在operator ++ 中，我们可以看到迭代器的移动。</p>

<pre><code>template &lt;class _Val, class _Key, class _HF, class _ExK, class _EqK, 
class _All&gt;
_Hashtable_iterator&lt;_Val,_Key,_HF,_ExK,_EqK,_All&gt;&amp;
_Hashtable_iterator&lt;_Val,_Key,_HF,_ExK,_EqK,_All&gt;::operator++()
{
    const _Node* __old = _M_cur;
    _M_cur = _M_cur-&gt;_M_next;
    if (!_M_cur) {
        size_type __bucket = _M_ht-&gt;_M_bkt_num(__old-&gt;_M_val);
        while (!_M_cur &amp;&amp; ++__bucket &lt; _M_ht-&gt;_M_buckets.size())
           _M_cur = _M_ht-&gt;_M_buckets[__bucket];
     }
     return *this;
}
</code></pre>

<p>首先在链表（一个bucket）中寻找下一个节点，如果是链表中的最后一个节点，那么寻找下一个链表（bucket）中的节点。了解迭代器之后，开始了解容器本身。</p>

<p>之前可以看出，SGI STL 虽然采用的是开链法，但是在分配空间大小时，依然采用的是质数，这一点和.net framework 中的dictionary一样。大小差不多是2倍</p>

<pre><code>static const int __stl_num_primes = 28;
static const unsigned long __stl_prime_list[__stl_num_primes] =
{
  53ul,         97ul,         193ul,       389ul,       769ul,
  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, 
  1610612741ul, 3221225473ul, 4294967291ul
};
//找到下一个大于n的质数，lower_bound是一个二分法查找。
inline unsigned long __stl_next_prime(unsigned long __n)
{
  const unsigned long* __first = __stl_prime_list;
  const unsigned long* __last = __stl_prime_list + __stl_num_primes;
  const unsigned long* pos = lower_bound(__first, __last, __n);
  return pos == __last ? *(__last - 1) : *pos;
}
</code></pre>

<p>  hashTable 中最重要的部分是扩容。那么，我们看看，SGI STL是怎么做的</p>

<pre><code>pair&lt;iterator, bool&gt; insert_unique(const value_type&amp; __obj) 
{ 
  resize(_M_num_elements + 1); 
  return insert_unique_noresize(__obj); 
}

template &lt;class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All&gt;
void hashtable&lt;_Val,_Key,_HF,_Ex,_Eq,_All&gt;
  ::resize(size_type __num_elements_hint)
{
  const size_type __old_n = _M_buckets.size();
  if (__num_elements_hint &gt; __old_n) {
    //如果需要扩容，我们找到下一个质数
    const size_type __n = _M_next_size(__num_elements_hint);
    if (__n &gt; __old_n) {
      //搞一个新的buckets
      vector&lt;_Node*, _All&gt; __tmp(__n, (_Node*)(0),
                                 _M_buckets.get_allocator());
      __STL_TRY {
        for (size_type __bucket = 0; __bucket &lt; __old_n; ++__bucket) {
          //遍历之旧的buckets
          _Node* __first = _M_buckets[__bucket];
          while (__first) {
            //遍历旧的bucket，这里，我们根据新的大小找到了新的位置
            size_type __new_bucket = _M_bkt_num(__first-&gt;_M_val, __n);
            //将旧的bucket数据改为 我们正在处理的item的下一个 
            _M_buckets[__bucket] = __first-&gt;_M_next;
            //把我们现在处理的item 插入到新的buckets中。
            __first-&gt;_M_next = __tmp[__new_bucket];
            __tmp[__new_bucket] = __first;
            //将我们当前处理的item，修改为旧数据的下一个
            __first = _M_buckets[__bucket];          
          }
        }
        //都搞定了，我们将buckets更换。
        _M_buckets.swap(__tmp);
      }
#ifdef __STL_USE_EXCEPTIONS
      catch(...) {
        for (size_type __bucket = 0; __bucket &lt; __tmp.size(); ++__bucket) {
          while (__tmp[__bucket]) {
            _Node* __next = __tmp[__bucket]-&gt;_M_next;
            _M_delete_node(__tmp[__bucket]);
            __tmp[__bucket] = __next;
          }
        }
        throw;
      }
#endif /* __STL_USE_EXCEPTIONS */
    }
  }
}
</code></pre>

<p>当然，这个只是insert_unique ，insert_equal 类似，这里不做描述。</p>

<p>除了resize，hashtable中还有一个吸引我们的就是hash func。但是，一般我们并不会指定hash func， 那么，我们看看SGI STL 是如何选择hash 函数的。</p>

<pre><code>#ifndef __SGI_STL_HASH_FUN_H
#define __SGI_STL_HASH_FUN_H
#include &lt;stddef.h&gt;
__STL_BEGIN_NAMESPACE
template &lt;class _Key&gt; struct hash { };
//字符串这里看来稍微有了一些操作
inline size_t __stl_hash_string(const char* __s)
{
  unsigned long __h = 0; 
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}
//这些东西，通过c++ 模板偏特化实现，我们看到，这些东西，啥都没做，只是返回而已。所以，如果
//希望获得最佳的性能，实现仿函数。是非常必要的。
__STL_TEMPLATE_NULL struct hash&lt;char*&gt;
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};
__STL_TEMPLATE_NULL struct hash&lt;const char*&gt;
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};
__STL_TEMPLATE_NULL struct hash&lt;char&gt; {
  size_t operator()(char __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned char&gt; {
  size_t operator()(unsigned char __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;signed char&gt; {
  size_t operator()(unsigned char __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;short&gt; {
  size_t operator()(short __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned short&gt; {
  size_t operator()(unsigned short __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;int&gt; {
  size_t operator()(int __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned int&gt; {
  size_t operator()(unsigned int __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;long&gt; {
  size_t operator()(long __x) const { return __x; }
};
__STL_TEMPLATE_NULL struct hash&lt;unsigned long&gt; {
  size_t operator()(unsigned long __x) const { return __x; }
};
</code></pre>

<p>SQLite 的hash表。</p>

<p>SQLite是在移动设备上普遍的一个家伙， 他用到了2种HASH， 一种和上面的SGI STL 类似，在PC端，在做增加的时候，判断了数据量大小（一般10个），如果小于，则采用双向链表的方式，不是则采用hash存储。只是，在移动分支中我没有找到，PC端的确有这样的设计，也许在mobile上做了精简。这种hash，用于SQLite底层的内存管理，缓存部分，SQLite采用的是LRU的方式缓存。</p>

<p>另一种Hash是叫做perfect hash。这是一种在最坏情况下，依然能够达到O(1) 的能力，听上去似乎挺吓人的，但是大多数是指固定的表，当然，似乎有些能够做到动态保证，不过，不管他了，我可不是科学家。</p>

<p>SQLite 的前端是需要做词法语法分析的。这部分就涉及到了关键字的保存，这里SQLite 通过perfect hash来达到快速查找。具体的策略了解编译原理的都比较明白，但是，这个的确比较有意思。</p>

<p>构造关键字是通过一个起始位置和长度来获取的。如 “REINDEX 、 INDEXED 、 INDEX 、 DESC”；将保存成“REINDEXEDESC”。那么 REINDEX = （0， 7）。而剩下的工作可以交给一些程序，他们会帮助我们生成perfect hash。</p>

<p>大数据量下，hash信息指纹的应用。可以参考 google黑板报  http://www.google.com.hk/ggblog/googlechinablog/2006/08/blog-post_8115.html</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/12/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/10/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - studentdeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'studentdeng';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>
