<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 不会开机的男孩]]></title>
  <link href="http://studentdeng.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://studentdeng.github.com/"/>
  <updated>2014-04-08T19:24:58+08:00</updated>
  <id>http://studentdeng.github.com/</id>
  <author>
    <name><![CDATA[studentdeng]]></name>
    <email><![CDATA[studentdeng@hotmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Design Patterns in iOS — Class Clusters]]></title>
    <link href="http://studentdeng.github.com/blog/2014/04/08/design-patterns-class-clusters/"/>
    <updated>2014-04-08T14:49:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/04/08/design-patterns-class-clusters</id>
    <content type="html"><![CDATA[<p>我对设计模式一直都是一个若有若无的感觉，特别是在手机端开发，觉得用处不是很大，认为设计模式是为了大规模团队合作，分工才能体现出效果。设计模式可以通过分不同的“层”让大家协同开发，相互之间不产生影响。但是最近看法有点改变，觉得还是需要多少了解一些。</p>

<p>天天使用的framework确实是一个庞大的项目，从framework的设计中可以找到很多设计模式的影子，而且还是一个很好的生产化的例子。这里先介绍 Class Clusters</p>

<p>Class Clusters 几乎涉及到iOS日常的所有开发过程中，也可能正是这样，导致我们很容易把它彻底遗忘。这里就拿最常用的 NSString 来讲。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">NSString</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">string1</span> <span class="o">=</span> <span class="s">@&quot;helloworld&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">string2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="s">@&quot;:%@&quot;</span><span class="p">,</span> <span class="s">@&quot;helloworld&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">string3</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSHomeDirectory</span><span class="p">()</span> <span class="nl">stringByAppendingPathComponent:</span><span class="n">string1</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSTextStorage</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">storage</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTextStorage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString:</span><span class="n">string1</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">string4</span> <span class="o">=</span> <span class="p">[</span><span class="n">storage</span> <span class="n">string</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string1</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string2</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string3</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">string4</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>不知道有多少人试过哈，string3的返回还是让我吃了一惊。下面的结果是在Xcode5.1 SDK7.1 下的结果。</p>

<pre><code>__NSCFConstantString
__NSCFString
NSPathStore2
NSBigMutableString
</code></pre>

<p>通过上面的方法创建的 NSString 最后都产生了不同的子类。有人可能会奇怪为什么需要不同的 NSString。因为对于大部分的以阅读内容为主的App来讲，很大部分资源消耗在了字符串处理上面（存储，解析，比较等等），所以对于字符串的存储需要有不同的方式来满足不同的情况，这样才能有性能上的提高。</p>

<p><div class='notebox'><p><strong>Note: </strong>设想一下，在这些场景上面，如果Apple直接把这些类扔给开发者，会有什么问题呢？</p></p><p><p>那么开发者需要自己在不同的场景决定使用不同的子类，不仅学习成本提高，而且也容易生成性能不太好的代码。<br/>现在简单的 NSString 就可以直接覆盖上面的所有场景。而且随着iOS的软硬件的后续开发，开发者还可以在不修改代码的情况下获得性能提升。</p></div></p>

<p>既然看到了它的强大之处，那么就开始了解吧。
既然这是第一篇DesignPattern那么就从最简单开始 ：)</p>

<h2>Abstract Classes</h2>

<p>这里引用一下Mike的内容</p>

<p><blockquote><p>An abstract class is a class which is not fully functional on its own. It must be subclassed, and the subclass must fill out the missing functionality.</p></p><p><p>An abstract class is not necessarily an empty shell. It can still contain a lot of functionality all on its own, but it's not complete without a subclass to fill in the holes.</p><footer><strong>Mike Ash</strong> <cite><a href='https://mikeash.com/pyblog/friday-qa-2010-03-12-subclassing-class-clusters.html'>Friday Q&amp;A 2010-03-12: Subclassing Class Clusters</a></cite></footer></blockquote></p>

<p>Abstract Class 的概念很简单，类中所有的方法不需要全部有具体的实现，相当于定义了很多的接口。比如一开始的 NSString</p>

<h2>Class Clusters</h2>

<p><blockquote><p>A class cluster is a hierarchy of classes capped off by a public abstract class. The public class provides an interface and a lot of auxiliary functionality, and then core functionality is implemented by private subclasses. The public class then provides creation methods which return instances of the private subclasses, so that the public class can be used without knowledge of those subclasses.</p><footer><strong>Mike Ash</strong> <cite><a href='https://mikeash.com/pyblog/friday-qa-2010-03-12-subclassing-class-clusters.html'>Friday Q&amp;A 2010-03-12: Subclassing Class Clusters</a></cite></footer></blockquote></p>

<p>Clusters的角色不仅要实现 Abstract Class 的方法，还需要自己实现自己的特殊化需求。Abstract Class 负责提供一个“外壳”，真正“干活”的就是Cluster class。这样外部就只需要了解Abstract Class就可以了。</p>

<h2>NSString Benefits</h2>

<p>比如 __NSCFConstantString 负责 const string，类似 @"helloworld"这样的字符串。这样的字符串有一个特点，不会被修改，当真正处理的时候，可以分配大小合适的内存，甚至可以分配在只读 data segment上面，而不需要分配在堆上面，如果有相同的字符串引用就可以完全赋值相同的地址。那么在retainCount上面的处理也就和其他字符串处理有很大不同。</p>

<p>NSPathStore2 看上去是处理有Path相关的字符串，因为没有源代码，这里我们可以大胆猜测一下，path相关的主要是做字符串的拼接操作，而这些字符串通常很长，占用空间大，但是重复的概率缺很高，那么就可以缓存一些字符串，这样可以减少一些内存的分配释放开销。</p>

<h2>How to use</h2>

<p><blockquote><p>The class cluster architecture involves a trade-off between simplicity and extensibility: Having a few public classes stand in for a multitude of private ones makes it easier to learn and use the classes in a framework but somewhat harder to create subclasses within any of the clusters.</p><footer><strong>Apple Develpoer Document</strong> <cite><a href='https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/ClassCluster.html'>Cocoa Core Competencies</a></cite></footer></blockquote></p>

<p>就像Apple文档中提到的，Class Cluster 是在简单和扩展性上面做了一个妥协。Class Clusters 的子类化比较麻烦，而且也看上去也非常trick,Apple 更推荐的方法是用组合的方法来扩展。</p>

<p>大家都知道设计模式有一个非常重的坑就是被过渡设计。Class Cluster 可以帮我们</p>

<ul>
<li>减少了if else 这样缺乏扩展性的代码</li>
<li>增加新功能支持不影响其他代码</li>
</ul>


<p>那么这个非常适合应用在适配上面，比如不同屏幕的适配，不同厂家可能的不同的需求。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">alloc</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">SFSSearchTVC</span> <span class="n">class</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">([</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemMajorVersion</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">SFSSearchTVC6</span> <span class="n">alloc</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemMajorVersion</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">SFSSearchTVC7</span> <span class="n">alloc</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="n">alloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p></li>
</ul>


<p>上面是代码来自<a href="http://bjmiller.me/post/69043165385/a-cluster-to-remove-clutter">BJ Miller's blog A Cluster to Remove Clutter</a>
是用于适配iOS6，iOS7的简单例子。</p>

<h2>Conclusion</h2>

<p>很多设计模式都很像，也很容易糊涂，比如工厂模式和Class Clusters在某些地方就很类似，我自己也并不能很好的分清楚。
设计模式的本质是为了解耦。不管使用哪个设计模式，我们最后追求的都是简单、容易维护和扩展的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth Concept]]></title>
    <link href="http://studentdeng.github.com/blog/2014/03/22/corebluetooth/"/>
    <updated>2014-03-22T20:41:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/03/22/corebluetooth</id>
    <content type="html"><![CDATA[<p>Core Bluetooth 里面的名词还是挺多的，这里简单记录一下，一上来的时候，还是很容易混淆的，这里记录一下。</p>

<h1>Basic Concept</h1>

<p>Bluetooth low energy (<a href="http://en.wikipedia.org/wiki/Bluetooth_low_energy#Radio_interface">BLE</a>，还有地方叫做BTLE，最恨各种简写了) 简单说是一种低功耗的短距离无线传输技术，主要用于低功耗设备传输，比如心率、记步器、智能家居方向,还有连接其他iOS设备。</p>

<p>Core Bluetooth API 支持BLE4.0，做了协议封装，让开发者不需要完整了解BLE协议就可以快速开发APP。</p>

<h2>Central and Peripheral</h2>

<p>BLE中有2个非常重要的概念就是Central和Peripheral，有一点类似Client Server。</p>

<ul>
<li>Peripheral是数据的发送方（比如运动手环需要把位置，步数等数据传递给其他设备）。</li>
<li>Central是数据的接收方（比如手机接收手环传递来的步数）</li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue1.png" alt="1-1 Central 和 Peripheral 心率设备和Apple product" /></p>

<h2>Centrals Discover and Connect to Peripherals That Are Advertising</h2>

<ul>
<li><p>Peripheral把advertising packets广播出去，advertising packet 包括会包含一些重要的信息，比如设备名字，所提供的服务。</p></li>
<li><p>Central 则是扫描自己感兴趣的advertising packet，比如一个APP需要查找当前家里的室温，会通过参数设定，只是检索温度设备发来的packet。</p></li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue2.png" alt="1-2 一个简单的advertising模型" /></p>

<h2>Data structure</h2>

<ul>
<li>Peripheral 是最上层的一种服务抽象，比如iOS 系统内置的<a href="http://studentdeng.github.io/blog/2014/03/22/ancs/">ANCS</a>服务,另外我们自己也可以创建自己的服务。</li>
<li>characteristic 则是用来描述服务中的具体内容（比如手环有传递行走路程的接口，还有行走位置的接口），一个服务可以包含多个characteristics。</li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue3.png" alt="1-3 心率检测仪包含1个服务，1个服务中包含2个characteristics,一个用来传递心率，一个用来传递位置" /></p>

<h1>How to</h1>

<p><a href="https://github.com/kickingvegas/YmsCoreBluetooth">YmsCoreBluetooth</a> 是个不错的框架，有很详细的<a href="http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/docs/tutorial/Tutorial.html">介绍</a>，这里就不赘述了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apple Notification Center Service]]></title>
    <link href="http://studentdeng.github.com/blog/2014/03/22/ancs/"/>
    <updated>2014-03-22T15:42:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/03/22/ancs</id>
    <content type="html"><![CDATA[<h1>名词解释与约定</h1>

<h2>名词解释</h2>

<ul>
<li>Apple Notification Center Service 简称 ANCS。</li>
<li>ANCS 服务（iOS设备，如iPhone，iPad等）的publisher 称为 Notification Provider。</li>
<li>任意的ANCS服务的client（硬件设备，配件）称为 Notification Consumer。</li>
<li>Generic Attribute Profile简称GATT。</li>
<li>在iOS NotificationCenter 显示的通知称为 iOS notification。</li>
<li>通过GATT characteristic 发布的通知称为 GATT notification。</li>
<li>iPhone、 iPad等运行iOS系统的设备称为iOS设备</li>
</ul>


<h2>约定</h2>

<p>文本档覆盖的内容中除特别描述外，和字节序相关的都是用Little-endian (小端模式)。
文本档覆盖的内容中除特别描述外，和字符串传递相关的都是UTF-8</p>

<p><div class='notebox'><p><strong>Note: </strong>ANCS 并不保证始终存在，服务开启，关闭机制由iOS系统决定，Device 需要一直检测，查找ANCS是否存在。</p></div></p>

<h1>协议内容</h1>

<p>ANCS的uart profile UUID : ” 7905F431-B5CE-4E99-A40F-4B1E122D00D0”</p>

<p>uart profile 中包括3个 characteristic</p>

<ul>
<li>Notification Source   UUID: “9FBF120D-6301-42D9-8C58-25E699A21DBD” (notifiable)</li>
<li>Control Point             UUID: “69D1D8F3-45E1-49A8-9821-9BBDFDAAD9D9”(write with             response)</li>
<li>Data Source           UUID:” 22EAC6E9-24D6-4BB5-BE44-B36ACE7C7BFB "(notifiable)</li>
</ul>


<p>Device端Notification Source 是必须实现的。Centrol Point 和 Data Source 可选。</p>

<h2>Notification Source Characteristic</h2>

<p>Notification Source characteristic 包括3个功能</p>

<ul>
<li>新的iOS设备通知</li>
<li>iOS设备通知修改</li>
<li>iOS设备通知删除</li>
</ul>


<p>当Device端 subscribes Notification Source characteristic时，GATT Notification 会立刻分发出去。所以，Notification consumer （Device）在subscribe之前就需要做好立马接受和处理消息的状态。</p>

<h3>Notification Source response format</h3>

<p><span class='caption-wrapper'><img class='caption' src='/images/ancs1.png' width='' height='' title='图2-1 Notification Source characteristic 通过GATT Notification 的格式。'><span class='caption-text'>图2-1 Notification Source characteristic 通过GATT Notification 的格式。</span></span></p>

<ul>
<li>EventID：描述iOS设备上面的通知是增加、删除、还是修改。</li>
<li>EventFlags: 标志位，描述iOS设备通知（重要， 静默）</li>
<li>CategoryID：iOS设备通知类型</li>
<li>CategoryCount：给定类型的通知数量，比如有2个未读email消息通知，这时有一个新的未读消息通知push到iOS设备，这时CategoryCount = 3
NotificationUID：通知的唯一标示，这个字段用于和Control Point characteristic 检索更多的信息。</li>
</ul>


<p><img src="http://studentdeng.github.io/images/ancs2.png" alt="image" /></p>

<p>表格3-1：CategoryID的描述</p>

<p><img src="http://studentdeng.github.io/images/ancs3.png" alt="image" /></p>

<h3>Notification Source Response Example</h3>

<p>Device 获取的来此Notification Source的数据是“00 01 00 01 43 00 00 00”</p>

<p><img src="http://studentdeng.github.io/images/ancs4.png" alt="image" /></p>

<p>图2-2一个iOS通知的生命周期。</p>

<p>比如当iOS设备（如iPhone）收到一个iMessage消息，iOS NotificationCenter会产生一个Notification，ANCS会通知device 有一个新的通知。当iOS设备阅读这个iMessage消息之后，iOS Not ificationCenter 会删除掉这个通知，ANCS把这个删除通知push到device</p>

<h2>Control Point 和 Data Source Characteristic</h2>

<p>只是Notification Source 不能获得足够的信息，
Control Point 和 Data Source characteristic用来解决这个问题。
Device 向Control Point characteristic 写一个命令，如果成功，会从DataSource characteristic 获得response。</p>

<h3>获取通知属性命令</h3>

<p>该命令根据NotificationUID 查找通知的详细内容（通知属性）。</p>

<p><img src="http://studentdeng.github.io/images/ancs5.png" alt="image" /></p>

<p>图2-3 获取通知属性命令格式
CommandID: 必须设置为0
NotificationUID：通知的唯一标示（Notification Source 获得）
AttributeIDS：需要检索信息list</p>

<p><img src="http://studentdeng.github.io/images/ancs6.png" alt="image" /></p>

<p>图3-5 可以检索的通知属性列表，其中Title， subtitle， Message 需要增加2个bytes的字段表示长度。</p>

<p>获取通知属性命令Example
“00 43 00 00 00 00 01 FF FF 02 05”</p>

<p><img src="http://studentdeng.github.io/images/ancs7.png" alt="image" /></p>

<h3>获取通知属性命令Response消息格式</h3>

<p><img src="http://studentdeng.github.io/images/ancs8.png" alt="image" /></p>

<p>图2-4 获取通知属性命令返回数据格式</p>

<p>CommandID： 0
NotificationUID：通知的唯一标示
AttributeList：具体的属性返回数据列表. 如果返回的属性空，长度是0</p>

<p>如果返回的数据长度大于 GATT MTU，那么数据会被分几段传输。Device 需要对数据拼接。</p>

<h3>通知属性命令Response 消息格式Example</h3>

<p>下图查找 NotificationUID为2的 AppIdentifier、Title、SubTitle、Message Date属性返回数据</p>

<p><img src="http://studentdeng.github.io/images/ancs9.png" alt="image" /></p>

<h2>获取APP属性命令</h2>

<p>该命令通过APPIdentifier查找iOS设备中安装的APP的属性。</p>

<p>图2-5 获取APP属性命令格式</p>

<p>CommandID: 必须设置成1
AppIdentifier：字符串’\0’ 结尾。
AttributeIDS：查找ID列表</p>

<h2>获取APP属性命令 Example</h2>

<p>查找AppIdentifier 为 “com.apple.mobilemail” 的APP属性</p>

<p><img src="http://studentdeng.github.io/images/ancs10.png" alt="image" /></p>

<h2>获取APP属性命令Response消息格式</h2>

<p><img src="http://studentdeng.github.io/images/ancs11.png" alt="image" /></p>

<p>图2-6获取APP属性命令返回数据格式</p>

<ul>
<li>CommandID：必须是1</li>
<li>AppIdentifier：字符串 ‘\0’结尾</li>
<li>AttributeList：具体的属性返回数据列表. 如果返回的属性空，长度是0</li>
</ul>


<p>如果返回的数据长度大于 GATT MTU，那么数据会被分几段传输。Device 需要对数据拼接。</p>

<h3>获取APP属性命令Response消息格式Example</h3>

<p>查找AppIdentifier 为 “com.apple.mobilemail” 的APP属性返回数据
汉字 “邮件”</p>

<p><img src="http://studentdeng.github.io/images/ancs12.png" alt="image" /></p>

<h2>sessions会话</h2>

<p>ANCS 的 session 从设备订阅characteristic 开始到取消订阅或是disconnect结束。所有的Identifier 比如 NotificationUID，AppIdentifier 只在当前的session有效。</p>

<p>当session结束后，设备需要删除掉所有的在session中获得的Identifier信息，这些信息会在session建立的时候重新通知设备.</p>

<h1>错误代码</h1>

<ul>
<li>未知命令：（0xA0）</li>
<li>无效命令:（0xA1）</li>
<li>无效参数（0xA2） : 比如NotificationUID 找不到</li>
</ul>


<p><em>注意：如果产生了上面的错误，都不会再收到任何的GATT 通知。</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode5 Plugins 开发简介]]></title>
    <link href="http://studentdeng.github.com/blog/2014/02/21/xcode-plugin-fun/"/>
    <updated>2014-02-21T13:13:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/02/21/xcode-plugin-fun</id>
    <content type="html"><![CDATA[<p>这篇文章介绍如何给Xcode5开发插件。如果之前了解iPhone &amp; iPad 开发，那么下面的内容对您非常熟悉。最后我们会开发一个简单的插件，记录Xcode开发中Building的时间。</p>

<h1>准备工作</h1>

<p>首先编写一个Plugin还是需要不少额外的配置，这里推荐<a href="https://github.com/kattrali/Xcode5-Plugin-Template">Xcode Plugin Template</a>。用这个templage来帮助我们开发Plugin。</p>

<p>另外，编写插件和之前的iPhone or Mac上的APP不太一样。从某种意义上来说就是用Xcode调试Xcode。所以这里需要额外配置一点东西。</p>

<ul>
<li>修改Scheme</li>
</ul>


<p><img src="http://studentdeng.github.io/images/xcode_plugin1.png" alt="image" /></p>

<ul>
<li>Executable 选择Xcode.app</li>
</ul>


<p><img src="http://studentdeng.github.io/images/xcode_plugin2.png" alt="image" /></p>

<p>当我们Build &amp; Run Project的时候就可以看到启动了一个新的Xcode进程，当然除了Xcode， Mail或是其他程序我们都可以调试。</p>

<h1>如何编写插件</h1>

<p>因为Apple至今并没有公开Xcode Plugin的文档，所以我们需要通过一些其他方法寻找思路。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserver:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">notificationLog:</span><span class="p">)</span> <span class="nl">name:</span><span class="nb">nil</span> <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">notificationLog:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notify</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里稍微有一点特殊，参数notificationName 设为nil，下面是Apple的文档，不是很清楚。</p>

<pre><code>notificationName If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer.
</code></pre>

<p>但是目前来看，似乎可以看到所有的通知。当然绝大部分是重复的，对我们没有意义。很幸运最后我们找到了2个通知是我们需要的，下面的代码，已经做了过滤。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">notificationLog:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="n">notify</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span> <span class="nl">hasPrefix:</span><span class="s">@&quot;IDEBuildOperation&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这2个通知分别是</p>

<ul>
<li>IDEBuildOperationWillStartNotification</li>
<li>IDEBuildOperationDidStopNotification</li>
</ul>


<p>这个我们不得不赞一下cocoa的命名方式，大家都可以猜出这2个通知的含义。剩下的事情就很简单了。统计build时间。</p>

<h1>最后</h1>

<p>这是<a href="https://github.com/studentdeng/Buddy">项目源代码</a>。有兴趣的同学可以玩玩，看一下自己的编译时间有多长。另外最终的代码中还增加了2个小的features。</p>

<ul>
<li>查看当前打开Xcode的人数</li>
<li>查看自己打开Xcode专注的时间有多长，这个时间是当Xcode被focus的时候才统计，另外不足1分钟不计算在内。</li>
</ul>


<p>Have fun！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百度面试]]></title>
    <link href="http://studentdeng.github.com/blog/2014/02/11/baidu-interview/"/>
    <updated>2014-02-11T00:10:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/02/11/baidu-interview</id>
    <content type="html"><![CDATA[<p>百度移动云可穿戴部门的面试经历，面试官都非常热情友好，一上来到弄的我挺不好意思的。下面记录一下自己的面试过程，因为我真的没啥面试经验，需要总结下。</p>

<h1>1面</h1>

<ul>
<li>Objective C runtime library：Objective C的对象模型，block的底层实现结构，消息发送，消息转发，这些都需要背后C一层的描述，内存管理。</li>
<li>Core Data：中多线程中处理大量数据同步时的操作。</li>
<li>Multithreading：什么时候处理多线程，几种方式，优缺点。</li>
<li>Delegate， Notification，KVO， other 优缺点</li>
</ul>


<p>runtime有一点追问，category，method 的实现机制，class的载入过程。
1面整体感觉不错，40分钟不到，感觉回答的还可以。被通知一会儿二面。</p>

<h1>2面</h1>

<p>二面的时间非常长，差不多将近3个小时，直接面到快下班了。1面问的主要是知识点。2面问主要考察的是设计解决方案的能力，另外辅助追问的方式，考察深度和广度，回答过程中需要列出适合的具体例子，方案还需要细致到具体的关键的函数名称，方法。另外考察设计模式的理解，最后还考了算法。因为时间太长，这里记录一些重要的问题。</p>

<ol>
<li>设计一个progress bar解决方案，追问到 Core Graphic、CGPath、maskLayer。</li>
<li>设计一个popup view被追问到 keyWindow、UIWindow的layer、UIView hierarchy。</li>
<li>从设计模式的角度分析Delegate、Notification、KVO的区别。被追问到自己写的library和开源的项目中用到哪些设计模式，为什么使用，有哪些好处和坏处，现在能否改进。</li>
<li>算是问题3的追问，设计一个方案来检测KVO的同步异步问题。willChange和 didChange的不同点，然后被追问到有没有其他地方也有类似情况，被追问到Core Data 中falut object。</li>
<li>这个是问题4的追问，设计一个KVO系统。</li>
<li>Multithreading，什么时候采用Multithreading方案，以及理由。追问到系统还有哪些在后台运行的thread，被追问到view life cycle、iOS6之后的不同以及内存管理。</li>
<li>Multithreading中常常遇到的问题，追问到死锁，优先级翻转，线程池等。</li>
<li>百度有一个亿级别的APP需要统计用户行为的日志系统。不使用数据库，只是使用普通文件，设计一个系统。被追问到内存映射文件。这个问题本来是服务器的问题，我表示从来没做过，回答很瞎。</li>
</ol>


<p>算法考了2个。一个是如何求2个集合的交集。另一个是百亿数据中查找相同的数字以及出现的次数。</p>

<p>最后还补充了几个小问题</p>

<ul>
<li>自己对可穿戴设备的感受</li>
<li>自己如果进入这个team，自己准备做那方面的事情</li>
<li>为什么创业，自己未来规划</li>
</ul>


<p>一会被告知3面，但是因为太晚，约到次日下午3面。</p>

<h1>3面</h1>

<p>3面的时间和1面差不多40分钟，问了几个问题，主要是考察精神层面的东西。</p>

<ul>
<li>为什么做Windows Mobile</li>
<li>为什么改iOS</li>
<li>为什么来百度</li>
<li>为什么iPhone 可以成功，那些吸引你</li>
<li>如何看待AppStore 现在的生态圈</li>
</ul>


<p>后面就是他说的多一些，介绍团队遇到的困难以及14年团队的打算。最后他给了我2句话的评价，我觉得还是蛮对的。</p>

<ul>
<li>选择的时候都是经过深思熟虑的</li>
<li>有野心，wanna make a difference</li>
</ul>


<p>有意思的是，他说他也wanna make a difference。</p>

<h1>总结</h1>

<p>整体还是挺尴尬的，几乎所有的知识点都是1，2年前积累的，13年积累的东西基本上没有，都是一些虚的东西。
2面挺好的，暴露了自己不少问题，设计模式那部分几乎没有概念了。</p>

<h1>最后</h1>

<p>面试通过，我个人觉得2面我的问题在思考设计模式上面少，另外在window hierarchy 上面有不足。设计 KVO 上面在 didChange上面考虑不足。这些都是被当场戳穿的。
有一点疑虑的是整个面试中并没有问到Core Animation。这个还是我蛮喜欢的部分。Anyway 个人很喜欢追问的方式，很容易考察出来理解的深度和广度。</p>

<p>整个面试收获很大，发现了很多不足。另外1，2面的面试题目个人觉得也不错。这里分享给大家。</p>
]]></content>
  </entry>
  
</feed>
