<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 不会开机的男孩]]></title>
  <link href="http://studentdeng.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://studentdeng.github.com/"/>
  <updated>2014-04-04T16:40:16+08:00</updated>
  <id>http://studentdeng.github.com/</id>
  <author>
    <name><![CDATA[studentdeng]]></name>
    <email><![CDATA[studentdeng@hotmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth Concept]]></title>
    <link href="http://studentdeng.github.com/blog/2014/03/22/corebluetooth/"/>
    <updated>2014-03-22T20:41:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/03/22/corebluetooth</id>
    <content type="html"><![CDATA[<p>Core Bluetooth 里面的名词还是挺多的，这里简单记录一下，一上来的时候，还是很容易混淆的，这里记录一下。</p>

<h1>Basic Concept</h1>

<p>Bluetooth low energy (<a href="http://en.wikipedia.org/wiki/Bluetooth_low_energy#Radio_interface">BLE</a>，还有地方叫做BTLE，最恨各种简写了) 简单说是一种低功耗的短距离无线传输技术，主要用于低功耗设备传输，比如心率、记步器、智能家居方向,还有连接其他iOS设备。</p>

<p>Core Bluetooth API 支持BLE4.0，做了协议封装，让开发者不需要完整了解BLE协议就可以快速开发APP。</p>

<h2>Central and Peripheral</h2>

<p>BLE中有2个非常重要的概念就是Central和Peripheral，有一点类似Client Server。</p>

<ul>
<li>Peripheral是数据的发送方（比如运动手环需要把位置，步数等数据传递给其他设备）。</li>
<li>Central是数据的接收方（比如手机接收手环传递来的步数）</li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue1.png" alt="1-1 Central 和 Peripheral 心率设备和Apple product" /></p>

<h2>Centrals Discover and Connect to Peripherals That Are Advertising</h2>

<ul>
<li><p>Peripheral把advertising packets广播出去，advertising packet 包括会包含一些重要的信息，比如设备名字，所提供的服务。</p></li>
<li><p>Central 则是扫描自己感兴趣的advertising packet，比如一个APP需要查找当前家里的室温，会通过参数设定，只是检索温度设备发来的packet。</p></li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue2.png" alt="1-2 一个简单的advertising模型" /></p>

<h2>Data structure</h2>

<ul>
<li>Peripheral 是最上层的一种服务抽象，比如iOS 系统内置的<a href="http://studentdeng.github.io/blog/2014/03/22/ancs/">ANCS</a>服务,另外我们自己也可以创建自己的服务。</li>
<li>characteristic 则是用来描述服务中的具体内容（比如手环有传递行走路程的接口，还有行走位置的接口），一个服务可以包含多个characteristics。</li>
</ul>


<p><img src="http://studentdeng.github.io/images/coreblue3.png" alt="1-3 心率检测仪包含1个服务，1个服务中包含2个characteristics,一个用来传递心率，一个用来传递位置" /></p>

<h1>How to</h1>

<p><a href="https://github.com/kickingvegas/YmsCoreBluetooth">YmsCoreBluetooth</a> 是个不错的框架，有很详细的<a href="http://kickingvegas.github.io/YmsCoreBluetooth/appledoc/docs/tutorial/Tutorial.html">介绍</a>，这里就不赘述了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apple Notification Center Service]]></title>
    <link href="http://studentdeng.github.com/blog/2014/03/22/ancs/"/>
    <updated>2014-03-22T15:42:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/03/22/ancs</id>
    <content type="html"><![CDATA[<h1>名词解释与约定</h1>

<h2>名词解释</h2>

<ul>
<li>Apple Notification Center Service 简称 ANCS。</li>
<li>ANCS 服务（iOS设备，如iPhone，iPad等）的publisher 称为 Notification Provider。</li>
<li>任意的ANCS服务的client（硬件设备，配件）称为 Notification Consumer。</li>
<li>Generic Attribute Profile简称GATT。</li>
<li>在iOS NotificationCenter 显示的通知称为 iOS notification。</li>
<li>通过GATT characteristic 发布的通知称为 GATT notification。</li>
<li>iPhone、 iPad等运行iOS系统的设备称为iOS设备</li>
</ul>


<h2>约定</h2>

<p>文本档覆盖的内容中除特别描述外，和字节序相关的都是用Little-endian (小端模式)。
文本档覆盖的内容中除特别描述外，和字符串传递相关的都是UTF-8</p>

<p><div class='notebox'><p><strong>Note: </strong>ANCS 并不保证始终存在，服务开启，关闭机制由iOS系统决定，Device 需要一直检测，查找ANCS是否存在。</p></div></p>

<h1>协议内容</h1>

<p>ANCS的uart profile UUID : ” 7905F431-B5CE-4E99-A40F-4B1E122D00D0”</p>

<p>uart profile 中包括3个 characteristic</p>

<ul>
<li>Notification Source   UUID: “9FBF120D-6301-42D9-8C58-25E699A21DBD” (notifiable)</li>
<li>Control Point             UUID: “69D1D8F3-45E1-49A8-9821-9BBDFDAAD9D9”(write with             response)</li>
<li>Data Source           UUID:” 22EAC6E9-24D6-4BB5-BE44-B36ACE7C7BFB "(notifiable)</li>
</ul>


<p>Device端Notification Source 是必须实现的。Centrol Point 和 Data Source 可选。</p>

<h2>Notification Source Characteristic</h2>

<p>Notification Source characteristic 包括3个功能</p>

<ul>
<li>新的iOS设备通知</li>
<li>iOS设备通知修改</li>
<li>iOS设备通知删除</li>
</ul>


<p>当Device端 subscribes Notification Source characteristic时，GATT Notification 会立刻分发出去。所以，Notification consumer （Device）在subscribe之前就需要做好立马接受和处理消息的状态。</p>

<h3>Notification Source response format</h3>

<p><span class='caption-wrapper'><img class='caption' src='/images/ancs1.png' width='' height='' title='图2-1 Notification Source characteristic 通过GATT Notification 的格式。'><span class='caption-text'>图2-1 Notification Source characteristic 通过GATT Notification 的格式。</span></span></p>

<ul>
<li>EventID：描述iOS设备上面的通知是增加、删除、还是修改。</li>
<li>EventFlags: 标志位，描述iOS设备通知（重要， 静默）</li>
<li>CategoryID：iOS设备通知类型</li>
<li>CategoryCount：给定类型的通知数量，比如有2个未读email消息通知，这时有一个新的未读消息通知push到iOS设备，这时CategoryCount = 3
NotificationUID：通知的唯一标示，这个字段用于和Control Point characteristic 检索更多的信息。</li>
</ul>


<p><img src="http://studentdeng.github.io/images/ancs2.png" alt="image" /></p>

<p>表格3-1：CategoryID的描述</p>

<p><img src="http://studentdeng.github.io/images/ancs3.png" alt="image" /></p>

<h3>Notification Source Response Example</h3>

<p>Device 获取的来此Notification Source的数据是“00 01 00 01 43 00 00 00”</p>

<p><img src="http://studentdeng.github.io/images/ancs4.png" alt="image" /></p>

<p>图2-2一个iOS通知的生命周期。</p>

<p>比如当iOS设备（如iPhone）收到一个iMessage消息，iOS NotificationCenter会产生一个Notification，ANCS会通知device 有一个新的通知。当iOS设备阅读这个iMessage消息之后，iOS Not ificationCenter 会删除掉这个通知，ANCS把这个删除通知push到device</p>

<h2>Control Point 和 Data Source Characteristic</h2>

<p>只是Notification Source 不能获得足够的信息，
Control Point 和 Data Source characteristic用来解决这个问题。
Device 向Control Point characteristic 写一个命令，如果成功，会从DataSource characteristic 获得response。</p>

<h3>获取通知属性命令</h3>

<p>该命令根据NotificationUID 查找通知的详细内容（通知属性）。</p>

<p><img src="http://studentdeng.github.io/images/ancs5.png" alt="image" /></p>

<p>图2-3 获取通知属性命令格式
CommandID: 必须设置为0
NotificationUID：通知的唯一标示（Notification Source 获得）
AttributeIDS：需要检索信息list</p>

<p><img src="http://studentdeng.github.io/images/ancs6.png" alt="image" /></p>

<p>图3-5 可以检索的通知属性列表，其中Title， subtitle， Message 需要增加2个bytes的字段表示长度。</p>

<p>获取通知属性命令Example
“00 43 00 00 00 00 01 FF FF 02 05”</p>

<p><img src="http://studentdeng.github.io/images/ancs7.png" alt="image" /></p>

<h3>获取通知属性命令Response消息格式</h3>

<p><img src="http://studentdeng.github.io/images/ancs8.png" alt="image" /></p>

<p>图2-4 获取通知属性命令返回数据格式</p>

<p>CommandID： 0
NotificationUID：通知的唯一标示
AttributeList：具体的属性返回数据列表. 如果返回的属性空，长度是0</p>

<p>如果返回的数据长度大于 GATT MTU，那么数据会被分几段传输。Device 需要对数据拼接。</p>

<h3>通知属性命令Response 消息格式Example</h3>

<p>下图查找 NotificationUID为2的 AppIdentifier、Title、SubTitle、Message Date属性返回数据</p>

<p><img src="http://studentdeng.github.io/images/ancs9.png" alt="image" /></p>

<h2>获取APP属性命令</h2>

<p>该命令通过APPIdentifier查找iOS设备中安装的APP的属性。</p>

<p>图2-5 获取APP属性命令格式</p>

<p>CommandID: 必须设置成1
AppIdentifier：字符串’\0’ 结尾。
AttributeIDS：查找ID列表</p>

<h2>获取APP属性命令 Example</h2>

<p>查找AppIdentifier 为 “com.apple.mobilemail” 的APP属性</p>

<p><img src="http://studentdeng.github.io/images/ancs10.png" alt="image" /></p>

<h2>获取APP属性命令Response消息格式</h2>

<p><img src="http://studentdeng.github.io/images/ancs11.png" alt="image" /></p>

<p>图2-6获取APP属性命令返回数据格式</p>

<ul>
<li>CommandID：必须是1</li>
<li>AppIdentifier：字符串 ‘\0’结尾</li>
<li>AttributeList：具体的属性返回数据列表. 如果返回的属性空，长度是0</li>
</ul>


<p>如果返回的数据长度大于 GATT MTU，那么数据会被分几段传输。Device 需要对数据拼接。</p>

<h3>获取APP属性命令Response消息格式Example</h3>

<p>查找AppIdentifier 为 “com.apple.mobilemail” 的APP属性返回数据
汉字 “邮件”</p>

<p><img src="http://studentdeng.github.io/images/ancs12.png" alt="image" /></p>

<h2>sessions会话</h2>

<p>ANCS 的 session 从设备订阅characteristic 开始到取消订阅或是disconnect结束。所有的Identifier 比如 NotificationUID，AppIdentifier 只在当前的session有效。</p>

<p>当session结束后，设备需要删除掉所有的在session中获得的Identifier信息，这些信息会在session建立的时候重新通知设备.</p>

<h1>错误代码</h1>

<ul>
<li>未知命令：（0xA0）</li>
<li>无效命令:（0xA1）</li>
<li>无效参数（0xA2） : 比如NotificationUID 找不到</li>
</ul>


<p><em>注意：如果产生了上面的错误，都不会再收到任何的GATT 通知。</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode5 Plugins 开发简介]]></title>
    <link href="http://studentdeng.github.com/blog/2014/02/21/xcode-plugin-fun/"/>
    <updated>2014-02-21T13:13:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/02/21/xcode-plugin-fun</id>
    <content type="html"><![CDATA[<p>这篇文章介绍如何给Xcode5开发插件。如果之前了解iPhone &amp; iPad 开发，那么下面的内容对您非常熟悉。最后我们会开发一个简单的插件，记录Xcode开发中Building的时间。</p>

<h1>准备工作</h1>

<p>首先编写一个Plugin还是需要不少额外的配置，这里推荐<a href="https://github.com/kattrali/Xcode5-Plugin-Template">Xcode Plugin Template</a>。用这个templage来帮助我们开发Plugin。</p>

<p>另外，编写插件和之前的iPhone or Mac上的APP不太一样。从某种意义上来说就是用Xcode调试Xcode。所以这里需要额外配置一点东西。</p>

<ul>
<li>修改Scheme</li>
</ul>


<p><img src="http://studentdeng.github.io/images/xcode_plugin1.png" alt="image" /></p>

<ul>
<li>Executable 选择Xcode.app</li>
</ul>


<p><img src="http://studentdeng.github.io/images/xcode_plugin2.png" alt="image" /></p>

<p>当我们Build &amp; Run Project的时候就可以看到启动了一个新的Xcode进程，当然除了Xcode， Mail或是其他程序我们都可以调试。</p>

<h1>如何编写插件</h1>

<p>因为Apple至今并没有公开Xcode Plugin的文档，所以我们需要通过一些其他方法寻找思路。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserver:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">notificationLog:</span><span class="p">)</span> <span class="nl">name:</span><span class="nb">nil</span> <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">notificationLog:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notify</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里稍微有一点特殊，参数notificationName 设为nil，下面是Apple的文档，不是很清楚。</p>

<pre><code>notificationName If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer.
</code></pre>

<p>但是目前来看，似乎可以看到所有的通知。当然绝大部分是重复的，对我们没有意义。很幸运最后我们找到了2个通知是我们需要的，下面的代码，已经做了过滤。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">notificationLog:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="n">notify</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span> <span class="nl">hasPrefix:</span><span class="s">@&quot;IDEBuildOperation&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这2个通知分别是</p>

<ul>
<li>IDEBuildOperationWillStartNotification</li>
<li>IDEBuildOperationDidStopNotification</li>
</ul>


<p>这个我们不得不赞一下cocoa的命名方式，大家都可以猜出这2个通知的含义。剩下的事情就很简单了。统计build时间。</p>

<h1>最后</h1>

<p>这是<a href="https://github.com/studentdeng/Buddy">项目源代码</a>。有兴趣的同学可以玩玩，看一下自己的编译时间有多长。另外最终的代码中还增加了2个小的features。</p>

<ul>
<li>查看当前打开Xcode的人数</li>
<li>查看自己打开Xcode专注的时间有多长，这个时间是当Xcode被focus的时候才统计，另外不足1分钟不计算在内。</li>
</ul>


<p>Have fun！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百度面试]]></title>
    <link href="http://studentdeng.github.com/blog/2014/02/11/baidu-interview/"/>
    <updated>2014-02-11T00:10:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/02/11/baidu-interview</id>
    <content type="html"><![CDATA[<p>百度移动云可穿戴部门的面试经历，面试官都非常热情友好，一上来到弄的我挺不好意思的。下面记录一下自己的面试过程，因为我真的没啥面试经验，需要总结下。</p>

<h1>1面</h1>

<ul>
<li>Objective C runtime library：Objective C的对象模型，block的底层实现结构，消息发送，消息转发，这些都需要背后C一层的描述，内存管理。</li>
<li>Core Data：中多线程中处理大量数据同步时的操作。</li>
<li>Multithreading：什么时候处理多线程，几种方式，优缺点。</li>
<li>Delegate， Notification，KVO， other 优缺点</li>
</ul>


<p>runtime有一点追问，category，method 的实现机制，class的载入过程。
1面整体感觉不错，40分钟不到，感觉回答的还可以。被通知一会儿二面。</p>

<h1>2面</h1>

<p>二面的时间非常长，差不多将近3个小时，直接面到快下班了。1面问的主要是知识点。2面问主要考察的是设计解决方案的能力，另外辅助追问的方式，考察深度和广度，回答过程中需要列出适合的具体例子，方案还需要细致到具体的关键的函数名称，方法。另外考察设计模式的理解，最后还考了算法。因为时间太长，这里记录一些重要的问题。</p>

<ol>
<li>设计一个progress bar解决方案，追问到 Core Graphic、CGPath、maskLayer。</li>
<li>设计一个popup view被追问到 keyWindow、UIWindow的layer、UIView hierarchy。</li>
<li>从设计模式的角度分析Delegate、Notification、KVO的区别。被追问到自己写的library和开源的项目中用到哪些设计模式，为什么使用，有哪些好处和坏处，现在能否改进。</li>
<li>算是问题3的追问，设计一个方案来检测KVO的同步异步问题。willChange和 didChange的不同点，然后被追问到有没有其他地方也有类似情况，被追问到Core Data 中falut object。</li>
<li>这个是问题4的追问，设计一个KVO系统。</li>
<li>Multithreading，什么时候采用Multithreading方案，以及理由。追问到系统还有哪些在后台运行的thread，被追问到view life cycle、iOS6之后的不同以及内存管理。</li>
<li>Multithreading中常常遇到的问题，追问到死锁，优先级翻转，线程池等。</li>
<li>百度有一个亿级别的APP需要统计用户行为的日志系统。不使用数据库，只是使用普通文件，设计一个系统。被追问到内存映射文件。这个问题本来是服务器的问题，我表示从来没做过，回答很瞎。</li>
</ol>


<p>算法考了2个。一个是如何求2个集合的交集。另一个是百亿数据中查找相同的数字以及出现的次数。</p>

<p>最后还补充了几个小问题</p>

<ul>
<li>自己对可穿戴设备的感受</li>
<li>自己如果进入这个team，自己准备做那方面的事情</li>
<li>为什么创业，自己未来规划</li>
</ul>


<p>一会被告知3面，但是因为太晚，约到次日下午3面。</p>

<h1>3面</h1>

<p>3面的时间和1面差不多40分钟，问了几个问题，主要是考察精神层面的东西。</p>

<ul>
<li>为什么做Windows Mobile</li>
<li>为什么改iOS</li>
<li>为什么来百度</li>
<li>为什么iPhone 可以成功，那些吸引你</li>
<li>如何看待AppStore 现在的生态圈</li>
</ul>


<p>后面就是他说的多一些，介绍团队遇到的困难以及14年团队的打算。最后他给了我2句话的评价，我觉得还是蛮对的。</p>

<ul>
<li>选择的时候都是经过深思熟虑的</li>
<li>有野心，wanna make a difference</li>
</ul>


<p>有意思的是，他说他也wanna make a difference。</p>

<h1>总结</h1>

<p>整体还是挺尴尬的，几乎所有的知识点都是1，2年前积累的，13年积累的东西基本上没有，都是一些虚的东西。
2面挺好的，暴露了自己不少问题，设计模式那部分几乎没有概念了。</p>

<h1>最后</h1>

<p>面试通过，我个人觉得2面我的问题在思考设计模式上面少，另外在window hierarchy 上面有不足。设计 KVO 上面在 didChange上面考虑不足。这些都是被当场戳穿的。
有一点疑虑的是整个面试中并没有问到Core Animation。这个还是我蛮喜欢的部分。Anyway 个人很喜欢追问的方式，很容易考察出来理解的深度和广度。</p>

<p>整个面试收获很大，发现了很多不足。另外1，2面的面试题目个人觉得也不错。这里分享给大家。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译 并发编程：API 和 挑战]]></title>
    <link href="http://studentdeng.github.com/blog/2014/01/15/concurrent-api/"/>
    <updated>2014-01-15T20:21:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2014/01/15/concurrent-api</id>
    <content type="html"><![CDATA[<p>并发（<a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29">Concurrency</a>）描述了一个同时运行多个任务的概念。他可以在单核设备上通过分时的方式实现，或者如果多个CPU则会真正的并行。</p>

<p>OSX和iOS提供了多种不同的API来实现并发编程。每一个API都有不同的功能和局限，适用于不同的任务。他们有不同的抽象层次。我们可以操作底层API，但是这也意味着我们需要做很多事情来保证正确。</p>

<p>并发编程是非常困难的，里面有很多陷阱。而且很容易被忘记，特别是我们使用API，比如 GCD 或者 NSOperationQueue。这篇文章来会总体介绍在iOS和OSX上面的不同的并发API，然后深入一点并发编程里面的固有的，每个API所独有的挑战。</p>

<h1>OSX和iOS上面的并发API</h1>

<p>Apple为移动和桌面操作系统提供了相同的并发编程API。这里我们会看一下pthread和NSThread。Grand Central Dispatch, NSOperationQueue 和 NSRunLoop。技术上来说，run loops 有一点奇怪。因为他们并不是真正的并发。但是他和这篇文章的主旨很接近，所以还是值得深入了解的。</p>

<p>我们从底层API开始，然后到上层API。我们这样做，因为上层的API是通过底层的API实现的。当然，在实际中，我们需要反过来考虑：用最上面的一层抽象搞定事情会简单很多。</p>

<p>你可能想知道为什么我们这个坚持推荐使用高抽象层会让并发编程代码简单。你可以阅读这篇文章的第二部分。也可以看 Peter Steinberger 的 <a href="http://www.objc.io/issue-2/thread-safe-class-design.html">线程安全</a>文章。</p>

<h1>线程</h1>

<p><a href="http://en.wikipedia.org/wiki/Thread_%28computing%29">线程</a>是进程的子单元，被操作系统独立调度执行。事实上，所有的并发API都基于线程。背后实际上的确是真的，不管是GCD还是operation queues。</p>

<p>多线程可以在同一个时间执行，即时在单核的CPU上。（或是至少看上去是在同时）。操作系统赋予每个线程一个时间片，用户看上去多个任务就像是在同时执行一样。如果CPU是多核的，那么多个线程就可以真正的并发执行，因此总的执行时间就会减少。</p>

<p>你可以使用<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html">CPU strategy view</a>Instruments中的几个工具来深入了解一下你的代码或者是framework代码在多核下是如何调用和执行的。</p>

<p>这里面有一个非常重要的需要记住的是你对什么时候执行代码，执行那段代码无能为力，执行多长时间，什么时候会被暂停去执行别的任务，也是不知道的。这个线程调度的技术非常强大。然而，也带来了非常大的复杂性，后面会提到。</p>

<p>让我们把这个复杂的情况暂时放在一边。你可以使用pthread API，或是其他的Objective-C封装的代码，NSThread去创建自己的线程。这里有一个简单的代码，查找100W和数中的最小和最大的数。使用了4个线程并发执行。这就是一个非常好的例子，告你你最好不要直接使用pThread。</p>

<pre><code>struct threadInfo {
    uint32_t * inputValues;
    size_t count;
};

struct threadResult {
    uint32_t min;
    uint32_t max;
};

void * findMinAndMax(void *arg)
{
    struct threadInfo const * const info = (struct threadInfo *) arg;
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; info-&gt;count; ++i) {
        uint32_t v = info-&gt;inputValues[i];
        min = MIN(min, v);
        max = MAX(max, v);
    }
    free(arg);
    struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));
    result-&gt;min = min;
    result-&gt;max = max;
    return result;
}

int main(int argc, const char * argv[])
{
    size_t const count = 1000000;
    uint32_t inputValues[count];

    // Fill input values with random numbers:
    for (size_t i = 0; i &lt; count; ++i) {
        inputValues[i] = arc4random();
    }

    // Spawn 4 threads to find the minimum and maximum:
    size_t const threadCount = 4;
    pthread_t tid[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {
        struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));
        size_t offset = (count / threadCount) * i;
        info-&gt;inputValues = inputValues + offset;
        info-&gt;count = MIN(count - offset, count / threadCount);
        int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);
        NSCAssert(err == 0, @"pthread_create() failed: %d", err);
    }
    // Wait for the threads to exit:
    struct threadResult * results[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {
        int err = pthread_join(tid[i], (void **) &amp;(results[i]));
        NSCAssert(err == 0, @"pthread_join() failed: %d", err);
    }
    // Find the min and max:
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; threadCount; ++i) {
        min = MIN(min, results[i]-&gt;min);
        max = MAX(max, results[i]-&gt;max);
        free(results[i]);
        results[i] = NULL;
    }

    NSLog(@"min = %u", min);
    NSLog(@"max = %u", max);
    return 0;
}
</code></pre>

<p>NSThread是</p>
]]></content>
  </entry>
  
</feed>
