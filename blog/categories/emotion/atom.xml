<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emotion | studentdeng Blog]]></title>
  <link href="http://studentdeng.github.com/blog/categories/emotion/atom.xml" rel="self"/>
  <link href="http://studentdeng.github.com/"/>
  <updated>2013-03-04T00:10:20+08:00</updated>
  <id>http://studentdeng.github.com/</id>
  <author>
    <name><![CDATA[studentdeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[哈佛幸福课 杂感一]]></title>
    <link href="http://studentdeng.github.com/blog/2013/01/15/happiness/"/>
    <updated>2013-01-15T18:10:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2013/01/15/happiness</id>
    <content type="html"><![CDATA[<p>好长时间不写博客了, 可以说将近一年的时间里面,并没有多少技术上的积累, 甚至有点倒退的痕迹, 不管是从心气还是态度, 还是毅力上面.我曾经是<em><a href="http://mindhacks.cn/">刘未鹏</a></em>的粉丝,哈,当然现在也一样. 我一直好奇为什么会他会那么的专心在思维这部分.其实在1年前,我也无法想象我会放下我心爱的计算机的书籍而拿起这些曾经我看不上的东西.有些东西的确只有经历过,才会明白.好消息是,一切还来得及.文本和技术类文章毫无瓜葛, 只是我觉得对于Geek们来说,有些其他东西还是很重要的.</p>

<p><em><a href="http://v.163.com/special/positivepsychology/">幸福课</a></em>来自豆瓣小组的推荐, 一开始觉得这个只是一个练习英文听力的一个好的途径, 因为相对电影来说,我觉得对时间的利用率更高, 但事实上, 却是我听过的最好的公开课, 没有之一</p>

<h2>为什么要看这门课</h2>

<p>Tal 也就是这门课的老师, 第一句话就深深的吸引了我, "我来这里讲这门课, 因为我在本科的时候非常希望能学习这样的一门课程".Tal本科在哈佛大学读计算机, 学习成绩优秀 社交优秀, 运动优秀, 但还是有一种说不出来的压抑, 不幸福的感觉,然后他寻找问题的根源, 最后居然转向了哲学和心理学. 看到这里, 我就有一种特别的冲动, 想继续看下去, 想去了解Tal的动机. 我特别好奇的在于, 如何将一个理科思维转向哲学和心理学呢? 当然, 这是我当时的想法,科学本来就是理性,严谨的, 只是我当时对心理学,哲学这些有很多的偏见. 后面我才知道了这门课程讲的是积极心理学.</p>

<p>积极心理学啊, 可能是涉及到一些积极的心理暗示的某些东西, 这是我当时的想法, 不过相比占卜啊,星座啊, 这些扯淡的东西,我还是比较有好感的, 因为我当初在高考前, 学校组织过一次考试时的减压方法的交流会,有一个专家说过, 在做题没有思路的时候, 深呼吸3次, 然后心理默念"我能行", 3次, 然后再读题, 效果会很不错. 然后我当年在考理综的时候, 最后一道物理题,纠结了我挺长时间, 最后就是通过这个心理暗示搞定的.从那之后,从不信到半信半疑.</p>

<p>为什么想学心理学, 主要原因还是,当自己的外部空间拓展收到阻碍, 这个包括 工作, 学习, 人际交往,各种都不顺利, 到达瓶颈, 突然觉得可以向自己内部空间探索.而这些正好和Tal第一节课讲的内容吻合, 我觉得这就是缘分, 一种在正确的时间学正确的东西的缘分.而且Tal是一个内向的心理学老师, 他自己也承认, 而且Tal很风趣幽默.他里面讲了很多自己的故事, 包括很多让自己很尴尬的事情, 感觉很真实, 而不是我看到的其他的那种特别热情, 有力量, 感觉就像江湖卖艺的那种老师.</p>

<h2>什么是幸福</h2>

<p>大家都知道现在社会充斥着浮躁的概念, 不仅在中国, 美国, 全世界都是, 各种各样的秘籍, 捷径, 只要就类似的语句, 还有那句经典的"移动互联网唯快不破", 等等. 尽是些夸大其词, 效果甚微的言论.而这些言论却成了媒体追逐的主要理念, 追求快节奏, 什么都要快.一个个就像兴奋剂一样, 给我们短暂的快感, 但对长远收获来说, 都是弊大于利的.而这些也就是我们不断的感到焦虑,压抑的原因,那么应该如何看待这些信息呢.</p>

<p>Tal 讲得最多的一句话,就是chip away 我们身上的限制, 消除掉我们心理的枷锁.很多人都没有做到permission to be human. 很多时候不能面对自己, 面对自己的情绪, 更别说控制情绪.疏导情绪. 不能合理的理解情绪, 则极大的影响到自己的个人成长, 不论是生活, 工作, 学习, 还是人际交往, 而且我也确确实实的遇到了这方面的困难.</p>

<p>生活包括了起起落落, 这是一件说起来容易, 做起来难的事情, 大家都知道生活包括了失败, 振作, 成功, 迎接新的挑战. 但是人们往往给自己的预期则是和这个道理背驰的. 甚至很多家长自己的心理不成熟而导致孩子心理也不成熟, 比如一个经典的例子, 考上一个好的初中, 高中, 大学, 找到好的工作, 成家就怎怎怎么了, 这个好像一个充分必要条件似的强加在孩子心理上. 幸福没有那么容易获得,也不是一个等式可以解决的.</p>

<p>说到幸福,呵呵,这门课的名字可是讲happiness的, 这里我想到了一个特别搞笑的段子, "你幸福么?" 我不在这里重复了, 我在这里其实一直很困惑这个问题. Tal 讲到, 幸福不是一个简单的比较, 0 或1 .要么幸福, 要不不幸福.幸福存在于一个连续的状态,这个很像物理中能量的概念, 我们更关注与能量的转化, 多了还是少了, 而不是在乎我到底具有多少能量.更准确的描述应该是,我们如何才能变得更幸福.</p>

<p>Tal 讲述了一个这样子的观点. 是这样子的一个调查, 调查那些参加终身职位的教授们的心理, 这些教授们只能申请一次一所大学, 要么得到,也么没有. 调查的内容就是, "如果得到了终身职位,那么会有多开心?", 教授们的绝大多数都是回答"会非常非常高兴, 这实现了很多很多很多年努力的目标, 梦想成真的一刻, 我余生都会非常快乐, 一切都会变得简单, 停止不成功变成仁的竞争, 他将改变我的人生云云", 另一个调查是,"如果得不到终身职位会怎么样?", 教授们绝大多数回答"我们会非常非常难过, 这是很多很多年奋斗的目标, 因为如果在一所学校无法获得终身职位, 就没有可能在更高的学府获得, 只能在低一等的学校获得,所以会难过很长很长时间"</p>

<p>而在一段时间时候,再次调查教授们的感受, 其中有人得到了, 有人没有得到."得到的说非常开心,余生都会非常开心", 而那些没有得到的, 则是"我们很确认我们会难过很长时间". 三个月后, 六个月后不管是得到职位的,还是没有得到职位的都恢复到之前的幸福水平.</p>

<p>也就是说, 在得到职位 对他们的幸福感觉, 没有任何帮助, 在长久的角度来看.这既是一个好消息也是一个坏消息.坏消息是似乎无论我们怎么做,都无关紧要, 好消息是,无论这是一个多么糟糕的经历, 最后都会过去.</p>

<p>但这就带来一个问题,为什么我们还要不断地设立目标,努力实现呢?</p>

<p>很多时候我们通过降低我们的心理预期,降低自己的压力,去享受生活, 比如考试只是考了B, 然后我们不去想为什么不是A, A+, 而是想,恩,可以了,及格了,我不在乎成绩;我们的工作不好, 我不在乎我工作什么, 我只想快乐.有些时候,的确降低期望水平,会感到快乐一点.但长远来看却不行.</p>

<p>真正的问题不是在于降低期望, 而是在于区分正确的和错误的期望.一个错误的期望例子,就是我之前提到的,"考上好大学, 找到好工作, 升职, 找到理想的伴侣,就能让自己更快乐". 而让我们更快乐,是通过改变我们对问题,事物的看法,内在的认知,心境来做到的,而不是这些外部条件.(当然,外部条件肯定重要,如果每天都吃不饱, 没有住的地方, 外部条件的改善当然能提升幸福, 这里不考虑这种极端情况).</p>

<p>一个自己的例子吧, 之前很很用心的喜欢过一个女孩子, 但是知道的, 对于我这样的低情商Geek们来说, 结局大多都是悲剧的,觉得自己真的迈不过这个坎, 没法在面对以后的生活了, 没法在北京待下去了, 要逃避. 但现在看来, 当时自己的想法就是哈哈一笑带过了. 现在不是好好的么, 还有一个例子, 当时做IOS开发, AppStore排名是相当的低, 一度AppStore都无法找到了, 当时过年的时候,就定下一个目标, 丫的一定能冲到第一, 而且, 最后的确到第一了, 但也没有觉得特别开心, 觉得自己很厉害什么的.</p>

<h2>Give ourselves the permission to be human</h2>

<p>学积极心理学,主要就是想让自己能够变得阳光, 积极, 不消极. 那么就吧思路聚焦在那些痛苦的,不愉快的经历上面.</p>

<p>很多情绪是与生俱来的, 但是我却在内心里不断得在抵触, 在抗拒那种情绪.有一个简单的例子,就是 "现在开始,我们脑子里面不要想一个粉色的大象, 恩, 不要想一个粉色的大象, 一定不要想一个粉色的大象".</p>

<p>我自己的感受吧, 对于一个低情商男孩来说和一个女孩交往往往会有各种各样神奇的情绪产生, 而且我自己也却觉得不可思议, 不管是嫉妒,羡慕, 负罪感, 等等的情绪. 或是对于一个初步进入社会的男孩, 在工作中也会遇到各种各样的困难,不管是大目标,还是小目标,总是会各种各样的问题, 特别是对我这种有这强大的信心,自我,自恋, 把自己看得很重, 但实际上,别人根本不这么想, 没有那么在意自己.而有时候,发现自己能力的确不够,无力改变一些事情,而陷入一种挣扎.</p>

<p>而且事实上,在现在的社会, 不管是西方还是东方的, 男人们往往不能想女人们一样去向别人倾诉自己的内心真实想法.而随着压力越来越大,而变得焦躁.</p>

<p>Tal 讲述了一个自己的例子, 是当他和她的妻子有第一个孩子的情景. Tal在一个月的时候, 突然发现自己有一种嫉妒的情绪,他很嫉妒她的妻子和医生之间的关系, 因为在他的角度来看, 突然有个另一个人在Tal的妻子心中比Tal获得更多的关注,不管Tal怎么哭…..Tal感到非常的嫉妒.</p>

<p>在看到这个例子的时候, 给我非常大的震惊, 因为看到很多表面现象, 很多人都是永远的宠辱不惊, 在大的压力也面不改色, 遇到再困难的事情都不会害怕,以至于我认为那些家伙们没有这些消极情绪, 而作为情商极高的Tal来说, 肯定不会有这种消极情绪存在,不会这么敏感.</p>

<p>但事实上, 的确有, 那后来的故事是这样子的. Tal说, 在5分钟后,他就想通了这件事情,"这个医生真的好棒,让我体会到这种以前从来没有过的情绪" 额, 听到这个, 真的觉得好假. 这也太假了, 我反正是不信, 几分钟钱还充满嫉妒, 几分钟后就感谢他么,太扯了.但是Tal说, 完全正确, 各种各样的情绪就是作为一个human的一部分. 有人的确比另一部分人敏感, 几分钟就能够产生很多各种各样的情绪.Tal说, 我完全接受了我对医生的嫉妒这个情绪, 然后give myself the permission to be human, 然后自然而然的对医生产生了积极的情绪.</p>

<p>这里边会有一种自相矛盾的感觉, 是一个反语的自然现象,就像我之前说过的粉色大象, 我相信大多数人脑子里面都会有一个粉色大象出来.因为当我们企图压抑一种自然现象时, 只会加强它.就像失恋后, 想忘记那个人, 然后不停得对自己说,忘掉,忘掉,但却越来越清晰是一个道理.</p>

<p>在控制自己消极情绪出现的时候, 首先做的,不是压抑他, 而是学会接受他.<em><a href="http://book.douban.com/subject/4194978/">完整的成长</a></em>这本书里面也提到了类似的经历, 让情绪自然而然的流动.</p>

<p>这是一件说起来容易, 做起来非常难的一件事情. 因为我们很多人对心理学有着很大的偏见, 总觉得我们可以控制自己很棒, 因为我们总认为自己很了解自己,但事实上, 我们对自己的理解, 对大脑是如何思维, 决断, 我们的潜意识,我们的基因等等的了解, 相对而来不会比宇宙多多少.</p>

<p>我们不会有一天起来说, OK, 我拒绝万有引力,我不想每天爬楼梯, 我想直接飞过去.这样多简单, 多容易.相对其他科学,比如物理, 我们总是能够很容易的承认物理的基本定理并欣然接受, 而且还能接受他的不足, 比如在量子物理等等很多领域.</p>

<p>但在心理学这里,却有了双重标准. <em><a href="http://book.douban.com/subject/1221479/">与“众”不同的心理学</a></em>这里面也提到了这个基本的道理.</p>

<p>一个简单的例子,就是很多媒体鼓吹的东西,什么占星, 星座, 一些通过特别简单的一些tips, 就可以把一个人了解彻底.多容易,多么简单的捷径, 不需要花费很多时间就可以了解一个人的性格.心理学家似乎就可以通过一眼就可以把这个人了解明白.网上我记得看过一个笑话, 是一个学心理的男孩,在吐槽她的女朋友, 她女朋友有天突然问他, 你知道我现在在想什么, 他说不知道,然后她女朋友说, 你真没用,学心理的居然不知道我想什么.然后他就瞎了.</p>

<p>拒绝自己内心的情绪, 就像不遵守物理中的万有引力定律一样, 会让自己到处碰壁, 而事实上, 我们可以利用万有引力做出很多好玩的游戏, 刺激精彩的运动.但在面对自己的情绪时, 我们却很难做到,甚至面对都很难, 而这里,我真的好佩服Tal的情商了.因为当我有这样的消极情绪,我会觉得一定是那里出了问题, 那里做的不对,然后陷入一大段无意义的思考中, 最后因疲倦而逃避,而不是面对它, 接受它, 甚至是改变它.时间一长,则变的更加焦虑, 抑郁.</p>

<p>而学到这里, 我又有了新的疑惑, 那么就是,如何接受, 被动的接受么?就没有什么可以主动做的么.而事实上,Tal说出了一个非常重要的观点, 就是, 在改变自己, 改造自己之前, 我们需要先知道, 我们可以改变什么, 不可以改变什么.</p>

<p>这里Tal 提出了一个很犀利的观点.心理学的A B C</p>

<p>A: affect           情绪</p>

<p>B: behavior       行为</p>

<p>C: cognition      思想,认知</p>

<p>permission to be human 主要是和情绪相关的. 比如,我们有愤怒的情绪,接受它但并不是意味着, 我们也要接受那些因为愤怒而做出伤害他人的行为.Tal嫉妒医生, 并不代表Tal是一个坏人, 这个没有好坏之分.很多时候,我们应该采用什么样的行为去表达情感, 这个才是问题的关键. 就像之前发生的一名男子失恋后, 在地铁里面划女孩脸. 我们承认失恋的确很难过, 但是通过这种行为表达自己的难过, 就是不能接受的.</p>

<p>对于认知这部分同样. 我们可以有消极的情绪,但并不意味着我们必须屈从于消极情绪带来的消极的想法.而且事实上沉思,下功夫琢磨对消极情绪这里,并没有多大帮助, 通常会越来越糟. 比如一直在想,哦,我被女朋友甩了,这有多么的惨.</p>

<p>举一个我的例子吧, 我很喜欢沉思,但是在对待消极情绪这里就遇到了极大的困难,恩, 算了, 我还是在改变里面讲这个吧.</p>

<p>一个情商高, 内心强大的家伙, 不是没有那些消极的情绪, 就像一个强壮的身体, 不可能永远不得病, 而是因为更有抵抗能力, 在面对病症时,也可以更快的恢复.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[plan]]></title>
    <link href="http://studentdeng.github.com/blog/2012/01/13/plan/"/>
    <updated>2012-01-13T23:46:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/01/13/plan</id>
    <content type="html"><![CDATA[<p>不知不觉又是一年，又大了一岁，呵呵，说的很假，因为自己并没有真正的意识到自己又大了一岁，甚至自己现在的年龄都不能一口说出来，过去的一年，甚至之前，我都不能准确的说出我自己到底做了什么，混沌，浑浑噩噩的一生，没有目标，一切都是随心，一切都是随心而发，没有目的，达成不达成，似乎都不重要。那么自己心里到底有什么在乎的了？不知道，那么还有什么感兴趣的呢？</p>

<p>庄子是我最佩服的人，千年前的古人，都可以去猜测天道，追逐天地之本，而做为现代人的我，从小都希望自己能够成为其中的一员，哪怕只是能够感知到一点，为此沉沦数学，物理。</p>

<p>什么是天道，天道不以人类意志左右，甚至和普通人意志相反。而这也就造就了普通人永远无法理解天道。所以，我从来没有觉得自己是普通人，甚至乐于反着做。而今天，我觉得，我错了，因为我现在自己都不了解，原来追求的东西，随着时间的打磨，已经逐渐淡去。现在做的，只是随心而动，追求自己内心的想法——每件事情，比别人多做一点，多深入一点，至于是什么事情，别人的看法，已经不重要了，我发现，我这个理科生，居然是一个彻头彻尾的唯心主义者。</p>

<p>人的一生是要不断学习的。这里面的动力很简单：因为我们在有些方面还“无知”， 无知是做事情的一个障碍。我们如果想做好事情，就要求知，要改变这种无知的状况。而对于创业这件事情，也是我这20多年来，做的最大的一件事情，1年前，对于创业，我还是处在，拿着无知当无畏的状态，而且，现在也没有好多少，但是，我很感谢我们这个Team，包容了我很多缺点，替我遮挡了许多细枝末节，使得我还有时间有精力追求自己内心的想法，而且我相信，我最终一定能够成功，但是这里面的代价实在是太大了，我甚至不能确定，而且害怕，这个时间太长，而那些身边默默支持我的人已经离去，甚至永远看不到了。</p>

<p>我最讨厌的人，就是浪费时间的人，因为，我自己已经浪费了自己20多年的青春。所以，当我在大三的时候，我就已经意识到，自己需要改变这一点——痛恨那些走在我前面档我走路的人，浪费我时间的人。</p>

<p>而现在，我发现，挡在我前面的那个人，不是别人，就是自己。自己的惰性，侥幸心里，成功考验的不仅是智力，更是意志。就像处在激发态的原子，时间会不断地侵蚀他的能量，而如果想要挣脱枷锁，只能是不断地更快地吸取更多的能量。就像鲲鹏，如果沉迷于大海，永远不可能越出水面，飞翔在空中。</p>

<p>呼呼，扯了好多，看看我这一年做了什么，1年前是离毕业还有半年时。</p>

<p>我很庆幸，因为，在很多人不知道自己以后应该做什么时，我知道了我该做什么，计算机就是为我而生的科学，我也很庆幸，我在离开大学的最后半年里，我能够把大学中学到的和没有学到的东西，捏合到了一起，明白了大学这些课程讲述的意义，汇编程序设计，计算机体系结构，编译原理等等耳熟能详的课程捏到一起，虽然不能融会贯通，但是计算机知识体系已经能够较为清晰的展现在脑海里，而这，也就是为什么我放弃考研的原因之一，不需要再学太多的理论来夯实基础，因为我不是要成为科学家，这些理论知识对现在的我来说已经足够，贪多嚼不烂。而更为重要的是，移动互联网，这一波已经滚滚而来，已经不可能在等我3年，就像我大二时，第一次用到智能手机时（Symbian不算）的感触，传统的PC应用已经不可能吸引我，除了mobile。</p>

<p>大学最后的半年，是在创业公司渡过的，第一次自己独立做项目（自己的毕设），而且是一个会正式发布的产品，对于我这样的一个二流大学毕业生来说已经不易。而后的毕业答辩，更是验证了我对学校的不屑，只能挑挑排版错误的导师，充满各种潜规则的评分，对我来说已经没有任何意义，90分和60分，同样没有区别。我唯一在意的是，最后半年，C++的基础打的更扎实了一点，windows消息机制的了解也更深入了一点。也不枉我在这里学习了将近1年的时间。</p>

<p>后半年，风雨突变，windows mobile 已经死在了IOS 和android 的车轮之下，顺应天意，转战IOS。</p>

<p>从0开始学习一个新的语言，新的平台，到产品上线，呵呵，虽然在Appstore 很惨淡，但是，我们并没有放弃，不说了，来年新产品上线再说，不信这个邪了。</p>

<p>总结之后，就要规划，虽然我实在是不想做这个规划，因为实在是不靠谱。1年的时间，说长不长，说短不短。不求别的，只求不浪费时间，全力学习，深入IOS 一点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转 从无知到有知]]></title>
    <link href="http://studentdeng.github.com/blog/2012/01/13/knownless/"/>
    <updated>2012-01-13T23:45:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2012/01/13/knownless</id>
    <content type="html"><![CDATA[<p>人的一生是要不断学习的。这里面的动力很简单：因为我们在有些方面还“无知”， 无知是做事情的一个障碍。我们如果想做好事情，就要求知，要改变这种无知的状况。</p>

<p>可是大多数人不知道的是，“无知” (ignorance) 其实不是一个状态，而是两个截然不同的状态，一种叫做不知道型无知 (uninformed ignorance)，另一种叫做知道型无知 (informed ignorance)。 相信很多人都有这个体会：某天看到一本书，一篇文章，觉得这里面的学问知识，是自己从来没有想过或者接触过的，是一个崭新的领域，这就代表了你突然发现了自己的无知，而且知道自己的这种无知，也就是，从 uninformed ignorance 跨入了 informed ignorance. 这两种无知的另一个不同在于，第一种无知可以让人无知无畏，因为自己不会认识到这种无知。第二种反而让人小心翼翼，知道自己不懂这方面的知识，或者咨询专业人士，或者恶补相关的知识。我们人生下来，所有的知识都在脑袋的外部，所以，我们最初处于一个纯粹的 uninformed ignorance 状态, 所以，从无知到有知，必然要经过两个过程，第一个过程是从第一种无知变到第二种无知；第二种是消灭部分的第二类无知，达到部分有知。 这两个过程其实截然不同，但是实际上我们常常把他们混淆。</p>

<p>第一个过程其实是非常轻松愉快的过程，甚至不需要花太多的力气。有句话叫见多识广，就是说游山玩水也能增广见识。 在互联网发达的今天，随便点几个链接，随便查几个维基百科，都能够让人获得“增长见闻”的感觉。 这是一个好事，因为我们更加容易的发现自己的无知。 同时，在这个过程里也很容易有认知满足感。 所以，很多人不知不觉的觉得每天只要“增广见闻”就行了，轻松愉快又每天都有新的见闻输入，是多么美好的事情呀。不幸的是，这个过程至多只能让人 informed, 而不能让人 knowledgeable。 想要 knowledge, 绕不过去的是持久的，深入的，有系统的学习。更加不幸的是，这个过程是不那么轻松愉快的。</p>

<p>我上高中的时候非常喜欢数学，正好图书馆里面有大学数学书，我就不管看得懂看不懂都借来看，看着那些如“微分方程”，“复变函数”之类的名词觉得很欣喜，虽然是不断的发现自己以前的无知，却也觉得学到了新东西，新名词，新概念。可是总所周知，“看”是不需要花费任何脑力的，尤其是从不知道到知道自己不知道这个状态，简直就是所谓的顿悟（由此我也怀疑所谓的顿悟其实可能也是突然间觉得自己是个笨蛋，也就悟了）。 就这样，我一度以为自己在数学上是非常的 knowledgeable 了。 然后我大学上了数学系，我突然发现，高中看的那些书，虽然也看了，也仅仅是知道名词 ( informed ) 而已，真正的数学训练，还是等到我用书中知识做后面习题的时候才开始的，而这个过程才不是轻松愉快呢。 我不知道是不是普遍的情况，就我见到的同学，有很多高中原来很喜欢某个专业的，等到真的选了这个专业，突然就不喜欢了，这也是 be informed 和 be knowledgeable 两种认知过程不一样造成的。 这种两种认知过程，是不管怎么都没法互相替代的。换句话说，如果只想捡便宜果子吃，只做第一步，或者用第一步里面的那些轻松愉快来代替第二步，就想变成有知识的人，是不可能的。</p>

<p>缺少持久，系统和深入的学习，知识结构就会处于半调子的状态。 李笑来老师在学英语的若干文章中都提到精读和查字典的重要性。比如说，如果在学英语中满足于 informed ignorance， 遇到不认识的单词仅仅是猜一个意思，也不记下这个单词的用法的话，这个单词还是不能成为自己的词汇。然后，如果仅仅是记下用法，而不在以后有意识的练习使用（或者多次再见到）这个词的话，或许很快也就忘掉了。我们对学语言要系统的精耕细作很同意，但是未必能体会到所有其他学科都需要如此，尤其是在那些我们认为“简单”或者“零碎”的领域，我们往往像蜜蜂一样，成了不知疲倦的收集者，不断的 be informed, 而忘了 be knowledgeable 的背后，不是收集，而是学习。知道自己无知是一件非常好的事情，不过不要容忍处于 knowledge 和  be informed之间的尴尬处境，要不代理给专业人士，要不，抓紧时间学习，赶快从无知，到有知。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[胡言乱语计算机二]]></title>
    <link href="http://studentdeng.github.com/blog/2011/02/27/computer2/"/>
    <updated>2011-02-27T23:08:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2011/02/27/computer2</id>
    <content type="html"><![CDATA[<p>中断和异常处理是OS中非常重要的组成部分，当然windows也不例外，他们是我们理解OS一些概念、机制的基础。</p>

<p>中断和异常简单的来说，就是在程序正常执行流程中，突发一个事件，导致程序的执行流程转向另外的执行流程中。而我们绝大多数编写的程序都是顺序执行的，我们的确体会不到这样的机制能够给我们带来多少好处。但是这个在OS的设计中，确实深入到各个方面，以至于没有中断异常处理，现代OS根本无法构建。为了简单理解，我们可以看看这个例子。</p>

<p>比如我们准备带我们的宠物狗狗出去散步，但是由于狗狗非常淘气，经常单独行动（这里，我们是无法预知狗狗会在什么时候跑掉的），在没有任何其他道具的帮助下，我们只能每隔一段时间去看看狗狗是否跟着我们。那么用code来模仿这个行为，那么就是这个样子。</p>

<pre><code>while(living) //人的行为简单说其实就是不断的重复重复...
{
    //do something
    ...
    if(!VerifyDog())//看看狗狗还跟的没有
    {
        //狗丢了....    
    }
    ...    
}
</code></pre>

<p>如果我们这个while循环中，没有其他事情，仅仅是和狗狗在一起，那么狗狗不会丢，但是如果我们突然遇到一个美女，驻足观赏了一会之后…狗狗不见了。</p>

<p>是的，我们通过轮询这种方式，不可能保证狗狗一定会在我们身边。那么如何才能保证狗狗一定在我们身边呢？无论我们走到哪里都会紧紧跟着呢？生活常识告诉我们，只需要给狗狗戴上链子，这样狗狗就会“听话”的跟在我们左右。那么我们就可以通过这样的code来展示我们的行为。</p>

<pre><code>while(living)
{
    leash(FuncProc); 
    while(bOutSide)
    {
       //doSomeThing 
    }
    UnLeash();    
}

FuncProc()
{
    狗狗想跑,抓紧链子。：）
}
</code></pre>

<p>好了，在我们带狗狗出去玩之前，我们给狗狗栓了链子，那么我们在外出的时候，就可以随行所欲的“看美女了”。一旦狗狗有不轨行为，我们只是需要下意识的抓紧便能保证狗狗不会跑丢。而这，要比隔一段时间查看狗狗在不在要简单多了，我们可以完全从这个事情上解脱出来。做更重要的事情。而这一切，其实就是默默跑了一个异常处理的过程。</p>

<p>我们通过leash(FuncProc); 注册了一个callback函数
我们可以做我们想做的事情，而不在我们的while循环中体现任何有关狗狗的信息。
当狗狗有不轨行为时，链子第一时间通知我们狗狗的行为，然后我们能够在第一时间制止狗狗。
然后我们继续while中的事情。
当然，回家了要把狗狗放出来（大部分的狗狗都不喜欢狗链子….）。
从某种角度上来看，OS相当于人，而我们写的一些应用层的程序则相当于宠物狗狗。而异常处理，就是这条链子。对操作系统来说，他希望找到一条能够应对所有狗狗的超级链子。而在这么多狗狗中，总有那些不听话的，希望能够摆脱这条链子的狗狗。而这条链子也在这2端的发展下，变得越来越强壮。</p>

<p>这篇文章的角度就是站在OS的角度，希望找到这条能够应对各种狗狗（主要是不听话的狗狗）的链子。也就是初步学习windows 的SEH的整体设计和思路（这个帽子的确很大）。下一篇则站在狗狗的角度来学习我们如何能够摆脱这条链子（这个帽子也挺大的），也就是SEH的相关安全机制。当然这篇是理解后面的基础。</p>

<p>当然，OS本身的实现和人狗链子的关系也是微妙的。现代操作系统的整个设计是分层的。有些时候是人是狗已经不再重要了。就像真实世界的我们，我们无法从那些枷锁中挣脱，真的。我们有时候真不知道我们是人？是狗？</p>

<p>闲话扯得太多了。为了更清楚的了解异常，我们需要进一步了解我们的计算机。类似的这种程序控制流的变化，还有中断(interrupt)，陷阱(trap)，错误(fault)，终止（abort）而中断，我们通常又分为软中断，和硬中断（这个又通常省略硬字）。是的，我相信对于绝大多数的和我一个水平的菜鸟来说，这些概念都是可以令人抓狂的。而造成这样的原因主要是在于计算机的发展是在是太快速了，所以，有些概念在这个过程中得到了扩展，而这些概念又和计算机体系结构密切相关，所以我们经常看到甚至是一些权威书籍之间有概念的冲突，是的。这个当然不是人家的错误，只是处在了不同的时空，而这也就是语言的悲剧。他永远不可能给我们准确的答案，除非数学。所以这里我们需要先搞清楚这些概念。把那些恼人的语言上的细枝末节过滤掉之后，整个东东也不复杂了。当然整个学习都在我们最“熟悉”的x86下，其他平台也不不难掌握了。</p>

<p>为了减少中英文的差异，在一些概念描述上，这里就不再一次引入另一门语言，虽然他是伟大的语言。为了能够较为清晰的了解他们之间的区别。我们不得不扯一些硬件相关的知识，事实上，也许这些“旁敲侧击”让你回想到了学校的那些认为不重要的课程《机组》《模电》《计算机体系结构》《微机原理接口》等。</p>

<p>在8086下，原谅我再次重复，有2种这样的机制。interrupt、exception。interrupt分为可屏蔽中断和不可屏蔽中断。exception分为 fault、trap、abort。概念有点多，慢慢来。</p>

<p>经过上一篇的胡扯，我们知道了CPU眼中，把这些硬件当成逻辑存储器，最后和存储器构成一个地址空间。但是有些笼统，这里稍微再了解一点。和CPU通过总线相连的芯片除了各种存储器外，还有3种芯片</p>

<ul>
<li>各种接口卡（显卡，网卡）上的接口芯片，它们控制接口卡</li>
<li>主板上的接口芯片，CPU通过它们对一些外设访问</li>
<li>其他芯片，存储相关的系统信息或对输入输出处理</li>
</ul>


<p>而这些芯片都有一组可以由CPU读写的寄存器。这些寄存器有2点相同。</p>

<ul>
<li>和CPU总线相连。</li>
<li>CPU对它们进行读写是通过控制些向他们所在的芯片发出端口读写命令</li>
</ul>


<p>所以，在CPU看来，这些外部的寄存器相当于端口，并对他们一起编址，从而又搞了一个端口地址空间，或是叫做IO端口空间。这里再扯的远一点，事实上，在x86下，我们现在知道有2个地址空间，一个是存储器的地址空间还有一个是IO地址空间，为什么不把IO地址空间也映射到存储器地址空间中呢？这样我们就可以再弄一些逻辑存储器了。是的这样设计的确简单，但是却浪费了一些CPU的地址空间，所以当时intel考虑到为了不浪费而又搞了一个IO地址空间，所以我们访问这些端口的时候，也就必须通过另外的指令来做。我们把这种IO编址称为独立编址。x86一共有64K个8bit的IO端口。事实上还有另一种思路和我们之前的想法一致，将这些IO的空间跑到了存储器地址空间，而这个又叫做统一编址。也就是说，这些IO寄存器与存储器单元一样看待。这样的设计在ARM中则比较常见。呵呵，有点乱，让我们看个例子。</p>

<p>那就用我们最熟悉的键盘来说。当我们在键盘上操作时，CPU是如何知道的呢？</p>

<p>键盘中有专门的芯片用于监视键盘上每一个键的状态，当我们按下一个键时，接通电路，这个芯片就会产生一个成为扫描码的东东，来表示键的位置，当键弹起的时候，同样产生一个扫描码。扫描码就保存在了键盘接口芯片的寄存器中（CPU来看这就是一个端口）。那么当键盘的输入到到端口时，我们这篇文章的主角终于来了。芯片向CPU发出中断信息。到这里，键盘的事情OK了。</p>

<p>那么芯片是如何给CPU发送中断呢？我们可以通过线将CPU和芯片连接起来，但是这样会遇到一个无法回避的问题，可以和CPU连接的线是有限的，但是CPU外部的这些设备确是非常多的，所以必须管理这些设备，让其中一些设备共享一条线。而这也就是中断控制器的作用之一，所以，真实的情况是类似如下的。</p>

<p><img src="/images/computer2.png" alt="alt text" /></p>

<p>inter x86通过2片中断控制器8259A来响应外部中断源（就是指产生中断的设备，比如键盘）。和中断控制器相连的每条线被称为中断线。我们看出如果想发送中断给CPU，那么必须得获得这条线的控制权。那么我们申请中断线的这个动作，叫做IRQ（Interrupt ReQuirement）。当然“申请中断线”这也有一个更加专业的叫法申请IRQ或是申请中断号。</p>

<p>而这个8259A做的事情就是</p>

<ul>
<li>监视中断线，检查产生的IRQ信号</li>
<li><p>如果中断线上产生了一个IRQ信号</p>

<p>  把IRQ信号转换成对应的中断向量
  这个向量存放在中断控制器的一个IO端口，CPU从而可以通过数据总线访问向量
  这个信号则发送到CPU的INTR引脚，也即是触发一个中断
  等待CPU确认中断之后，写入PIC(可编程中断控制器)的IO端口，并清INTR</p></li>
</ul>


<p>但是事实上还没有完，我们知道CPU在一个时刻只能处理一个事情。我们有那么多的外围设备，当他们都要CPU时间时，这里就有一个先后问题了。也就是需要对这些中断分级别。而且在有些特殊的中断下，是不可以被其他中断打断的。呵呵，这里就引入了可屏蔽中断和不可屏蔽中断。那么我们就可以有选择的处理一些中断，而放弃另一些中断在一些极端情况下。而且有些中断处理过程中是不可以再处理中断的。可屏蔽中断IRQ信号通常是通过CPU的INTR引脚发给CPU的。而不可屏蔽中断信号通常是通过NMI引脚发给CPU。呵呵，这就是可屏蔽中断和不可屏蔽中断区别之一。</p>

<p>那么我们再来搞定异常。</p>

<p>为了能够稍微再了解一点，我们需要知道一些CPU内部是如何执行一条指令的。原谅我这里就不赘述了。只是搞一个例子。</p>

<p>当CPU执行汇编指令IDIV。首先会检查源操作数（除数）是否为0，如果为0，则CPU在执行这条指令中，就会产生一个除零异常（在CPU眼里，汇编也成高级语言了）。通过中断的例子，我们看出，中断是CPU外部告诉CPU的执行流程需要转变。那么异常和中断最大的不同就是异常是CPU自己本身执行时发现的。中断的来源通常是外部设备，异常的来源则有3种。</p>

<ul>
<li>程序错误，当CPU在执行程序指令时遇到操作数错误或是指令非法。前者的例子就是除零，后者的例子可以是在用户模式下执行特权指令</li>
<li>某些特殊指令。这些指令的本身就是产生异常。</li>
<li>intel在P6引入了机器检查异常（Machine Check Exception）。当CPU执行指令期间检测到CPU内部或是外部硬件错误。</li>
</ul>


<p>可见，对CPU来说，中断是异步的，因为CPU完全是被动的指望外部硬件给他一个信号。而异常，则是CPU自己发起，从CPU来看则是同步的。</p>

<p>我们之前已经了解了CPU是如何获知异常，中断。那么CPU接下来的动作又是什么呢？首先需要区分出这些不同的异常，中断。具体则是需要区分出产生中断的来源，8086使用被称为中断类型码的数据来表示中断源。中断类型码为一个字节数据。8086最多可以表示256种中断源。那么接受到各种中断或是异常时，接下来需要做不同处理，那么分别处理中断或是异常的程序入口，叫做中断向量（这里可没有异常向量一回事，这里被统一看待）。而这些中断向量组成一张线性表被称为中断向量表。由于是线性表，我们可以很容易的构造一个类型码到中断向量的映射。</p>

<p>这里还需要强调一点。之前我们提到的异常的分类，那么这些异常的区别是什么呢？既然是控制流的转变，那么就有如何恢复和如何报告控制流转变这2种情况需要我们考虑，而事实上，fault abort trap 就是按照这样划分的。</p>

<ul>
<li>错误类（fault）异常是在产生这个异常指令的指令之前发起。fault通常在执行指令或是执行指令之中被CPU检测到。如果检测到，那么异常将机器的状态恢复到这条指令开始的地方，这样。指令就可以继续执行。可见错误类异常可以无缝继续执行，但是如果没有解决，则会陷入死循环。</li>
<li>陷阱（trap）异常是在产生这个异常指令完成之后，立即产生。那么异常之后的恢复就是引起这条指令的下一个指令（这个是逻辑上的，可不是空间上的）。 可见trap也是可以无缝继续执行。</li>
<li>终止（abort）异常用来报告严重的错误，而这种错误已经严重到不可恢复的地步，也可以说，我们已经不知道该如何恢复了。整个都乱了。比如一些硬件错误。</li>
</ul>


<p>当然到了80386之后，由于保护模式的引入，这部分又引入了各种门，中断们，陷阱门等等，恢复的过程也分了内核态和用户态。而这些个过程，绝大多数书籍都有相关详细的说明，这里不做赘述。有兴趣的同学可以自己翻阅。这里引入这些概念是为了对硬件处理中断有一个笼统的概念，这样会对我们理解OS是如何模拟这个异常过程提供一些帮助。</p>

<p>这里还需要再强调一点，我们可以通过一些指令来屏蔽 可屏蔽中断，事实上，大多数的外接设备都是可屏蔽中断。但是我们的异常确是不可以被屏蔽的。有了之前的基础，我们可以从硬件本身的搭建思考这个原因，也可以从整体设计去思考这样设计的原因。这里算是留个问题吧。我已经觉得我是在是太罗嗦了。</p>

<p>当然这些划分也不是非常精确，有一些错误类异常也是不能恢复执行的。哎，没办法，谁让这计算机是人造的呢。事实上，计算机的世界中充斥着“差不多”，“懒惰”这类思想，如果非要钻严谨的牛角尖只会增加自己的痛苦。因为我们不是在搞数学，有些东西可能背负着我们现在的视野所不能企及的历史问题。所以还是那句话，存在即是道理。我们没有资格对他们评头论足，在我们彻底搞出一个自认为更加合理的东西之前。当然这也是人造科学最让一些喜欢追求完美的家伙们郁闷的地方。呵呵，如果真的有可能，真的应该去拥抱数学。当然人造科学也有好处，是的。他和我们大多数的思维一致，甚至是我们现实经验的抽象，看看计算机的那些最基本的核心概念，stack queue。</p>

<p>差点忘了，还有一个软中断的概念，这里通常指的是INT n这样的指令。如果站在CPU的角度，这个明显是异常，因为这个控制流的转变是CPU内部检测到的。</p>

<p>让我们从茫茫的硬件跳出来。别忘了我们是要了解OS的异常处理。我们可对CPU的世界没有兴趣。是的。正是因为这些硬件太过于底层，而且不同的硬件结构都有不同的地方。那么操作系统如何来保证自己可以在多个这样的硬件平台上执行呢？一个最常见，最通俗的就是OS自己再抽象一个异常，中断。自己定义一个。是的，再没有比自己推倒旧体制，重建新秩序让人更兴奋的了。这样上层的应用就不需要考虑这些细枝末节了。事实上，OS是将这些异常，中断打包在一起管理的。因为他们本质上都是程序执行流程的转换。我们只能看到这是一种“跳转，恢复”而已。所以，现在我们可以忽略掉上面所讲的所有东西。（这里可能会有一种误解，所以我这里叫胡言乱语，要想完全真实的了解这些过程，intel手册，当然如果想要吃下这东西，《机组》《体系结构》….）。</p>

<p>庄子也讲，计人之所知，不若其所不知；其生之时，不若未生之时；以其至小求穷其至大之域，是故迷乱而不能自得也。这些东西还是因人而异。我这里可没有给大家传递必须要学那些硬件知识，或是鼓励大家怎么怎么做。事实上我也没有这个能力，退一步，即使我有这个能力，也没有这个资格。用自己的特例来推广到大家这本身就是一个本末倒置的问题。其实，哎，再加一句废话。存在即是理由，技术本身没有错，错的只是人的角度而已。而这也就是人造科学的悲剧，它不可能让所有人都满意，相反那些只有神才能理解的东西--数学，不以人类意志为转移。</p>

<p>让我们扯开那些鸡毛蒜皮的东西，静下心来。站在OS的角度来观察异常。那就拿我们最“熟悉”的windows。好吧。windows自己搞了一个异常处理机制。而这里面最熟悉的就是SEH了。当然这不是windows中唯一的异常处理机制。等我们了解SEH之后，再了解他。因为他并不是NT设计之初就存在的。这里可能又要绕绕了。MS真正的操作系统是NT。而95 98 只是dos的一层皮，并不真正算我们想象中的操作系统。</p>

<p>当然NT也搞了自己的一套中断的概念，只是这里。我觉得我们应该暂时放下。在OS，IO处理那部分在来讲述。我觉得这次的硬件有些多了。涉及的太多，反而不能讲述清楚了。</p>

<p>既然我们要弄一个抽象的中间值，那么我们显然只能从异常被CPU识别，然后经过各种机制之后，扔给我们来看的就是NT给我们定义的异常，也是给他自己定义的异常。</p>

<pre><code>typedef struct _EXCEPTION_RECORD { 
    DWORD ExceptionCode; 
    DWORD ExceptionFlags; 
    struct _EXCEPTION_RECORD *ExceptionRecord; 
    PVOID ExceptionAddress; 
    DWORD NumberParameters; 
    DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; 
}  EXCEPTION_RECORD;
</code></pre>

<p>EXCEPTION_RECORD 定义异常，更多的可以参考msdn，http://msdn.microsoft.com/en-us/library/aa363082(VS.85).aspx这里只是简单提几点。</p>

<p>ExceptionCode 是NT分配给异常的编码，用来表示是一个什么样的异常。比如我们最熟悉的 0xC0000005 STATUS_ACCESS_VIOLATION。</p>

<p>ExceptionAddress 则表示异常产生的地方。（这里其实是不准确的，如果我们从硬件的角度去看，因为有些地方windows替我们做了一些额外的事情。后面会提到一个例子。）</p>

<p>既然要模拟实现这种程序控制流的转换，那么我们需要提供系统一个函数执行的入口，说白了就是一个函数指针。那么就是下面的这个样子。</p>

<pre><code>EXCEPTION_DISPOSITION 
__cdecl _except_handler( 
     struct _EXCEPTION_RECORD *ExceptionRecord, 
     void * EstablisherFrame, 
     struct _CONTEXT *ContextRecord, 
     void * DispatcherContext 
     );
</code></pre>

<p>让我们先略过这些参数。思考一些问题。我们应该如何注册我们的函数入口，何时解除我们的回调函数。如果站在NT的角度，这些函数入口又该记录在哪里？</p>

<p>最直观的想法就是模仿硬件那种线性设计，搞一张表，来存储这些函数入口。但是我们这种直接想到的，往往都不是真实的设计。我这里只能猜想，由于这些设计都是20年前的东西，过多的访问外部的表，可能会冲击缓存性能。</p>

<p>那么我们怎么做才能在少影响缓存性能的情况下，还能触发程序执行流程转换？而且我们并不知道哪里会出现程序流程的转换。而且由于我们需要模拟这个流程，也就是要支持底层中的中断来让我们普通程序捕获的同时，我们还想要扩展，自定义一些异常来抛出，使得程序流程转换。这个的确是一个复杂的问题。事实上，在我们的程序中已经给我们提供了一个实现这个机制的空间。他就是计算机中里程碑的东东，堆栈。</p>

<p>堆栈是什么时候出现的，这个已经不清楚了。但是可以确定的是现在已经几乎没有能够脱离堆栈而运行的程序。堆栈给我们提供了非常出色的环境。</p>

<p>记录子程序调用轨迹，使得嵌套子程序调用成为可能
通过堆栈传递子程序调用参数，从而简化程序设计。因为寄存器的数目很可能是不够用的。
基于堆栈的程序局部变量的概念得以出现，使得模块化程序设计和结构化程序设计成为可能，也最后导致了进程，线程。
程序执行的轨迹和局部变量结合一起成为“脉络”即上下文。这给我们恢复程序执行，跳转程序执行提供了保障，甚至后面的调度。
我猜想，正是因为SEH的设计和堆栈密不可分，所以才叫“结构化异常处理”吧。</p>

<p>回想一开始的那个带狗狗出去玩的例子，栓链子和解开链子，构成了一段受保护的空间。事实上，编译器在给我们构造可以支持SEH的环境时，也是这样的。进入<strong>try block之前，加保护，在当前程序的堆栈空间中构造一些结构，也就是我们的回调函数入口等其他一些必要的结构。而当我们离开</strong>try block 之后，则就像释放普通的临时变量一样释放掉这些结构体。而且堆栈还有其他的好处，由于我们可以根据堆栈去构造类似printf的不定参数的功能，所以，编译器在支持NT的SEH机制时，可以加入其他一些结构，这样比较方便的扩展和优化这些基本的机制，从而提高效率。减少支持异常的开销。而且事实上，对于异常的开销，如果没有触发异常，现代的编译器已经几乎做到零开销，只是当真正的触发异常时，效率会大幅下降。当然。异常提供了非常强大的转换程序流程的能力，而这也是那些病毒，木马最喜欢的事情。更不说这些相关的SEH结构体就构造在程序的堆栈中，这种没有任何保护的地方。所以需要非常多的安全机制协同保护。而这些问题，大概直到vista后win7才基本上做到了完美，或是那些牛人还没有找到漏洞。</p>

<p>所以说，我们自定义的异常，一般都是程序执行流程中的极端情况，万万不能像理解硬件中断那种思想去理解，也就是异常是不能用来控制程序中大多数流程转变。只能用于极端情况，作为最后的手段。当然，这个可能并不是20年前的那些牛人都能想到的。相关的有关SEH编译器级实现可以参考</p>

<p>Matt Pietrek的文章</p>

<p>http://www.microsoft.com/msj/0197/exception/exception.aspx，</p>

<p>还有我自己写的2篇。</p>

<p>http://www.cnblogs.com/studentdeng/archive/2010/12/15/1907232.html</p>

<p>http://www.cnblogs.com/studentdeng/archive/2010/12/21/1912991.html</p>

<p>原谅我把我的文章和Matt Pietrek的放到一起。当然，这些东西都是最最基础的。</p>

<p>但是这篇可不是去学习具体的实现机制，要明白这个，还是需要一定的汇编基础和多一些的耐心，其实，怎么说呢，对于c的反汇编，主要还是靠耐心吧，没有太多的技术（纯个人感觉，我觉得c++的需要更多些技术）。而且如果再稍微了解一点SEH的安全机制，就会发现，我们似乎又回到了最开始的想法。构造一个表来保存这些回调函数的一些信息。呵呵，事物的发展似乎又回到了原点，但是我们的认识却不在一个层面上了。螺旋发展，也增加了我们学习这些古老东东的难度。真的，有时候真不知道为什么自己会处在这个时代。20年前的操作系统还有人敢说能够比较全面地了解。对于现在的千万级，有的linux甚至是亿级代码量来说。呼呼。穷极一生也仅仅皮毛而已，不过对于计算机这种新科学来说，还能搞个皮毛。而物理，数学那就是还没了解就over了。。。。。。</p>

<p>对比之前的硬件结构，我们已经了解了我们自定义的“异常信号”，“异常向量”。那么我们又是如何根据“异常信号”找到这些“异常向量”呢？那么我们就必须要了解NT的异常触发的模型了。当异常跳出来时，NT的顺序是这样的。（准确说异常在用户态下，关于内核态的我们不管他）</p>

<ul>
<li>调试器 first chance</li>
<li>堆栈上的那些回调函数</li>
<li>调试器 second chance</li>
<li>环境子系统
怎么说呢，我觉得这篇真的好长，环境子系统还是放在OS进程线程那部分了解吧。现在可以把它想象成NT进程的妈吧。反正只要是要创建一个进程都要告她一下。当异常最后也没找到属于他的回调函数，那么就给他妈管教了。当然，NT之所以这样设计异常，就是要构建一个非常强壮的设计。能够将问题层层分类解决。是的，当问题复杂到一定程度之后，虽然我们通常的理解是一步到位会快些，但是事实往往分层更容易开发，维护，管理和甚至是优化。如果不分层，那么想象，搞这么多信息，还需要能支持用户扩展，而且，这个异常处理充斥整个系统本身设计。MS如何能够协同那么多人开发，即使都是天才？</li>
</ul>


<p>整个NT处理异常就是这样的，异常来了，OS先找debugger，debugger不管，那就在程序堆栈上找人，也不管，唉，debugger你还不管？ 好吧，subsystem你搞定吧。对于这种谁都不管的异常，正式一点的叫法是未处理异常，这个也其实是比较复杂的，因为2K， XP，vista的策略都不同。策略本身不复杂但为什么不同？ 有机会的话，需要再深入一点学习一点。</p>

<p>这里面对大多数同学，如果不了解汇编的话，可能无法理解这个调试器为什么要跑2次？要知道我们现在可是在和效率赛跑，而且为什么调试器首先要捕获异常？而不是我们本身的程序？</p>

<p>我们想一个问题。在我们使用debugger调试程序的时候，我们的程序凭什么能够加入断点，然后停下来？CPU执行可是老老实实的按照一条条的指令跑的，没有那些花花肠子。当我们单步调试的时候，为什么程序执行一条指令（我这里指调试汇编代码，调试c，c++这些还需要稍微麻烦一点）就要停下来呢？当我们有了中断的概念就不难理解这个问题了。是的。就是发生了中断。导致CPU暂停了当前被调试进程，而把控制流转向到了debugger。那么怎么暂停？为什么能够暂停？这个还是交给OS的调度和同步那里再学习吧。</p>

<p>事实上，这个断点（我说的这种）就是指令INT 3。他可以说是我们非常熟悉，但又陌生的。不知道大家在一开始用c编程的时候，至少是我自己，在辛苦了半天之后，一运行发现屏幕上跑出一大堆烫烫烫烫。事实上，他就是INT 3。</p>

<p>INT 3的机器码是1100 1100b（0xCC）。一个字节长。编译器在debug下会给我们创建额外的栈空间并填上INT 3，至于为什么这样，我这里就不啰嗦了。这种纯菜鸟错误，通常是没把指针玩明白。有点远，呵呵，为什么扯这么远，是因为在有了之前的硬件知识，这里很可能产生疑问。看这个指令的样子，我们发现他是个软中断，或称为trap。那么根据之前所讲的，这里的异常地址应该是这条指令的下一条。但是我们这里看到的却是我们打断点的这条指令。那么要搞清楚这个，又要稍微绕绕下。当我们加入一个断点的时候，vc会自动记录下我们这个断点的位置信息。当调试的时候，vc会把这些断点位置处的指令换成我们的INT 3。也就是替换掉一个字节。当然，替换之前要保存原来的。这个过程叫做落实断点（resolve break point）。那么当CPU执行到INT 3指令时。是的。这时我们就明白了，为什么要先让调试器捕获异常了。这些东西要是先给了我们做，那么调试器就没法子实现功能了。然后就是一系列的硬件，OS的事情。vc把之前我们的代码再恢复过来。所以这也就是RtlRaiseException产生的软件异常并不会先扔给debugger first chance。因为我们自己搞得东西是不可能和debugger有任何关系的。</p>

<p>我们这里需要特别关注下NT干的事。</p>

<p>对于NT来说，INT 3 会导致CPU执行KiTrap03程序。（为什么执行这个，我们在IO那里再了解）。在WRK中，我们可以看到这部分的源代码。这里不得不提MS，不知道哪个脑子别了改锥的人想出了一个这么限定，代码不能超过50行。无语。</p>

<pre><code>mov     esi, ecx                ; ExceptionInfo 2
mov     edi, edx                ; ExceptionInfo 3
mov     edx, eax                ; ExceptionInfo 1

mov     ebx, [ebp]+TsEip
dec     ebx                     ; (ebx)-&gt; int3 instruction
mov     ecx, 3
mov     eax, STATUS_BREAKPOINT
call    CommonDispatchException ; Never return
</code></pre>

<p>不管怎么说，人家总是做出贡献了。我们看到了dec ebx。是的。在处理异常的时候，nt这里修正了一下，而那个1，就是INT 3这条指令的长度。现在我们就明白为什么我们能正确看到我们的代码了。也验证了trap的流程。</p>

<p>绕了很远，把思路拉回来。</p>

<p>让我们再思考一个问题，程序流程突然转变了，甚至可能永远回不来了，而且我们现在的代码是看不出这个状态。也就是我们随时都可能被别人抢了。哎，可惜啊，咱们处在最底层。人为刀俎，我为鱼肉。但是NT还是比较有人性的。而且这也是很有必要的。在程序流程突然转变了。在保护的这段代码中，可能有一些关键的操作没有做。比如内存释放，一些同步的锁等。但是由于某种未知原因，我们只能放弃这部分操作。那么我们的这部分被动代码什么时候执行呢？而且，由于这些保护的代码很可能由于函数调用，在形式上或是非形式上，都可以形成一个嵌套的关系。这些释放的顺序，从那里开始释放，释放到哪里？这都是NT需要给我们规划好的。</p>

<p>不要被我复杂的言论迷惑，实际上整个过程很简单。因为我们程序的执行流程信息都在堆栈上。我们根据堆栈信息我们可以很容易找到起点和终点。那么从问题出发点，到结束点。我们便走了2次。第一次从出发点到结束点，这是为了找到处理程序。第二次则是叫做stack unwind，栈展开。 从出发点到结束点。当然这个过程中，依然有很多更复杂的问题。异常查找时很可能产生死循环。unwind的过程也可以被随时中断或是走到其他地方。而导致我们写的那些备用代码无法执行。事实上NT给了我们非常多的选择。vc只是披了一层皮。</p>

<p>SEH就像ReactOS上写的一样，“SEH is a game which is played between OS and Compiler (Keywords: <strong>try, </strong>except, __finally)。</p>

<p>写在最后</p>

<p>我发现我越来越罗嗦了。絮叨絮叨的像个大妈。
后面的部分依然有点穿越。在不谈具体实现的细节下去说清楚SEH的基本过程，对我还是太复杂了，应该是我还没有理解透彻，慢慢来吧。具体过程可以参考我推荐的3篇文章，当然。最好的方法是自己推导。
我真的不知道这篇文章是写给自己还是写给别人看的。是的。如果我是读者，当我看到这篇文章的时候，我真想向这个作者扔砖头。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[算法学习二三事]]></title>
    <link href="http://studentdeng.github.com/blog/2011/02/03/algorithms/"/>
    <updated>2011-02-03T23:02:00+08:00</updated>
    <id>http://studentdeng.github.com/blog/2011/02/03/algorithms</id>
    <content type="html"><![CDATA[<p>不得不说，有时候无知是福，看到一点有趣而深刻的东东，就能感觉到神奇。越是我们熟悉的东西，往往却是我们进一步理解深刻的障碍，而之所以是障碍是我们并不知道这个是我们理解问题的障碍。困惑中的每一次豁然开朗往往是从一点一滴的我们已经成为惯性思维中开始。越是深刻的原理，往往越是简单强大。就像爱因斯坦打破牛顿给我们原有的世界观一样。对于一个打破常规，让你重新理解问题的最简单的方法就是把你整个思考的前提否定。而带来的结果就是我们看问题的角度，层面有了更大的扩展。所以，有时候知道的太多反而不美，做一个白痴也很幸福。</p>

<p>哎，又无病呻吟了半天。之所以有上述感想。还得感谢自己的同学。由于我没有看过MIT的经典课程《算法导论》而被鄙视，而且更无语的是，我的理由是“听不懂，如果有老师的课堂发音的记录”，而事实上。这个MIT早就提供了，为了照顾想我这样的听力不好的家伙。好吧，我是个白痴，不过就像上面讲的，白痴也有白痴的幸福。这个假期，无聊的时候，不仅可以看《爱情公寓2》也可以屡屡自己的数学常识了。：）</p>

<p>《算法导论》是一名研究算法设计的课程。设计算法，我们关心的主要是2个方面，一个是性能，另一个是资源花费。当然，我们重点的是性能，我们总是希望我们的程序跑的更快。那么学习算法到底有什么用呢？这是一个经典的问题。Charles Leiserson 是这样给我们解答的。首先，列举了一大堆在实际编程中比性能更重要的东西：可维护性，模块化，功能，用户体验等等。特别是用户体验，那么既然有这么多的东东比算法重要，那么为什么我们还要学习算法呢？</p>

<h2>算法决定了可行还是不可行。</h2>

<p>在一些实时的情况下，比如机器人等嵌入式设备，我们不够快，那么就没有意义，如果我们用了太多的内存，同样不行。所以，算法这个东东，总是在我们计算机领域的最前沿部分，如人工智能，搜索引擎，数据挖掘。如果我们是在做10年前就已经实现了的东西，那么性能的确在一些情况下已经不重要了。但是，如果想做一些别人没有做过的东西，真正的实现从无到有的过程。那么其中遇到的绝大多数问题都是，数据太复杂了。没有能力在有限的资源下找到答案。这也就是为什么叫计算机科学，而不是计算机工程。（当然科学这个和名字是无关的，比如物理，从来没有那个学校叫个什么物理科学什么的。：））。不得不说，MIT的目标是为世界培养leader，而我们那破学校是为了培养farmer（这里并没有不敬在里面，而且事实上，做一个farmer挺好的，每年坐在家里，收个房租，年末村里再分个几十万，比那些城里白领好多了在物质上）。其实也不那么绝对，非要改变世界，只要是之前没有做过的程序，我们在实现之前，首先思考的一定是算法。其次，则是对他不断的优化，完善。</p>

<p>对绝大多数的刚刚参加工作的同学，往往不能体会到整个产品的创建过程。参与的仅仅是完善，算法的设计或是大体设计已经完成，所以感觉不到算法的存在。而匆匆下了学校白学的定论。而随着工作时间变长，总会遇到没有或是不能直接利用原有设计的东东，那么算法也就体现出价值了。</p>

<h2>算法是一种描述程序行为的通用语言。</h2>

<p>我们可以通过算法去描述程序的运行流程，在任何地方。他不仅能在实践中得到体现，也能在理论中得到证明。而且能够得到大家一致的看法。而这是别的永远无法做到的，比如用户体验，每个人都有自己的想法，我们不可能让所有人都满意我们的设计，而算法却可以做到，因为快就是快。放到计算机上一跑结果自知。别人无法击败你，即便是再挑剔的对手，只要你足够出色。而能够满足这样条件的前提就是，算法是一个如此一般化，基础的东西。就像Charles Leiserson 所讲，算法就像钱，你可以用钱去买吃的，喝的。而衡量这些花费的就是钱的数目。在计算机上，则是，选择一个这样的策略，需要花费多少。选择另一个策略，需要花费多少。而衡量这2个选择谁的花费多呢？是算法。</p>

<p>算法在计算机中的地位，就和数学在所有理科学科中的地位一样。我曾经问过我的数学老师一个问题，他的回答让我直到现在还记忆犹新。“老师，数学在您眼中是什么呢？”“数学是所有理科中是最奇妙的一个。因为他可以独立于其他任何学科存在而其他学科离开不了数学。”是的。能够想象物理化学离开数学之后是什么样子么？但是数学为什么能够独立存在？是因为他构建了一门语言，一门伟大的语言。使用这门语言可以让知识在任何领域中环绕，学好数学就好像有了一张无限透支的通用支票，可以在任何地方花费（黄金？）。作为一个可以让这么多地方都通用的原因中最重要的就是，他是超级稳定的。是一个说一不二的世界。一个公平的世界，绝对的世界（当然，现在数学这个概念也不准确了，这个充分体现了哲学思想，有正必有反啊：P）。他所确定的东西的结果是肯定的。没有歧义，而且不随时间变化而流动。比如，我们真实世界中交流的语言，比如“忽悠”，“猥琐”。等等。很多词义，随着时间的变化而改变了。使得很多年纪大的人，和我们这年轻人在交流上就产生了隔阂。而我们最熟悉另一个例子就是文言文，特别是其中的一些扭曲的字。但数学这种基础类学科是不会的。至少在一个可以预见的范围是稳定的，没有地域限制的。所以，数学才能站在人类科学发展的最前沿，他的每一次前进的一小步，都能改变世界。这就是数学之美。同样也是自己能够让绝大多数人接受的最大障碍。由于他改变的太慢，而且枯燥。绝大多数人无法深入的理解。当用世俗，腐烂，充满铜臭，功利的眼光看待纯净的数学世界，必然发现数学无用。而且，这的确是事实，因为大部分人，都不可能成为改变世界的家伙（这里的确不准确，因为改变世界话题太大，修理地球同样也是改变世界。）。</p>

<p>算法，同样为我们计算机构建了一个纯净的世界。一个说一不二的世界，他所确定的，没有能够反驳的。当然，就和学习数学一样，我们不是去成为数学家，学习物理，不是去成为物理学家，然后去做哪些能够改变世界的东西。学习这些基础类学科的重要在于，他提供了一个让我们和那些站在人类史上最顶尖的家伙们交流的语言，从我的角度来看。如果没学好数学，能够和牛顿，爱因斯坦交流么？没有学好算法，能够和高爷爷交流么？作为一个普通人，我们只要学习到他们身上的一点点，也就足够了。当然，这不是对所有家伙都有效，有些人总是想，和那些老家伙有什么好交流的，给我一个周杰伦的签名吧。：）</p>

<h2>学习算法还有一个原因，是的，就是兴趣。这个传说中最牛X的老师。</h2>

<p>喜欢算法，没有别的原因，是的。我就是喜欢比别人快速的感觉。喜欢数学，是的。因为大部分人数学不好。所以我就喜欢数学。迎难而上，哥就是喜欢做别人做不了的东西。是的，虽然听上去很牵强，而且比较扭曲。比较符合印象中90后的想法。不知道90后是不是能产生更多的数学家呢？</p>

<p>让我们回到我们的算法上，既然我们这么关注性能，那么什么是影响性能的因素呢？</p>

<p>对于一个计算机外行来说，首先就是计算机硬件本身的运算能力。多一个超级牛的CPU，超大的内存，固态硬盘。肯定运算快。的确，如果你拿一个超级计算机和地摊上买的一个小的计算器比运算能力。这个实在是一个很显然的结果。是的，所以，我们有些情况下，需要思考在相同条件下，到底哪个算法的性能更高。这比较的是相对速度。但是我们却不能忘了这一点。有时，我们想使用一些很一般的计算机，通过优秀的算法，来打败那些拥有更高硬件的那些家伙们，而我们则必须关心算法性能的绝对速度。那么我们该如何描述这些看似互相矛盾的东西呢？不要忘记，算法可是基础啊，我们要的是一个确切的答案。我们如何给出一个确切的答案，而这个答案不管是超级计算机，还是普通PC都能够支持呢？这就是算法中最重要的一个概念，甚至是一切分析的大前提，一个可以把这些复杂的因素都考虑在内（或是都不考虑在内）的东东转换为可以用数学分析的对象。这就是渐进分析。</p>

<p>渐进分析的基本思想是</p>

<p>忽略硬件结构</p>

<p>不使用真实世界的运行时间，而是关心运行时间的增长速度为对象</p>

<p>渐进分析是一个非常庞大的概念，我们最熟悉的，也是大多数本科院校教我们的就是Θ,O,Ω等等类似的这些符号。这里只从Θ开始。</p>

<p>对一个初学者，Θ-notation是比较容易接受的。对一个多项式，我们只需要删除掉所有的低次幂项，忽略掉常数，系数这些次要因素。就和Charles Leiserson 所讲的。这个描述，是工程方向的描述，并不是严格的数学上的定义。而对像我这样的小白来说，最大的误解就是把他当成了数学上的严格定义而产生了极大的困惑。</p>

<p><img src="/images/algorithms.png" alt="alt text" /></p>

<p>这个是一个相当经典的图，当n趋于无穷大时，Θ（n3）总能干掉Θ（n2）。不管是同样的硬件设备，还是不同的硬件设备。只是在不同的设备下，不同的算法下，我们有了一个不同的系数，低次幂项，和常数。但是，我们关心的是他随着数据输入长度的变大而产生的增速。当n超过n0时，任何的次要因素都是浮云了。我们就可以说Θ（n3）被Θ（n2）干掉了，即使Θ（n3）的硬件要比Θ（n2）好很多，在一开始的时候效率有多高。</p>

<p>这是一个伟大，cool的概念。是的，他完美的既满足了我们追求的绝对速度，也能满足我们追求的相对速度。可以说，这给了我们继续学习算法的动力。但是，事实上，在实际开发中，我们有时候却使用那些在学校中认为是效率低的算法。难道这个理论错了？当然不是，错的是我们，我们忽略了一个很大的前提，n0。在我们多数开发过程中，很少接触那些海量数据的运算。我们的运算多数是在一个较少的数据上下浮动，这个也可以说我们的硬件，资金，产品，根本不需要我们整那么大的数据。也就是n0，我们根本达不到。事实上，只要是有脑子的，看到这个图，在小于n0的前提下，都会做成正确的判断。但对于刚刚步入IT的广大学生，却总是犯下屁股决定脑袋这样愚蠢的选择。而这其实，就是做科学和做工程师的最大区别。理论和实践相互掰手腕的结果。</p>

<p>这几天，挖老赵的“坟”，找出了这么一篇。<a href="http://www.cnblogs.com/JeffreyZhao/archive/2009/05/29/1491692.html">写程序时该追求什么，什么是次要的？</a>里面有一段十分搞笑的代码，之所以这样说，是因为我自己也写过这样的代码。想想真是dt啊。回想事发现场，我记得是我看了个什么类似《面试宝典》东东，有一些题考察交换元素，事实上，你可以找到一大堆的，而且是更精妙的去交换2个元素。看到之后，如获至宝。只要是2个元素要换位置，就用。站在做科学的角度上看，这无可厚非。但是如果站在工程的角度来看。这就是明显的画蛇添足。往往花费80%的精力在提高%20的性能上，而不是去花费20%的精力提高80%的性能。这同样是刚刚步入IT的广大同学的问题。做科学需要严谨，但是在工程方面，考虑的事情非常复杂，多。我们必须要关注在核心，关键的部分。这样才能在有限的资源下，最大的做出东东来。实践中，没有任何项目的资源是足够的。MS，Google都会有资源不足的时候。我们需要学会抓住重点。当然这里并没有鄙视这些面试问题，事实上，这些问题的背后往往是考察数学思维的基本功，而不是鼓励大家这么做。就像那个经典的问题，12个小球一架天平。没有仔细，严谨的思考，能够想到这个东东能和排序问题扯上勾么？神啊，万恶的功利，给完美的数学模型批了一层邪恶的外套，使我们在追求本质的过程中迷失。</p>

<p>有关n0的问题，不仅在算法设计上，也出现在我们的设计模式之中。《设计模式》这本神书，我是没看过，也不敢看。但也隐隐感觉到类似“设计过度”的言论。这同样都是在理论和实践结合上出了问题。当然，不少理论支持者，肯定会说，那是因为你没做过那么大的项目。但事实却是，不管设计多么复杂的，还是多么简单的，实践和理论永远不可能都得到满足。windows操作系统可以说是一个我们可见的最大的项目之一了。但是windows也并不是一个微内核，在内核中也绑定了非常多的“多余”的部分从理论上看。那无疑会降低系统稳定性，提高维护难度。但是我们却不能不说windows是最成功的一套软件之一（这个之一甚至都可以去掉）。</p>

<p>当然，要想在做学问和实践找到平衡点。这个无疑是极大的挑战。只是分析理论，而不实践，那么永远不可能成为一个出色的工程师。除非你的目标是成为理论科学家。反过来，如果不理论而只是实践，不同的是，这个是可以成为一个出色的工程师。所以，这里有一句经典的话。</p>

<p>If you want to be a good programmer, you just program ever day for two years, you will be an excellent programmer. If you want to be a world-class programmer, you can program every day for ten years, or you can program every day for two years and take an algorithms class.</p>

<p>既然算法是如此的重要，那么我们该如何学呢？其实，这是一个很纠结的问题。甚至是一个鸡生蛋，蛋生鸡的问题。不学算法，你不会了解他，也不会认识到算法重要，反而。认为算法不重要，那么也就不会下功夫去学。这就又回到一开始的那个unknown unknown上了。所以，如果准备学习算法，也就意味着选择了一条坎坷的路。一开始特别迷茫，但是没有别的选择。唯有坚持，放下浮躁，功利的心态，沉浸在数学的世界中才能体会到数学的价值，数学的乐趣。也只有这样，才能坚持到最后。</p>

<p>当然，能做到这一点的，敢说体会到数学之美的家伙，全世界也没有几个人。那么作为一个普通人，我们怎么才能最大的去提高自己，更好的掌握实践和科学的平衡点呢？这个问题，我自己也没有答案。因为我既没经验又没理论。这里只是扯下我自己的理解，可能很偏激。</p>

<p>首先应该研究下<a href="http://mindhacks.cn/author/pongba/">刘未鹏</a>的很多博客内容，特别是<a href="http://mindhacks.cn/2009/01/16/hammers-and-nails/">锤子和钉子</a>。对我这样的新手来说，武器真的太少了。所以当捡到一个武器往往过于兴奋而忽视了这个武器的使用前提，往往杀鸡用牛刀，而且还达不到积极的效果。就是因为我们拿到锤子之后，所有东西看上去都像钉子。所以，我们唯有摆正心态，深入了解拥有的武器，并增加更多的武器，见更多的市面，才能坐怀不乱，达到手中有锤，心中无锤的最终境界。</p>

<p>一个稍微实际的例子。对像我这样的菜鸟来讲，大部分都会遇到这样一个问题。而且困惑很久很久。“堆排序为什么比快速排序在大多数时要慢呢？”事实上，造成这个问题的主要原因（对我）就是，没有理解明白Θ-notation。那些被忽略掉的次要因素，当然还有更重要的是数学上对概率的薄弱理解。然后我们会再映射出一大堆的数学基础知识，然后大部分人死在沙滩上（真的，这是我从小以来最大的遗憾，就是没有学好概率，而造成这个的原因居然是，这些题目初学时往往是用日常用语出题，而由于本人语文太差，总不能理解清楚题意，而对这类题目产生了极大的抵触，可见小朋友们千万不要偏科:P）。从科学的角度去，完全可以证明这个问题，但是付出的代价就是没有硕士以上的数学能力的玩家，没有机会理解到那个层次。那么，其实我们可以从另一个角度看，直接放到计算机上跑一下就可以了么。是的，我不是科学家，我只需要知道结果就OK了。是啊，好在我们处在一个和谐的世界。让我们从这个庞然大物中得以解脱，所以，有时，我们需要根据自身情况，放弃一些东西，特别是那些比较能够通过实验来证明的东西。</p>

<p>好吧，总不能啥也放弃吧，都放弃了那到底也简单了。这里，我只能说，我推荐SGI STL。在我看来，这是一个结合了设计模式，理论算法与实践最好的一个实例。他不仅是开源的，代码量也不多，命名也算规范，而且还有一本侯捷大师的著作来诠释，帮助我们理解，而且还能帮助我们具体实践过程中规避一些错误。我们每一个在学校学习的算法，我们都可以在这里找到答案（至少可以用来做作业拿高分对某些特别的女生），而且都会比一般大学讲的深刻，事实上，我认为，大学现在的教育为什么觉得无用，不是太难太理论，而是教的太简单了，简单到已经没有用的地步了，从而根本没有实际意义。（大学联合培训机构，是我所见过的，比大学扩招还要搞笑的事情）比如快速排序，SGI STL做了非常多的优化来保证无论在什么时候，都不会退化到n2，在分的过程总是分不好时，采用堆排序。在快速排序到做最后几步，为了减少开销而采用插入排序去做哪些马上就要排好序的部分。而这些策略，并不是凭空想象，都可以在高爷爷的著作中找到理论证明，以及网上的各种论文，前提是你的数学功底足够（当然这里实践在前还是理论在前这个实在是没有讨论的意义）。所以，理论不是没有用，只是自己学的太肤浅。实践也不是没有用，只是自己没有考虑那么多的情况，想的太简单而已。</p>

<p>当然，这个可能又会引起另一个庞大的问题，“不要重复制作轮子”，不过这个已经大大超出这篇文章的范围了。我自己的看法是，STL是为了实现最基本的最通用的东东的，而实际过程中，我们往往有自己的特殊性。而这些特殊性是STL不可能设计时都给我们考虑周全的。也就是我们很可能需要扩展，重写部分以适合我们的需要。当然，现在离这些目标还很远很远很远。</p>
]]></content>
  </entry>
  
</feed>
